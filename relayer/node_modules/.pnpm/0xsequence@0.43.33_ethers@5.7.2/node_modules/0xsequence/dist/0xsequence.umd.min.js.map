{"version":3,"file":"0xsequence.umd.min.js","sources":["../../abi/src/wallet/index.ts","../../abi/src/wallet/erc1271.ts","../../abi/src/wallet/factory.ts","../../abi/src/wallet/mainModule.ts","../../abi/src/wallet/mainModuleUpgradable.ts","../../abi/src/wallet/sequenceUtils.ts","../../abi/src/wallet/libs/requireFreshSigners.ts","../../api/src/api.gen.ts","../../api/src/index.ts","../../../node_modules/.pnpm/js-base64@3.7.3/node_modules/js-base64/base64.mjs","../../../node_modules/.pnpm/@0xsequence+ethauth@0.8.1_ethers@5.7.2/node_modules/@0xsequence/ethauth/dist/index.es.js","../../config/src/bytecode.ts","../../config/src/cache.ts","../../config/src/config.ts","../../utils/src/base64.ts","../../utils/src/digest.ts","../../utils/src/is-node-or-browser.ts","../../utils/src/jwt-decode.ts","../../utils/src/logger.ts","../../utils/src/promisify.ts","../../utils/src/rand.ts","../../utils/src/sanitize.ts","../../utils/src/typed-data.ts","../../utils/src/types.ts","../../utils/src/big-number.ts","../../config/src/finder/sequence-utils-finder.ts","../../multicall/src/constants.ts","../../multicall/src/utils.ts","../../network/src/utils.ts","../../network/src/config.ts","../../network/src/context.ts","../../network/src/json-rpc/types.ts","../../network/src/json-rpc/router.ts","../../network/src/json-rpc/utils.ts","../../network/src/json-rpc/sender.ts","../../network/src/json-rpc/middleware/allow-provider.ts","../../network/src/json-rpc/middleware/cached-provider.ts","../../network/src/json-rpc/middleware/eager-provider.ts","../../network/src/json-rpc/middleware/exception-provider.ts","../../network/src/json-rpc/middleware/logging-provider.ts","../../network/src/json-rpc/middleware/network-provider.ts","../../network/src/json-rpc/middleware/signing-provider.ts","../../network/src/json-rpc/middleware/singleflight.ts","../../network/src/json-rpc-provider.ts","../../multicall/src/multicall.ts","../../multicall/src/providers/provider.ts","../../multicall/src/providers/external-provider.ts","../../multicall/src/providers/provider-middleware.ts","../../config/src/signature.ts","../../indexer/src/indexer.gen.ts","../../indexer/src/index.ts","../../metadata/src/metadata.gen.ts","../../metadata/src/index.ts","../../wallet/src/signer.ts","../../transactions/src/utils.ts","../../wallet/src/remote-signers/remote-signer.ts","../../guard/src/guard.gen.ts","../../wallet/src/utils.ts","../../wallet/src/wallet.ts","../../relayer/src/base-relayer.ts","../../relayer/src/provider-relayer.ts","../../relayer/src/rpc-relayer/relayer.gen.ts","../../relayer/src/rpc-relayer/index.ts","../../relayer/src/index.ts","../../wallet/src/account.ts","../../wallet/src/validate.ts","../../wallet/src/config.ts","../../auth/src/session.ts","../../auth/src/authorization.ts","../../auth/src/proof.ts","../../config/src/finder/config-finder.ts","../../network/src/json-rpc/middleware/public-provider.ts","../../../node_modules/.pnpm/eventemitter2@6.4.9/node_modules/eventemitter2/lib/eventemitter2.js","../../provider/src/types.ts","../../provider/src/transports/base-provider-transport.ts","../../provider/src/transports/wallet-request-handler.ts","../../provider/src/provider.ts","../../provider/src/eip191exceptions.ts","../../provider/src/utils.ts","../../provider/src/transports/base-wallet-transport.ts","../../provider/src/transports/proxy-transport/proxy-message-channel.ts","../../provider/src/transports/proxy-transport/proxy-message-provider.ts","../../provider/src/transports/mux-transport/mux-message-provider.ts","../../provider/src/transports/window-transport/window-message-provider.ts","../../provider/src/transports/extension-transport/extension-message-handler.ts","../../provider/src/transports/extension-transport/extension-message-provider.ts","../../provider/src/transports/extension-transport/base-injected-transport.ts","../../provider/src/transports/unreal-transport/overridelogs.ts","../../provider/src/transports/unreal-transport/unreal-message-provider.ts","../../provider/src/utils/index.ts","../../provider/src/wallet.ts","../../provider/src/transports/proxy-transport/proxy-message-handler.ts","../../provider/src/transports/window-transport/window-message-handler.ts","../../provider/src/transports/unreal-transport/unreal-message-handler.ts","../../relayer/src/local-relayer.ts","../../utils/src/query-string.ts","../../utils/src/sleep.ts","../../utils/src/web.ts"],"sourcesContent":["import * as erc1271 from './erc1271'\nimport * as factory from './factory'\nimport * as mainModule from './mainModule'\nimport * as mainModuleUpgradable from './mainModuleUpgradable'\nimport * as sequenceUtils from './sequenceUtils'\nimport * as requireFreshSigner from './libs/requireFreshSigners'\n\nexport const walletContracts = {\n  erc1271,\n  factory,\n  mainModule,\n  mainModuleUpgradable,\n  sequenceUtils,\n  requireFreshSigner\n}\n","export const abi = [\n  {\n    type: 'function',\n    name: 'isValidSignature',\n    constant: true,\n    inputs: [\n      {\n        type: 'bytes32'\n      },\n      {\n        type: 'bytes'\n      }\n    ],\n    outputs: [\n      {\n        type: 'bytes4'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view'\n  }\n]\n\nexport const returns = {\n  isValidSignatureBytes32: '0x1626ba7e'\n}\n","export const abi = [\n  {\n    type: 'function',\n    name: 'deploy',\n    constant: false,\n    inputs: [\n      {\n        type: 'address'\n      },\n      {\n        type: 'bytes32'\n      }\n    ],\n    outputs: [],\n    payable: true,\n    stateMutability: 'payable'\n  }\n]\n","export const abi = [\n  {\n    type: 'function',\n    name: 'nonce',\n    constant: true,\n    inputs: [],\n    outputs: [\n      {\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view'\n  },\n  {\n    type: 'function',\n    name: 'readNonce',\n    constant: true,\n    inputs: [\n      {\n        type: 'uint256'\n      }\n    ],\n    outputs: [\n      {\n        type: 'uint256'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view'\n  },\n  {\n    type: 'function',\n    name: 'updateImplementation',\n    constant: false,\n    inputs: [\n      {\n        type: 'address'\n      }\n    ],\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable'\n  },\n  {\n    type: 'function',\n    name: 'selfExecute',\n    constant: false,\n    inputs: [\n      {\n        components: [\n          {\n            type: 'bool',\n            name: 'delegateCall'\n          },\n          {\n            type: 'bool',\n            name: 'revertOnError'\n          },\n          {\n            type: 'uint256',\n            name: 'gasLimit'\n          },\n          {\n            type: 'address',\n            name: 'target'\n          },\n          {\n            type: 'uint256',\n            name: 'value'\n          },\n          {\n            type: 'bytes',\n            name: 'data'\n          }\n        ],\n        type: 'tuple[]'\n      }\n    ],\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable'\n  },\n  {\n    type: 'function',\n    name: 'execute',\n    constant: false,\n    inputs: [\n      {\n        components: [\n          {\n            type: 'bool',\n            name: 'delegateCall'\n          },\n          {\n            type: 'bool',\n            name: 'revertOnError'\n          },\n          {\n            type: 'uint256',\n            name: 'gasLimit'\n          },\n          {\n            type: 'address',\n            name: 'target'\n          },\n          {\n            type: 'uint256',\n            name: 'value'\n          },\n          {\n            type: 'bytes',\n            name: 'data'\n          }\n        ],\n        type: 'tuple[]'\n      },\n      {\n        type: 'uint256'\n      },\n      {\n        type: 'bytes'\n      }\n    ],\n    outputs: [],\n    payable: false,\n    stateMutability: 'nonpayable'\n  },\n  {\n    type: 'function',\n    name: 'createContract',\n    inputs: [\n      {\n        type: 'bytes'\n      }\n    ],\n    payable: true,\n    stateMutability: 'payable'\n  }\n]\n","export const abi = [\n  {\n    type: 'function',\n    name: 'updateImageHash',\n    constant: true,\n    inputs: [\n      {\n        type: 'bytes32'\n      }\n    ],\n    outputs: [],\n    payable: false,\n    stateMutability: 'view'\n  },\n  {\n    type: 'function',\n    name: 'imageHash',\n    constant: true,\n    inputs: [],\n    outputs: [\n      {\n        type: 'bytes32'\n      }\n    ],\n    payable: false,\n    stateMutability: 'view'\n  }\n]\n","export const abi = [\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_factory',\n        type: 'address'\n      },\n      {\n        internalType: 'address',\n        name: '_mainModule',\n        type: 'address'\n      }\n    ],\n    stateMutability: 'nonpayable',\n    type: 'constructor'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: '_wallet',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: '_imageHash',\n        type: 'bytes32'\n      },\n      {\n        indexed: false,\n        internalType: 'uint256',\n        name: '_threshold',\n        type: 'uint256'\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: '_signers',\n        type: 'bytes'\n      }\n    ],\n    name: 'RequiredConfig',\n    type: 'event'\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: '_wallet',\n        type: 'address'\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: '_signer',\n        type: 'address'\n      }\n    ],\n    name: 'RequiredSigner',\n    type: 'event'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_addr',\n        type: 'address'\n      }\n    ],\n    name: 'callBalanceOf',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callBlockNumber',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_i',\n        type: 'uint256'\n      }\n    ],\n    name: 'callBlockhash',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callChainId',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: 'id',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'pure',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_addr',\n        type: 'address'\n      }\n    ],\n    name: 'callCode',\n    outputs: [\n      {\n        internalType: 'bytes',\n        name: 'code',\n        type: 'bytes'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_addr',\n        type: 'address'\n      }\n    ],\n    name: 'callCodeHash',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: 'codeHash',\n        type: 'bytes32'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_addr',\n        type: 'address'\n      }\n    ],\n    name: 'callCodeSize',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: 'size',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callCoinbase',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callDifficulty',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callGasLeft',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callGasLimit',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callGasPrice',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callOrigin',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [],\n    name: 'callTimestamp',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    name: 'knownImageHashes',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32'\n      }\n    ],\n    name: 'lastImageHashUpdate',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    name: 'lastSignerUpdate',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address'\n      }\n    ],\n    name: 'lastWalletUpdate',\n    outputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256'\n      }\n    ],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'bool',\n            name: 'delegateCall',\n            type: 'bool'\n          },\n          {\n            internalType: 'bool',\n            name: 'revertOnError',\n            type: 'bool'\n          },\n          {\n            internalType: 'uint256',\n            name: 'gasLimit',\n            type: 'uint256'\n          },\n          {\n            internalType: 'address',\n            name: 'target',\n            type: 'address'\n          },\n          {\n            internalType: 'uint256',\n            name: 'value',\n            type: 'uint256'\n          },\n          {\n            internalType: 'bytes',\n            name: 'data',\n            type: 'bytes'\n          }\n        ],\n        internalType: 'struct IModuleCalls.Transaction[]',\n        name: '_txs',\n        type: 'tuple[]'\n      }\n    ],\n    name: 'multiCall',\n    outputs: [\n      {\n        internalType: 'bool[]',\n        name: '_successes',\n        type: 'bool[]'\n      },\n      {\n        internalType: 'bytes[]',\n        name: '_results',\n        type: 'bytes[]'\n      }\n    ],\n    stateMutability: 'payable',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_wallet',\n        type: 'address'\n      },\n      {\n        internalType: 'uint256',\n        name: '_threshold',\n        type: 'uint256'\n      },\n      {\n        components: [\n          {\n            internalType: 'uint256',\n            name: 'weight',\n            type: 'uint256'\n          },\n          {\n            internalType: 'address',\n            name: 'signer',\n            type: 'address'\n          }\n        ],\n        internalType: 'struct RequireUtils.Member[]',\n        name: '_members',\n        type: 'tuple[]'\n      },\n      {\n        internalType: 'bool',\n        name: '_index',\n        type: 'bool'\n      }\n    ],\n    name: 'publishConfig',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_wallet',\n        type: 'address'\n      },\n      {\n        internalType: 'bytes32',\n        name: '_hash',\n        type: 'bytes32'\n      },\n      {\n        internalType: 'uint256',\n        name: '_sizeMembers',\n        type: 'uint256'\n      },\n      {\n        internalType: 'bytes',\n        name: '_signature',\n        type: 'bytes'\n      },\n      {\n        internalType: 'bool',\n        name: '_index',\n        type: 'bool'\n      }\n    ],\n    name: 'publishInitialSigners',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_wallet',\n        type: 'address'\n      },\n      {\n        internalType: 'uint256',\n        name: '_nonce',\n        type: 'uint256'\n      }\n    ],\n    name: 'requireMinNonce',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function'\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '_expiration',\n        type: 'uint256'\n      }\n    ],\n    name: 'requireNonExpired',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function'\n  }\n]\n","\nexport const abi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    name: \"requireFreshSigner\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  }\n]\n","/* eslint-disable */\n// sequence-api v0.4.0 e4aaaf3a3c07a1f339226fcac3b8addcb3120c7b\n// --\n// Code generated by webrpc-gen@v0.10.x-dev with typescript@v0.10.0 generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=api.ridl -target=typescript@v0.10.0 -client -out=./clients/api.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = \"v1\"\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = \"v0.4.0\"\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = \"e4aaaf3a3c07a1f339226fcac3b8addcb3120c7b\"\n\n//\n// Types\n//\n\nexport enum SmartRampOrderStatus {\n  UNKNOWN = 'UNKNOWN',\n  RUNNING_CHECKS = 'RUNNING_CHECKS',\n  PROCESSING = 'PROCESSING',\n  FAILED = 'FAILED',\n  COMPLETE = 'COMPLETE'\n}\nexport enum SmartRampTxnStatus {\n  UNKNOWN = 'UNKNOWN',\n  SUCCESSFUL = 'SUCCESSFUL',\n  FAILED = 'FAILED'\n}\nexport enum SortOrder {\n  DESC = 'DESC',\n  ASC = 'ASC'\n}\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n  checks: RuntimeChecks\n}\n\nexport interface RuntimeChecks {\n}\n\nexport interface SequenceContext {\n  factory: string\n  mainModule: string\n  mainModuleUpgradable: string\n  guestModule: string\n  utils: string\n}\n\nexport interface User {\n  address: string\n  username: string\n  \n  avatar: string\n  bio: string\n  location: string\n  locale: string\n  backup?: boolean\n  backupConfirmed?: boolean\n  maxInvites?: number\n  updatedAt?: string\n  createdAt?: string\n  \n}\n\nexport interface WalletBackup {\n  accountAddress: string\n  secretHash: string\n  encryptedWallet: string\n  userConfirmed: boolean\n  updatedAt?: string\n  createdAt?: string\n}\n\nexport interface Friend {\n  id: number\n  userAddress: string\n  friendAddress: string\n  nickname: string\n  user?: User\n  createdAt?: string\n}\n\nexport interface InviteCode {\n  \n  \n  usesLeft: number\n  ownerAccount: string\n  email?: string\n  url: string\n  createdAt?: string\n  expiresAt?: string\n}\n\nexport interface InviteCodeAccount {\n  \n  claimedByUserAddress: string\n  claimedAt?: string\n}\n\nexport interface InviteInfo {\n  expiryInHours: number\n  max: number\n  invites: Array<InviteCode>\n}\n\nexport interface ContractCall {\n  signature: string\n  function: string\n  args: Array<TupleComponent>\n}\n\nexport interface TupleComponent {\n  name?: string\n  type: string\n  value: any\n}\n\nexport interface Transaction {\n  delegateCall: boolean\n  revertOnError: boolean\n  gasLimit: string\n  target: string\n  value: string\n  data: string\n  call?: ContractCall\n}\n\nexport interface UserStorage {\n  userAddress: string\n  key: string\n  value: any\n}\n\nexport interface Token {\n  chainId: number\n  contractAddress: string\n  tokenId?: string\n}\n\nexport interface Price {\n  value: number\n  currency: string\n}\n\nexport interface TokenPrice {\n  token: Token\n  price?: Price\n  price24hChange?: Price\n  floorPrice: Price\n  buyPrice: Price\n  sellPrice: Price\n  updatedAt: string\n}\n\nexport interface ExchangeRate {\n  name: string\n  symbol: string\n  value: number\n  vsCurrency: string\n  currencyType: string\n}\n\nexport interface PayCard {\n  id: number\n  userAddress: string\n  cardType: string\n  cardFirstNameToken: string\n  cardLastNameToken: string\n  cardNumberLastFourDigits: string\n  cardNumberToken: string\n  cardCVCToken: string\n  cardExpMonth: number\n  cardExpYear: number\n  contactAddressToken: string\n  contactCityToken: string\n  contactProvinceToken: string\n  contactPostalCodeToken: string\n  contactCountryCodeToken: string\n  contactEmailToken: string\n  contactPhoneToken: string\n  updatedAt?: string\n  createdAt?: string\n}\n\nexport interface SmartRampQuoteRequest {\n  countryCode: string\n  niftyswapContractAddress: string\n  tokenIds: Array<string>\n  tokensBoughtAmounts: Array<string>\n  maxCurrency: string\n  extraFeeRecipients?: Array<string>\n  extraFeeAmounts?: Array<string>\n}\n\nexport interface SmartRampQuoteDetails {\n  quoteId: string\n  smartScriptId: string\n  quoteRequest: SmartRampQuoteRequest\n  recipientAddress: string\n  purchaseAmount: number\n  purchaseFees: number\n  purchaseTotal: number\n  sourceCurrency: string\n  destCurrency: string\n  countryIsSupported: boolean\n  createdAt: string\n  expiresAt: string\n}\n\nexport interface SmartRampPurchaseReceipt {\n  orderId: string\n  quoteId: string\n  createdAt: string\n  status: SmartRampOrderStatus\n  errorReason?: string\n  errorCode?: string\n  authCodesRequested: boolean\n  countryCode: string\n  sourceCurrency: string\n  purchaseAmount: number\n  purchaseFees: number\n  purchaseTotal: number\n  txnHash: string\n  txnSuccessful: SmartRampTxnStatus\n}\n\nexport interface SmartRampOrder {\n  id: number\n  userAddress: string\n  contractAddress: string\n  payCardId: number\n  orderId: string\n  quoteId: string\n  status: SmartRampOrderStatus\n  errorReason: string\n  errorCode: string\n  authCodesRequested: boolean\n  countryCode: string\n  email: string\n  sourceCurrency: string\n  destCurrency: string\n  purchaseAmount: number\n  purchaseFees: number\n  purchaseTotal: number\n  smartScriptParams: {[key: string]: any}\n  txnHash: string\n  txnSuccessful: SmartRampTxnStatus\n  updatedAt?: string\n  createdAt?: string\n}\n\nexport interface PayCardAuth {\n  orderId: string\n  smsNeeded: boolean\n  card2faNeeded: boolean\n  authorization3dsUrl: string\n}\n\nexport interface Page {\n  pageSize?: number\n  page?: number\n  totalRecords?: number\n  column?: string\n  before?: any\n  after?: any\n  sort?: Array<SortBy>\n}\n\nexport interface SortBy {\n  column: string\n  order: SortOrder\n}\n\nexport interface API {\n  ping(headers?: object): Promise<PingReturn>\n  version(headers?: object): Promise<VersionReturn>\n  runtimeStatus(headers?: object): Promise<RuntimeStatusReturn>\n  getSequenceContext(headers?: object): Promise<GetSequenceContextReturn>\n  getAuthToken(args: GetAuthTokenArgs, headers?: object): Promise<GetAuthTokenReturn>\n  sendPasswordlessLink(args: SendPasswordlessLinkArgs, headers?: object): Promise<SendPasswordlessLinkReturn>\n  friendList(args: FriendListArgs, headers?: object): Promise<FriendListReturn>\n  getFriendByAddress(args: GetFriendByAddressArgs, headers?: object): Promise<GetFriendByAddressReturn>\n  searchFriends(args: SearchFriendsArgs, headers?: object): Promise<SearchFriendsReturn>\n  addFriend(args: AddFriendArgs, headers?: object): Promise<AddFriendReturn>\n  updateFriendNickname(args: UpdateFriendNicknameArgs, headers?: object): Promise<UpdateFriendNicknameReturn>\n  removeFriend(args: RemoveFriendArgs, headers?: object): Promise<RemoveFriendReturn>\n  contractCall(args: ContractCallArgs, headers?: object): Promise<ContractCallReturn>\n  decodeContractCall(args: DecodeContractCallArgs, headers?: object): Promise<DecodeContractCallReturn>\n  lookupContractCallSelectors(args: LookupContractCallSelectorsArgs, headers?: object): Promise<LookupContractCallSelectorsReturn>\n  userStorageFetch(args: UserStorageFetchArgs, headers?: object): Promise<UserStorageFetchReturn>\n  userStorageSave(args: UserStorageSaveArgs, headers?: object): Promise<UserStorageSaveReturn>\n  userStorageDelete(args: UserStorageDeleteArgs, headers?: object): Promise<UserStorageDeleteReturn>\n  userStorageFetchAll(args: UserStorageFetchAllArgs, headers?: object): Promise<UserStorageFetchAllReturn>\n  getMoonpayLink(args: GetMoonpayLinkArgs, headers?: object): Promise<GetMoonpayLinkReturn>\n  getSardineClientToken(headers?: object): Promise<GetSardineClientTokenReturn>\n  isUsingGoogleMail(args: IsUsingGoogleMailArgs, headers?: object): Promise<IsUsingGoogleMailReturn>\n  resolveENSAddress(args: ResolveENSAddressArgs, headers?: object): Promise<ResolveENSAddressReturn>\n  isValidSignature(args: IsValidSignatureArgs, headers?: object): Promise<IsValidSignatureReturn>\n  isValidMessageSignature(args: IsValidMessageSignatureArgs, headers?: object): Promise<IsValidMessageSignatureReturn>\n  isValidTypedDataSignature(args: IsValidTypedDataSignatureArgs, headers?: object): Promise<IsValidTypedDataSignatureReturn>\n  isValidETHAuthProof(args: IsValidETHAuthProofArgs, headers?: object): Promise<IsValidETHAuthProofReturn>\n  getCoinPrices(args: GetCoinPricesArgs, headers?: object): Promise<GetCoinPricesReturn>\n  getCollectiblePrices(args: GetCollectiblePricesArgs, headers?: object): Promise<GetCollectiblePricesReturn>\n  getExchangeRate(args: GetExchangeRateArgs, headers?: object): Promise<GetExchangeRateReturn>\n  memoryStore(args: MemoryStoreArgs, headers?: object): Promise<MemoryStoreReturn>\n  memoryLoad(args: MemoryLoadArgs, headers?: object): Promise<MemoryLoadReturn>\n  listPayCardsOnFile(headers?: object): Promise<ListPayCardsOnFileReturn>\n  savePayCard(args: SavePayCardArgs, headers?: object): Promise<SavePayCardReturn>\n  updatePayCardCVC(args: UpdatePayCardCVCArgs, headers?: object): Promise<UpdatePayCardCVCReturn>\n  deletePayCard(args: DeletePayCardArgs, headers?: object): Promise<DeletePayCardReturn>\n  smartRampQuote(args: SmartRampQuoteArgs, headers?: object): Promise<SmartRampQuoteReturn>\n  smartRampPurchase(args: SmartRampPurchaseArgs, headers?: object): Promise<SmartRampPurchaseReturn>\n  smartRampWaitOrderConfirmation(args: SmartRampWaitOrderConfirmationArgs, headers?: object): Promise<SmartRampWaitOrderConfirmationReturn>\n  smartRampGetOrder(args: SmartRampGetOrderArgs, headers?: object): Promise<SmartRampGetOrderReturn>\n  smartRampCheckCardAuthorization(args: SmartRampCheckCardAuthorizationArgs, headers?: object): Promise<SmartRampCheckCardAuthorizationReturn>\n  smartRampOrdersList(args: SmartRampOrdersListArgs, headers?: object): Promise<SmartRampOrdersListReturn>\n  smartRampGetOrderTxnHash(args: SmartRampGetOrderTxnHashArgs, headers?: object): Promise<SmartRampGetOrderTxnHashReturn>\n  smartRampSubmitCardAuthorization(args: SmartRampSubmitCardAuthorizationArgs, headers?: object): Promise<SmartRampSubmitCardAuthorizationReturn>\n  adminSmartRampGetOrder(args: AdminSmartRampGetOrderArgs, headers?: object): Promise<AdminSmartRampGetOrderReturn>\n  adminSmartRampListCompletedOrders(args: AdminSmartRampListCompletedOrdersArgs, headers?: object): Promise<AdminSmartRampListCompletedOrdersReturn>\n  adminSmartRampListPendingOrders(args: AdminSmartRampListPendingOrdersArgs, headers?: object): Promise<AdminSmartRampListPendingOrdersReturn>\n  getInviteInfo(headers?: object): Promise<GetInviteInfoReturn>\n  isValidAccessCode(args: IsValidAccessCodeArgs, headers?: object): Promise<IsValidAccessCodeReturn>\n  internalClaimAccessCode(args: InternalClaimAccessCodeArgs, headers?: object): Promise<InternalClaimAccessCodeReturn>\n  walletRecover(args: WalletRecoverArgs, headers?: object): Promise<WalletRecoverReturn>\n  blockNumberAtTime(args: BlockNumberAtTimeArgs, headers?: object): Promise<BlockNumberAtTimeReturn>\n  paperSessionSecret(args: PaperSessionSecretArgs, headers?: object): Promise<PaperSessionSecretReturn>\n  paperSessionSecret2(args: PaperSessionSecret2Args, headers?: object): Promise<PaperSessionSecret2Return>\n}\n\nexport interface PingArgs {\n}\n\nexport interface PingReturn {\n  status: boolean  \n}\nexport interface VersionArgs {\n}\n\nexport interface VersionReturn {\n  version: Version  \n}\nexport interface RuntimeStatusArgs {\n}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus  \n}\nexport interface GetSequenceContextArgs {\n}\n\nexport interface GetSequenceContextReturn {\n  data: SequenceContext  \n}\nexport interface GetAuthTokenArgs {\n  ewtString: string\n  testnetMode?: boolean\n}\n\nexport interface GetAuthTokenReturn {\n  status: boolean\n  jwtToken: string\n  address: string\n  user?: User  \n}\nexport interface SendPasswordlessLinkArgs {\n  email: string\n  redirectUri: string\n  intent: string\n}\n\nexport interface SendPasswordlessLinkReturn {\n  status: boolean  \n}\nexport interface FriendListArgs {\n  page?: Page\n}\n\nexport interface FriendListReturn {\n  page: Page\n  friends: Array<Friend>  \n}\nexport interface GetFriendByAddressArgs {\n  friendAddress: string\n}\n\nexport interface GetFriendByAddressReturn {\n  status: boolean\n  friend: Friend  \n}\nexport interface SearchFriendsArgs {\n  filterUsername: string\n}\n\nexport interface SearchFriendsReturn {\n  friends: Array<Friend>  \n}\nexport interface AddFriendArgs {\n  friendAddress: string\n  optionalNickname?: string\n}\n\nexport interface AddFriendReturn {\n  status: boolean\n  friend?: Friend  \n}\nexport interface UpdateFriendNicknameArgs {\n  friendAddress: string\n  nickname: string\n}\n\nexport interface UpdateFriendNicknameReturn {\n  status: boolean\n  friend?: Friend  \n}\nexport interface RemoveFriendArgs {\n  friendAddress: string\n}\n\nexport interface RemoveFriendReturn {\n  status: boolean  \n}\nexport interface ContractCallArgs {\n  chainID: string\n  contract: string\n  inputExpr: string\n  outputExpr: string\n  args: Array<string>\n}\n\nexport interface ContractCallReturn {\n  returns: Array<string>  \n}\nexport interface DecodeContractCallArgs {\n  callData: string\n}\n\nexport interface DecodeContractCallReturn {\n  call: ContractCall  \n}\nexport interface LookupContractCallSelectorsArgs {\n  selectors: Array<string>\n}\n\nexport interface LookupContractCallSelectorsReturn {\n  signatures: Array<Array<string>>  \n}\nexport interface UserStorageFetchArgs {\n  key: string\n}\n\nexport interface UserStorageFetchReturn {\n  object: any  \n}\nexport interface UserStorageSaveArgs {\n  key: string\n  object: any\n}\n\nexport interface UserStorageSaveReturn {\n  ok: boolean  \n}\nexport interface UserStorageDeleteArgs {\n  key: string\n}\n\nexport interface UserStorageDeleteReturn {\n  ok: boolean  \n}\nexport interface UserStorageFetchAllArgs {\n  keys?: Array<string>\n}\n\nexport interface UserStorageFetchAllReturn {\n  objects: {[key: string]: any}  \n}\nexport interface GetMoonpayLinkArgs {\n  url: string\n}\n\nexport interface GetMoonpayLinkReturn {\n  signedUrl: string  \n}\nexport interface GetSardineClientTokenArgs {\n}\n\nexport interface GetSardineClientTokenReturn {\n  token: string  \n}\nexport interface IsUsingGoogleMailArgs {\n  domain: string\n}\n\nexport interface IsUsingGoogleMailReturn {\n  yes: boolean  \n}\nexport interface ResolveENSAddressArgs {\n  ens: string\n}\n\nexport interface ResolveENSAddressReturn {\n  address: string\n  ok: boolean  \n}\nexport interface IsValidSignatureArgs {\n  chainId: string\n  walletAddress: string\n  digest: string\n  signature: string\n}\n\nexport interface IsValidSignatureReturn {\n  isValid: boolean  \n}\nexport interface IsValidMessageSignatureArgs {\n  chainId: string\n  walletAddress: string\n  message: string\n  signature: string\n}\n\nexport interface IsValidMessageSignatureReturn {\n  isValid: boolean  \n}\nexport interface IsValidTypedDataSignatureArgs {\n  chainId: string\n  walletAddress: string\n  typedData: any\n  signature: string\n}\n\nexport interface IsValidTypedDataSignatureReturn {\n  isValid: boolean  \n}\nexport interface IsValidETHAuthProofArgs {\n  chainId: string\n  walletAddress: string\n  ethAuthProofString: string\n}\n\nexport interface IsValidETHAuthProofReturn {\n  isValid: boolean  \n}\nexport interface GetCoinPricesArgs {\n  tokens: Array<Token>\n}\n\nexport interface GetCoinPricesReturn {\n  tokenPrices: Array<TokenPrice>  \n}\nexport interface GetCollectiblePricesArgs {\n  tokens: Array<Token>\n}\n\nexport interface GetCollectiblePricesReturn {\n  tokenPrices: Array<TokenPrice>  \n}\nexport interface GetExchangeRateArgs {\n  toCurrency: string\n}\n\nexport interface GetExchangeRateReturn {\n  exchangeRate: ExchangeRate  \n}\nexport interface MemoryStoreArgs {\n  key: string\n  value: string\n}\n\nexport interface MemoryStoreReturn {\n  ok: boolean  \n}\nexport interface MemoryLoadArgs {\n  key: string\n}\n\nexport interface MemoryLoadReturn {\n  value: string  \n}\nexport interface ListPayCardsOnFileArgs {\n}\n\nexport interface ListPayCardsOnFileReturn {\n  payCards: Array<PayCard>  \n}\nexport interface SavePayCardArgs {\n  payCard: PayCard\n}\n\nexport interface SavePayCardReturn {\n  ok: boolean\n  payCard: PayCard  \n}\nexport interface UpdatePayCardCVCArgs {\n  payCardId: number\n  payCardCVC: string\n}\n\nexport interface UpdatePayCardCVCReturn {\n  ok: boolean  \n}\nexport interface DeletePayCardArgs {\n  payCardId: number\n}\n\nexport interface DeletePayCardReturn {\n  ok: boolean  \n}\nexport interface SmartRampQuoteArgs {\n  quoteRequest: SmartRampQuoteRequest\n}\n\nexport interface SmartRampQuoteReturn {\n  status: boolean\n  quoteDetails: SmartRampQuoteDetails  \n}\nexport interface SmartRampPurchaseArgs {\n  quoteDetails: SmartRampQuoteDetails\n  payCardId: number\n  payCardCVC?: string\n}\n\nexport interface SmartRampPurchaseReturn {\n  processing: boolean\n  receipt: SmartRampPurchaseReceipt  \n}\nexport interface SmartRampWaitOrderConfirmationArgs {\n  orderId: string\n}\n\nexport interface SmartRampWaitOrderConfirmationReturn {\n  done: boolean\n  receipt: SmartRampPurchaseReceipt  \n}\nexport interface SmartRampGetOrderArgs {\n  orderId?: string\n  id?: number\n}\n\nexport interface SmartRampGetOrderReturn {\n  order: SmartRampOrder  \n}\nexport interface SmartRampCheckCardAuthorizationArgs {\n  orderId: string\n}\n\nexport interface SmartRampCheckCardAuthorizationReturn {\n  cardAuth: PayCardAuth  \n}\nexport interface SmartRampOrdersListArgs {\n  page?: Page\n  userAddressFilter?: string\n}\n\nexport interface SmartRampOrdersListReturn {\n  page: Page\n  orders: Array<SmartRampOrder>  \n}\nexport interface SmartRampGetOrderTxnHashArgs {\n  orderId: string\n}\n\nexport interface SmartRampGetOrderTxnHashReturn {\n  txnHash: string\n  txnSuccessful: SmartRampTxnStatus  \n}\nexport interface SmartRampSubmitCardAuthorizationArgs {\n  orderId: string\n  sms?: string\n  card2fa?: string\n}\n\nexport interface SmartRampSubmitCardAuthorizationReturn {\n  status: boolean  \n}\nexport interface AdminSmartRampGetOrderArgs {\n  orderId?: string\n  id?: number\n}\n\nexport interface AdminSmartRampGetOrderReturn {\n  order: SmartRampOrder  \n}\nexport interface AdminSmartRampListCompletedOrdersArgs {\n  accountAddress?: string\n}\n\nexport interface AdminSmartRampListCompletedOrdersReturn {\n  orders: Array<SmartRampOrder>  \n}\nexport interface AdminSmartRampListPendingOrdersArgs {\n  accountAddress?: string\n}\n\nexport interface AdminSmartRampListPendingOrdersReturn {\n  pendingOrders: Array<SmartRampOrder>  \n}\nexport interface GetInviteInfoArgs {\n}\n\nexport interface GetInviteInfoReturn {\n  inviteInfo: InviteInfo  \n}\nexport interface IsValidAccessCodeArgs {\n  accessCode: string\n}\n\nexport interface IsValidAccessCodeReturn {\n  status: boolean  \n}\nexport interface InternalClaimAccessCodeArgs {\n  address: string\n  accessCode: string\n}\n\nexport interface InternalClaimAccessCodeReturn {\n  status: boolean  \n}\nexport interface WalletRecoverArgs {\n  username: string\n  secretHash: string\n}\n\nexport interface WalletRecoverReturn {\n  encryptedWallet: string  \n}\nexport interface BlockNumberAtTimeArgs {\n  chainId: number\n  timestamps: Array<number>\n}\n\nexport interface BlockNumberAtTimeReturn {\n  blocks: Array<number>  \n}\nexport interface PaperSessionSecretArgs {\n  chainName: string\n  contractAddress: string\n  paramsJson: string\n  contractType: string\n}\n\nexport interface PaperSessionSecretReturn {\n  secret: string  \n}\nexport interface PaperSessionSecret2Args {\n  chainName: string\n  contractAddress: string\n  paramsJson: string\n  abi: string\n}\n\nexport interface PaperSessionSecret2Return {\n  secret: string  \n}\n\n\n  \n//\n// Client\n//\nexport class API implements API {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/API/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n  \n  ping = (headers?: object): Promise<PingReturn> => {\n    return this.fetch(\n      this.url('Ping'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status)\n        }\n      })\n    })\n  }\n  \n  version = (headers?: object): Promise<VersionReturn> => {\n    return this.fetch(\n      this.url('Version'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          version: <Version>(_data.version)\n        }\n      })\n    })\n  }\n  \n  runtimeStatus = (headers?: object): Promise<RuntimeStatusReturn> => {\n    return this.fetch(\n      this.url('RuntimeStatus'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <RuntimeStatus>(_data.status)\n        }\n      })\n    })\n  }\n  \n  getSequenceContext = (headers?: object): Promise<GetSequenceContextReturn> => {\n    return this.fetch(\n      this.url('GetSequenceContext'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          data: <SequenceContext>(_data.data)\n        }\n      })\n    })\n  }\n  \n  getAuthToken = (args: GetAuthTokenArgs, headers?: object): Promise<GetAuthTokenReturn> => {\n    return this.fetch(\n      this.url('GetAuthToken'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status), \n          jwtToken: <string>(_data.jwtToken), \n          address: <string>(_data.address), \n          user: <User>(_data.user)\n        }\n      })\n    })\n  }\n  \n  sendPasswordlessLink = (args: SendPasswordlessLinkArgs, headers?: object): Promise<SendPasswordlessLinkReturn> => {\n    return this.fetch(\n      this.url('SendPasswordlessLink'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status)\n        }\n      })\n    })\n  }\n  \n  friendList = (args: FriendListArgs, headers?: object): Promise<FriendListReturn> => {\n    return this.fetch(\n      this.url('FriendList'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          friends: <Array<Friend>>(_data.friends)\n        }\n      })\n    })\n  }\n  \n  getFriendByAddress = (args: GetFriendByAddressArgs, headers?: object): Promise<GetFriendByAddressReturn> => {\n    return this.fetch(\n      this.url('GetFriendByAddress'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status), \n          friend: <Friend>(_data.friend)\n        }\n      })\n    })\n  }\n  \n  searchFriends = (args: SearchFriendsArgs, headers?: object): Promise<SearchFriendsReturn> => {\n    return this.fetch(\n      this.url('SearchFriends'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          friends: <Array<Friend>>(_data.friends)\n        }\n      })\n    })\n  }\n  \n  addFriend = (args: AddFriendArgs, headers?: object): Promise<AddFriendReturn> => {\n    return this.fetch(\n      this.url('AddFriend'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status), \n          friend: <Friend>(_data.friend)\n        }\n      })\n    })\n  }\n  \n  updateFriendNickname = (args: UpdateFriendNicknameArgs, headers?: object): Promise<UpdateFriendNicknameReturn> => {\n    return this.fetch(\n      this.url('UpdateFriendNickname'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status), \n          friend: <Friend>(_data.friend)\n        }\n      })\n    })\n  }\n  \n  removeFriend = (args: RemoveFriendArgs, headers?: object): Promise<RemoveFriendReturn> => {\n    return this.fetch(\n      this.url('RemoveFriend'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status)\n        }\n      })\n    })\n  }\n  \n  contractCall = (args: ContractCallArgs, headers?: object): Promise<ContractCallReturn> => {\n    return this.fetch(\n      this.url('ContractCall'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          returns: <Array<string>>(_data.returns)\n        }\n      })\n    })\n  }\n  \n  decodeContractCall = (args: DecodeContractCallArgs, headers?: object): Promise<DecodeContractCallReturn> => {\n    return this.fetch(\n      this.url('DecodeContractCall'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          call: <ContractCall>(_data.call)\n        }\n      })\n    })\n  }\n  \n  lookupContractCallSelectors = (args: LookupContractCallSelectorsArgs, headers?: object): Promise<LookupContractCallSelectorsReturn> => {\n    return this.fetch(\n      this.url('LookupContractCallSelectors'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          signatures: <Array<Array<string>>>(_data.signatures)\n        }\n      })\n    })\n  }\n  \n  userStorageFetch = (args: UserStorageFetchArgs, headers?: object): Promise<UserStorageFetchReturn> => {\n    return this.fetch(\n      this.url('UserStorageFetch'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          object: <any>(_data.object)\n        }\n      })\n    })\n  }\n  \n  userStorageSave = (args: UserStorageSaveArgs, headers?: object): Promise<UserStorageSaveReturn> => {\n    return this.fetch(\n      this.url('UserStorageSave'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          ok: <boolean>(_data.ok)\n        }\n      })\n    })\n  }\n  \n  userStorageDelete = (args: UserStorageDeleteArgs, headers?: object): Promise<UserStorageDeleteReturn> => {\n    return this.fetch(\n      this.url('UserStorageDelete'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          ok: <boolean>(_data.ok)\n        }\n      })\n    })\n  }\n  \n  userStorageFetchAll = (args: UserStorageFetchAllArgs, headers?: object): Promise<UserStorageFetchAllReturn> => {\n    return this.fetch(\n      this.url('UserStorageFetchAll'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          objects: <{[key: string]: any}>(_data.objects)\n        }\n      })\n    })\n  }\n  \n  getMoonpayLink = (args: GetMoonpayLinkArgs, headers?: object): Promise<GetMoonpayLinkReturn> => {\n    return this.fetch(\n      this.url('GetMoonpayLink'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          signedUrl: <string>(_data.signedUrl)\n        }\n      })\n    })\n  }\n  \n  getSardineClientToken = (headers?: object): Promise<GetSardineClientTokenReturn> => {\n    return this.fetch(\n      this.url('GetSardineClientToken'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          token: <string>(_data.token)\n        }\n      })\n    })\n  }\n  \n  isUsingGoogleMail = (args: IsUsingGoogleMailArgs, headers?: object): Promise<IsUsingGoogleMailReturn> => {\n    return this.fetch(\n      this.url('IsUsingGoogleMail'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          yes: <boolean>(_data.yes)\n        }\n      })\n    })\n  }\n  \n  resolveENSAddress = (args: ResolveENSAddressArgs, headers?: object): Promise<ResolveENSAddressReturn> => {\n    return this.fetch(\n      this.url('ResolveENSAddress'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          address: <string>(_data.address), \n          ok: <boolean>(_data.ok)\n        }\n      })\n    })\n  }\n  \n  isValidSignature = (args: IsValidSignatureArgs, headers?: object): Promise<IsValidSignatureReturn> => {\n    return this.fetch(\n      this.url('IsValidSignature'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          isValid: <boolean>(_data.isValid)\n        }\n      })\n    })\n  }\n  \n  isValidMessageSignature = (args: IsValidMessageSignatureArgs, headers?: object): Promise<IsValidMessageSignatureReturn> => {\n    return this.fetch(\n      this.url('IsValidMessageSignature'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          isValid: <boolean>(_data.isValid)\n        }\n      })\n    })\n  }\n  \n  isValidTypedDataSignature = (args: IsValidTypedDataSignatureArgs, headers?: object): Promise<IsValidTypedDataSignatureReturn> => {\n    return this.fetch(\n      this.url('IsValidTypedDataSignature'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          isValid: <boolean>(_data.isValid)\n        }\n      })\n    })\n  }\n  \n  isValidETHAuthProof = (args: IsValidETHAuthProofArgs, headers?: object): Promise<IsValidETHAuthProofReturn> => {\n    return this.fetch(\n      this.url('IsValidETHAuthProof'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          isValid: <boolean>(_data.isValid)\n        }\n      })\n    })\n  }\n  \n  getCoinPrices = (args: GetCoinPricesArgs, headers?: object): Promise<GetCoinPricesReturn> => {\n    return this.fetch(\n      this.url('GetCoinPrices'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          tokenPrices: <Array<TokenPrice>>(_data.tokenPrices)\n        }\n      })\n    })\n  }\n  \n  getCollectiblePrices = (args: GetCollectiblePricesArgs, headers?: object): Promise<GetCollectiblePricesReturn> => {\n    return this.fetch(\n      this.url('GetCollectiblePrices'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          tokenPrices: <Array<TokenPrice>>(_data.tokenPrices)\n        }\n      })\n    })\n  }\n  \n  getExchangeRate = (args: GetExchangeRateArgs, headers?: object): Promise<GetExchangeRateReturn> => {\n    return this.fetch(\n      this.url('GetExchangeRate'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          exchangeRate: <ExchangeRate>(_data.exchangeRate)\n        }\n      })\n    })\n  }\n  \n  memoryStore = (args: MemoryStoreArgs, headers?: object): Promise<MemoryStoreReturn> => {\n    return this.fetch(\n      this.url('MemoryStore'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          ok: <boolean>(_data.ok)\n        }\n      })\n    })\n  }\n  \n  memoryLoad = (args: MemoryLoadArgs, headers?: object): Promise<MemoryLoadReturn> => {\n    return this.fetch(\n      this.url('MemoryLoad'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          value: <string>(_data.value)\n        }\n      })\n    })\n  }\n  \n  listPayCardsOnFile = (headers?: object): Promise<ListPayCardsOnFileReturn> => {\n    return this.fetch(\n      this.url('ListPayCardsOnFile'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          payCards: <Array<PayCard>>(_data.payCards)\n        }\n      })\n    })\n  }\n  \n  savePayCard = (args: SavePayCardArgs, headers?: object): Promise<SavePayCardReturn> => {\n    return this.fetch(\n      this.url('SavePayCard'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          ok: <boolean>(_data.ok), \n          payCard: <PayCard>(_data.payCard)\n        }\n      })\n    })\n  }\n  \n  updatePayCardCVC = (args: UpdatePayCardCVCArgs, headers?: object): Promise<UpdatePayCardCVCReturn> => {\n    return this.fetch(\n      this.url('UpdatePayCardCVC'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          ok: <boolean>(_data.ok)\n        }\n      })\n    })\n  }\n  \n  deletePayCard = (args: DeletePayCardArgs, headers?: object): Promise<DeletePayCardReturn> => {\n    return this.fetch(\n      this.url('DeletePayCard'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          ok: <boolean>(_data.ok)\n        }\n      })\n    })\n  }\n  \n  smartRampQuote = (args: SmartRampQuoteArgs, headers?: object): Promise<SmartRampQuoteReturn> => {\n    return this.fetch(\n      this.url('SmartRampQuote'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status), \n          quoteDetails: <SmartRampQuoteDetails>(_data.quoteDetails)\n        }\n      })\n    })\n  }\n  \n  smartRampPurchase = (args: SmartRampPurchaseArgs, headers?: object): Promise<SmartRampPurchaseReturn> => {\n    return this.fetch(\n      this.url('SmartRampPurchase'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          processing: <boolean>(_data.processing), \n          receipt: <SmartRampPurchaseReceipt>(_data.receipt)\n        }\n      })\n    })\n  }\n  \n  smartRampWaitOrderConfirmation = (args: SmartRampWaitOrderConfirmationArgs, headers?: object): Promise<SmartRampWaitOrderConfirmationReturn> => {\n    return this.fetch(\n      this.url('SmartRampWaitOrderConfirmation'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          done: <boolean>(_data.done), \n          receipt: <SmartRampPurchaseReceipt>(_data.receipt)\n        }\n      })\n    })\n  }\n  \n  smartRampGetOrder = (args: SmartRampGetOrderArgs, headers?: object): Promise<SmartRampGetOrderReturn> => {\n    return this.fetch(\n      this.url('SmartRampGetOrder'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          order: <SmartRampOrder>(_data.order)\n        }\n      })\n    })\n  }\n  \n  smartRampCheckCardAuthorization = (args: SmartRampCheckCardAuthorizationArgs, headers?: object): Promise<SmartRampCheckCardAuthorizationReturn> => {\n    return this.fetch(\n      this.url('SmartRampCheckCardAuthorization'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          cardAuth: <PayCardAuth>(_data.cardAuth)\n        }\n      })\n    })\n  }\n  \n  smartRampOrdersList = (args: SmartRampOrdersListArgs, headers?: object): Promise<SmartRampOrdersListReturn> => {\n    return this.fetch(\n      this.url('SmartRampOrdersList'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          orders: <Array<SmartRampOrder>>(_data.orders)\n        }\n      })\n    })\n  }\n  \n  smartRampGetOrderTxnHash = (args: SmartRampGetOrderTxnHashArgs, headers?: object): Promise<SmartRampGetOrderTxnHashReturn> => {\n    return this.fetch(\n      this.url('SmartRampGetOrderTxnHash'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          txnHash: <string>(_data.txnHash), \n          txnSuccessful: <SmartRampTxnStatus>(_data.txnSuccessful)\n        }\n      })\n    })\n  }\n  \n  smartRampSubmitCardAuthorization = (args: SmartRampSubmitCardAuthorizationArgs, headers?: object): Promise<SmartRampSubmitCardAuthorizationReturn> => {\n    return this.fetch(\n      this.url('SmartRampSubmitCardAuthorization'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status)\n        }\n      })\n    })\n  }\n  \n  adminSmartRampGetOrder = (args: AdminSmartRampGetOrderArgs, headers?: object): Promise<AdminSmartRampGetOrderReturn> => {\n    return this.fetch(\n      this.url('AdminSmartRampGetOrder'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          order: <SmartRampOrder>(_data.order)\n        }\n      })\n    })\n  }\n  \n  adminSmartRampListCompletedOrders = (args: AdminSmartRampListCompletedOrdersArgs, headers?: object): Promise<AdminSmartRampListCompletedOrdersReturn> => {\n    return this.fetch(\n      this.url('AdminSmartRampListCompletedOrders'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          orders: <Array<SmartRampOrder>>(_data.orders)\n        }\n      })\n    })\n  }\n  \n  adminSmartRampListPendingOrders = (args: AdminSmartRampListPendingOrdersArgs, headers?: object): Promise<AdminSmartRampListPendingOrdersReturn> => {\n    return this.fetch(\n      this.url('AdminSmartRampListPendingOrders'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          pendingOrders: <Array<SmartRampOrder>>(_data.pendingOrders)\n        }\n      })\n    })\n  }\n  \n  getInviteInfo = (headers?: object): Promise<GetInviteInfoReturn> => {\n    return this.fetch(\n      this.url('GetInviteInfo'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          inviteInfo: <InviteInfo>(_data.inviteInfo)\n        }\n      })\n    })\n  }\n  \n  isValidAccessCode = (args: IsValidAccessCodeArgs, headers?: object): Promise<IsValidAccessCodeReturn> => {\n    return this.fetch(\n      this.url('IsValidAccessCode'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status)\n        }\n      })\n    })\n  }\n  \n  internalClaimAccessCode = (args: InternalClaimAccessCodeArgs, headers?: object): Promise<InternalClaimAccessCodeReturn> => {\n    return this.fetch(\n      this.url('InternalClaimAccessCode'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status)\n        }\n      })\n    })\n  }\n  \n  walletRecover = (args: WalletRecoverArgs, headers?: object): Promise<WalletRecoverReturn> => {\n    return this.fetch(\n      this.url('WalletRecover'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          encryptedWallet: <string>(_data.encryptedWallet)\n        }\n      })\n    })\n  }\n  \n  blockNumberAtTime = (args: BlockNumberAtTimeArgs, headers?: object): Promise<BlockNumberAtTimeReturn> => {\n    return this.fetch(\n      this.url('BlockNumberAtTime'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          blocks: <Array<number>>(_data.blocks)\n        }\n      })\n    })\n  }\n  \n  paperSessionSecret = (args: PaperSessionSecretArgs, headers?: object): Promise<PaperSessionSecretReturn> => {\n    return this.fetch(\n      this.url('PaperSessionSecret'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          secret: <string>(_data.secret)\n        }\n      })\n    })\n  }\n  \n  paperSessionSecret2 = (args: PaperSessionSecret2Args, headers?: object): Promise<PaperSessionSecret2Return> => {\n    return this.fetch(\n      this.url('PaperSessionSecret2'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          secret: <string>(_data.secret)\n        }\n      })\n    })\n  }\n  \n}\n\n  \nexport interface WebRPCError extends Error {\n  code: string\n  msg: string\n\tstatus: number\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {})\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch(err) {\n      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError\n    }\n    if (!res.ok) {\n      throw data // webrpc error response\n    }\n    return data\n  })\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n","export * from './api.gen'\n\nimport { API as ApiRpc } from './api.gen'\n\nconst fetch = typeof global === 'object' ? global.fetch : window.fetch\n\nexport class SequenceAPIClient extends ApiRpc {\n  constructor(hostname: string, public jwtAuth?: string) {\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch)\n    this.fetch = this._fetch\n  }\n\n  _fetch = (input: RequestInfo, init?: RequestInit): Promise<Response> => {\n    // automatically include jwt auth header to requests\n    // if its been set on the api client\n    const headers: { [key: string]: any } = {}\n    if (this.jwtAuth && this.jwtAuth.length > 0) {\n      headers['Authorization'] = `BEARER ${this.jwtAuth}`\n    }\n\n    // before the request is made\n    init!.headers = { ...init!.headers, ...headers }\n\n    return fetch(input, init)\n  }\n}\n","/**\n *  base64.ts\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n *\n * @author Dan Kogai (https://github.com/dankogai)\n */\nconst version = '3.7.3';\n/**\n * @deprecated use lowercase `version`.\n */\nconst VERSION = version;\nconst _hasatob = typeof atob === 'function';\nconst _hasbtoa = typeof btoa === 'function';\nconst _hasBuffer = typeof Buffer === 'function';\nconst _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;\nconst _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;\nconst b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\nconst b64chs = Array.prototype.slice.call(b64ch);\nconst b64tab = ((a) => {\n    let tab = {};\n    a.forEach((c, i) => tab[c] = i);\n    return tab;\n})(b64chs);\nconst b64re = /^(?:[A-Za-z\\d+\\/]{4})*?(?:[A-Za-z\\d+\\/]{2}(?:==)?|[A-Za-z\\d+\\/]{3}=?)?$/;\nconst _fromCC = String.fromCharCode.bind(String);\nconst _U8Afrom = typeof Uint8Array.from === 'function'\n    ? Uint8Array.from.bind(Uint8Array)\n    : (it, fn = (x) => x) => new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));\nconst _mkUriSafe = (src) => src\n    .replace(/=/g, '').replace(/[+\\/]/g, (m0) => m0 == '+' ? '-' : '_');\nconst _tidyB64 = (s) => s.replace(/[^A-Za-z0-9\\+\\/]/g, '');\n/**\n * polyfill version of `btoa`\n */\nconst btoaPolyfill = (bin) => {\n    // console.log('polyfilled');\n    let u32, c0, c1, c2, asc = '';\n    const pad = bin.length % 3;\n    for (let i = 0; i < bin.length;) {\n        if ((c0 = bin.charCodeAt(i++)) > 255 ||\n            (c1 = bin.charCodeAt(i++)) > 255 ||\n            (c2 = bin.charCodeAt(i++)) > 255)\n            throw new TypeError('invalid character found');\n        u32 = (c0 << 16) | (c1 << 8) | c2;\n        asc += b64chs[u32 >> 18 & 63]\n            + b64chs[u32 >> 12 & 63]\n            + b64chs[u32 >> 6 & 63]\n            + b64chs[u32 & 63];\n    }\n    return pad ? asc.slice(0, pad - 3) + \"===\".substring(pad) : asc;\n};\n/**\n * does what `window.btoa` of web browsers do.\n * @param {String} bin binary string\n * @returns {string} Base64-encoded string\n */\nconst _btoa = _hasbtoa ? (bin) => btoa(bin)\n    : _hasBuffer ? (bin) => Buffer.from(bin, 'binary').toString('base64')\n        : btoaPolyfill;\nconst _fromUint8Array = _hasBuffer\n    ? (u8a) => Buffer.from(u8a).toString('base64')\n    : (u8a) => {\n        // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326\n        const maxargs = 0x1000;\n        let strs = [];\n        for (let i = 0, l = u8a.length; i < l; i += maxargs) {\n            strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));\n        }\n        return _btoa(strs.join(''));\n    };\n/**\n * converts a Uint8Array to a Base64 string.\n * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5\n * @returns {string} Base64 string\n */\nconst fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const utob = (src: string) => unescape(encodeURIComponent(src));\n// reverting good old fationed regexp\nconst cb_utob = (c) => {\n    if (c.length < 2) {\n        var cc = c.charCodeAt(0);\n        return cc < 0x80 ? c\n            : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))\n                + _fromCC(0x80 | (cc & 0x3f)))\n                : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))\n                    + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n                    + _fromCC(0x80 | (cc & 0x3f)));\n    }\n    else {\n        var cc = 0x10000\n            + (c.charCodeAt(0) - 0xD800) * 0x400\n            + (c.charCodeAt(1) - 0xDC00);\n        return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))\n            + _fromCC(0x80 | ((cc >>> 12) & 0x3f))\n            + _fromCC(0x80 | ((cc >>> 6) & 0x3f))\n            + _fromCC(0x80 | (cc & 0x3f)));\n    }\n};\nconst re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-8 string\n * @returns {string} UTF-16 string\n */\nconst utob = (u) => u.replace(re_utob, cb_utob);\n//\nconst _encode = _hasBuffer\n    ? (s) => Buffer.from(s, 'utf8').toString('base64')\n    : _TE\n        ? (s) => _fromUint8Array(_TE.encode(s))\n        : (s) => _btoa(utob(s));\n/**\n * converts a UTF-8-encoded string to a Base64 string.\n * @param {boolean} [urlsafe] if `true` make the result URL-safe\n * @returns {string} Base64 string\n */\nconst encode = (src, urlsafe = false) => urlsafe\n    ? _mkUriSafe(_encode(src))\n    : _encode(src);\n/**\n * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.\n * @returns {string} Base64 string\n */\nconst encodeURI = (src) => encode(src, true);\n// This trick is found broken https://github.com/dankogai/js-base64/issues/130\n// const btou = (src: string) => decodeURIComponent(escape(src));\n// reverting good old fationed regexp\nconst re_btou = /[\\xC0-\\xDF][\\x80-\\xBF]|[\\xE0-\\xEF][\\x80-\\xBF]{2}|[\\xF0-\\xF7][\\x80-\\xBF]{3}/g;\nconst cb_btou = (cccc) => {\n    switch (cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                | ((0x3f & cccc.charCodeAt(1)) << 12)\n                | ((0x3f & cccc.charCodeAt(2)) << 6)\n                | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;\n            return (_fromCC((offset >>> 10) + 0xD800)\n                + _fromCC((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)\n                | ((0x3f & cccc.charCodeAt(1)) << 6)\n                | (0x3f & cccc.charCodeAt(2)));\n        default:\n            return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)\n                | (0x3f & cccc.charCodeAt(1)));\n    }\n};\n/**\n * @deprecated should have been internal use only.\n * @param {string} src UTF-16 string\n * @returns {string} UTF-8 string\n */\nconst btou = (b) => b.replace(re_btou, cb_btou);\n/**\n * polyfill version of `atob`\n */\nconst atobPolyfill = (asc) => {\n    // console.log('polyfilled');\n    asc = asc.replace(/\\s+/g, '');\n    if (!b64re.test(asc))\n        throw new TypeError('malformed base64.');\n    asc += '=='.slice(2 - (asc.length & 3));\n    let u24, bin = '', r1, r2;\n    for (let i = 0; i < asc.length;) {\n        u24 = b64tab[asc.charAt(i++)] << 18\n            | b64tab[asc.charAt(i++)] << 12\n            | (r1 = b64tab[asc.charAt(i++)]) << 6\n            | (r2 = b64tab[asc.charAt(i++)]);\n        bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)\n            : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)\n                : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);\n    }\n    return bin;\n};\n/**\n * does what `window.atob` of web browsers do.\n * @param {String} asc Base64-encoded string\n * @returns {string} binary string\n */\nconst _atob = _hasatob ? (asc) => atob(_tidyB64(asc))\n    : _hasBuffer ? (asc) => Buffer.from(asc, 'base64').toString('binary')\n        : atobPolyfill;\n//\nconst _toUint8Array = _hasBuffer\n    ? (a) => _U8Afrom(Buffer.from(a, 'base64'))\n    : (a) => _U8Afrom(_atob(a), c => c.charCodeAt(0));\n/**\n * converts a Base64 string to a Uint8Array.\n */\nconst toUint8Array = (a) => _toUint8Array(_unURI(a));\n//\nconst _decode = _hasBuffer\n    ? (a) => Buffer.from(a, 'base64').toString('utf8')\n    : _TD\n        ? (a) => _TD.decode(_toUint8Array(a))\n        : (a) => btou(_atob(a));\nconst _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == '-' ? '+' : '/'));\n/**\n * converts a Base64 string to a UTF-8 string.\n * @param {String} src Base64 string.  Both normal and URL-safe are supported\n * @returns {string} UTF-8 string\n */\nconst decode = (src) => _decode(_unURI(src));\n/**\n * check if a value is a valid Base64 string\n * @param {String} src a value to check\n  */\nconst isValid = (src) => {\n    if (typeof src !== 'string')\n        return false;\n    const s = src.replace(/\\s+/g, '').replace(/={0,2}$/, '');\n    return !/[^\\s0-9a-zA-Z\\+/]/.test(s) || !/[^\\s0-9a-zA-Z\\-_]/.test(s);\n};\n//\nconst _noEnum = (v) => {\n    return {\n        value: v, enumerable: false, writable: true, configurable: true\n    };\n};\n/**\n * extend String.prototype with relevant methods\n */\nconst extendString = function () {\n    const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));\n    _add('fromBase64', function () { return decode(this); });\n    _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });\n    _add('toBase64URI', function () { return encode(this, true); });\n    _add('toBase64URL', function () { return encode(this, true); });\n    _add('toUint8Array', function () { return toUint8Array(this); });\n};\n/**\n * extend Uint8Array.prototype with relevant methods\n */\nconst extendUint8Array = function () {\n    const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));\n    _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });\n    _add('toBase64URI', function () { return fromUint8Array(this, true); });\n    _add('toBase64URL', function () { return fromUint8Array(this, true); });\n};\n/**\n * extend Builtin prototypes with relevant methods\n */\nconst extendBuiltins = () => {\n    extendString();\n    extendUint8Array();\n};\nconst gBase64 = {\n    version: version,\n    VERSION: VERSION,\n    atob: _atob,\n    atobPolyfill: atobPolyfill,\n    btoa: _btoa,\n    btoaPolyfill: btoaPolyfill,\n    fromBase64: decode,\n    toBase64: encode,\n    encode: encode,\n    encodeURI: encodeURI,\n    encodeURL: encodeURI,\n    utob: utob,\n    btou: btou,\n    decode: decode,\n    isValid: isValid,\n    fromUint8Array: fromUint8Array,\n    toUint8Array: toUint8Array,\n    extendString: extendString,\n    extendUint8Array: extendUint8Array,\n    extendBuiltins: extendBuiltins,\n};\n// makecjs:CUT //\nexport { version };\nexport { VERSION };\nexport { _atob as atob };\nexport { atobPolyfill };\nexport { _btoa as btoa };\nexport { btoaPolyfill };\nexport { decode as fromBase64 };\nexport { encode as toBase64 };\nexport { utob };\nexport { encode };\nexport { encodeURI };\nexport { encodeURI as encodeURL };\nexport { btou };\nexport { decode };\nexport { isValid };\nexport { fromUint8Array };\nexport { toUint8Array };\nexport { extendString };\nexport { extendUint8Array };\nexport { extendBuiltins };\n// and finally,\nexport { gBase64 as Base64 };\n","import { ethers } from 'ethers';\nimport { Base64 } from 'js-base64';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar encodeTypedDataHash = function (typedData) {\r\n    return ethers.utils._TypedDataEncoder.hash(typedData.domain, typedData.types, typedData.message);\r\n};\r\nvar encodeTypedDataDigest = function (typedData) {\r\n    var hash = encodeTypedDataHash(typedData);\r\n    var digest = ethers.utils.arrayify(ethers.utils.keccak256(hash));\r\n    return digest;\r\n};\n\nvar Proof = /** @class */ (function () {\r\n    function Proof(args) {\r\n        this.prefix = ETHAuthPrefix;\r\n        this.address = (args === null || args === void 0 ? void 0 : args.address) ? args.address.toLowerCase() : '';\r\n        this.claims = (args === null || args === void 0 ? void 0 : args.claims) ? args.claims : { app: '', iat: 0, exp: 0, v: ETHAuthVersion };\r\n        this.signature = (args === null || args === void 0 ? void 0 : args.signature) ? args.signature : '';\r\n        this.extra = (args === null || args === void 0 ? void 0 : args.extra) ? args.extra : '';\r\n    }\r\n    Proof.prototype.setIssuedAtNow = function () {\r\n        this.claims.iat = Math.round((new Date()).getTime() / 1000);\r\n    };\r\n    Proof.prototype.setExpiryIn = function (seconds) {\r\n        this.claims.exp = Math.round((new Date()).getTime() / 1000) + seconds;\r\n    };\r\n    Proof.prototype.validateClaims = function () {\r\n        return validateClaims(this.claims);\r\n    };\r\n    Proof.prototype.messageDigest = function () {\r\n        var isValid = this.validateClaims();\r\n        if (isValid.err) {\r\n            throw isValid.err;\r\n        }\r\n        return ethers.utils.arrayify(encodeTypedDataHash(this.messageTypedData()));\r\n    };\r\n    Proof.prototype.messageTypedData = function () {\r\n        var domain = __assign({}, ETHAuthEIP712Domain);\r\n        var types = {\r\n            'Claims': []\r\n        };\r\n        var message = {};\r\n        var typedData = { domain: domain, types: types, message: message };\r\n        if (this.claims.app && this.claims.app.length > 0) {\r\n            typedData.types.Claims.push({ name: 'app', type: 'string' });\r\n            typedData.message['app'] = this.claims.app;\r\n        }\r\n        if (this.claims.iat && this.claims.iat > 0) {\r\n            typedData.types.Claims.push({ name: 'iat', type: 'int64' });\r\n            typedData.message['iat'] = this.claims.iat;\r\n        }\r\n        if (this.claims.exp && this.claims.exp > 0) {\r\n            typedData.types.Claims.push({ name: 'exp', type: 'int64' });\r\n            typedData.message['exp'] = this.claims.exp;\r\n        }\r\n        if (this.claims.n && this.claims.n > 0) {\r\n            typedData.types.Claims.push({ name: 'n', type: 'uint64' });\r\n            typedData.message['n'] = this.claims.n;\r\n        }\r\n        if (this.claims.typ && this.claims.typ.length > 0) {\r\n            typedData.types.Claims.push({ name: 'typ', type: 'string' });\r\n            typedData.message['typ'] = this.claims.typ;\r\n        }\r\n        if (this.claims.ogn && this.claims.ogn.length > 0) {\r\n            typedData.types.Claims.push({ name: 'ogn', type: 'string' });\r\n            typedData.message['ogn'] = this.claims.ogn;\r\n        }\r\n        if (this.claims.v && this.claims.v.length > 0) {\r\n            typedData.types.Claims.push({ name: 'v', type: 'string' });\r\n            typedData.message['v'] = this.claims.v;\r\n        }\r\n        return typedData;\r\n    };\r\n    return Proof;\r\n}());\r\nvar validateClaims = function (claims) {\r\n    if (claims.app === '') {\r\n        return { ok: false, err: new Error('claims: app is empty') };\r\n    }\r\n    var now = Math.round((new Date()).getTime() / 1000);\r\n    var drift = 5 * 60; // 5 minutes\r\n    var max = (60 * 60 * 24 * 365) + drift; // 1 year\r\n    if (claims.v === '') {\r\n        return { ok: false, err: new Error('claims: ethauth version is empty') };\r\n    }\r\n    if (claims.iat && claims.iat !== 0 && (claims.iat > now + drift || claims.iat < now - max)) {\r\n        return { ok: false, err: new Error('claims: iat is invalid') };\r\n    }\r\n    if (claims.exp < now - drift || claims.exp > now + max) {\r\n        return { ok: false, err: new Error('claims: token has expired') };\r\n    }\r\n    return { ok: true };\r\n};\n\n// ValidateEOAProof verifies the account proof, testing if the proof claims have been signed with an\r\n// EOA (externally owned account) and will return success/failture, the account address as a string, and any errors.\r\nvar ValidateEOAProof = function (provider, chainId, proof) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var messageDigest, address;\r\n    return __generator(this, function (_a) {\r\n        messageDigest = proof.messageDigest();\r\n        address = ethers.utils.verifyMessage(messageDigest, proof.signature);\r\n        if (address.slice(0, 2) === '0x' && address.length === 42 &&\r\n            address.toLowerCase() === proof.address.toLowerCase()) {\r\n            return [2 /*return*/, { isValid: true, address: proof.address }];\r\n        }\r\n        else {\r\n            return [2 /*return*/, { isValid: false }];\r\n        }\r\n    });\r\n}); };\r\n// ValidateContractAccountProof verifies the account proof, testing if the\r\n// proof claims have been signed with a smart-contract based account by calling the EIP-1271\r\n// method of the remote contract. This method will return success/failure, the\r\n// account address as a string, and any errors. The wallet contract must be deployed in\r\n// order for this call to be successful. In order test an undeployed smart-wallet, you\r\n// will have to implement your own custom validator method.\r\nvar ValidateContractAccountProof = function (provider, chainId, proof) { return __awaiter(void 0, void 0, void 0, function () {\r\n    var messageDigest, walletCode, abi, contract, isValidSignature;\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                if (!provider || provider === undefined) {\r\n                    return [2 /*return*/, { isValid: false }];\r\n                }\r\n                messageDigest = proof.messageDigest();\r\n                return [4 /*yield*/, provider.getCode(proof.address)];\r\n            case 1:\r\n                walletCode = _a.sent();\r\n                if (walletCode === '0x' || walletCode.length <= 2) {\r\n                    throw new Error('ValidateContractAccountProof failed. unable to fetch wallet contract code');\r\n                }\r\n                abi = ['function isValidSignature(bytes32, bytes) public view returns (bytes4)'];\r\n                contract = new ethers.Contract(proof.address, abi, provider);\r\n                return [4 /*yield*/, contract.isValidSignature(messageDigest, ethers.utils.arrayify(proof.signature))];\r\n            case 2:\r\n                isValidSignature = _a.sent();\r\n                if (isValidSignature === IsValidSignatureBytes32MagicValue) {\r\n                    return [2 /*return*/, { isValid: true, address: proof.address }];\r\n                }\r\n                else {\r\n                    return [2 /*return*/, { isValid: false }];\r\n                }\r\n        }\r\n    });\r\n}); };\r\n// IsValidSignatureBytes32 is the EIP-1271 magic value we test\r\nvar IsValidSignatureBytes32MagicValue = '0x1626ba7e';\n\nvar ETHAuthVersion = '1';\r\nvar ETHAuthPrefix = 'eth';\r\nvar ETHAuthEIP712Domain = {\r\n    name: 'ETHAuth',\r\n    version: ETHAuthVersion,\r\n};\r\nvar ETHAuth = /** @class */ (function () {\r\n    function ETHAuth() {\r\n        var validators = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            validators[_i] = arguments[_i];\r\n        }\r\n        var _this = this;\r\n        this.configJsonRpcProvider = function (ethereumJsonRpcURL) { return __awaiter(_this, void 0, void 0, function () {\r\n            var netVersion;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        this.provider = new ethers.providers.JsonRpcProvider(ethereumJsonRpcURL);\r\n                        return [4 /*yield*/, this.provider.send('net_version', [])];\r\n                    case 1:\r\n                        netVersion = _a.sent();\r\n                        this.chainId = parseInt(netVersion);\r\n                        if (!this.chainId || this.chainId === 0 || this.chainId === NaN) {\r\n                            throw new Error('ethauth: unable to get chainId');\r\n                        }\r\n                        this.ethereumJsonRpcURL = ethereumJsonRpcURL;\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        }); };\r\n        this.configValidators = function () {\r\n            var validators = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                validators[_i] = arguments[_i];\r\n            }\r\n            if (validators.length == 0) {\r\n                throw new Error('validators list is empty');\r\n            }\r\n            _this.validators = validators;\r\n        };\r\n        this.encodeProof = function (proof, skipSignatureValidation) {\r\n            if (skipSignatureValidation === void 0) { skipSignatureValidation = false; }\r\n            return __awaiter(_this, void 0, void 0, function () {\r\n                var isValid, claimsJSON, proofString;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            if (proof.address.length !== 42 || proof.address.slice(0, 2) !== '0x') {\r\n                                throw new Error('ethauth: invalid address');\r\n                            }\r\n                            if (proof.signature === '' || proof.signature.slice(0, 2) !== '0x') {\r\n                                throw new Error('ethauth: invalid signature');\r\n                            }\r\n                            if (proof.extra && proof.extra.slice(0, 2) !== '0x') {\r\n                                throw new Error('ethauth: invalid extra encoding, expecting hex data');\r\n                            }\r\n                            return [4 /*yield*/, this.validateProof(proof, skipSignatureValidation)];\r\n                        case 1:\r\n                            isValid = _a.sent();\r\n                            if (!isValid) {\r\n                                throw new Error(\"ethauth: proof is invalid\");\r\n                            }\r\n                            claimsJSON = JSON.stringify(proof.claims);\r\n                            proofString = ETHAuthPrefix + '.' +\r\n                                proof.address.toLowerCase() + '.' +\r\n                                Base64.encode(claimsJSON, true) + '.' +\r\n                                proof.signature;\r\n                            if (proof.extra && proof.extra.length > 0) {\r\n                                proofString += '.' + proof.extra;\r\n                            }\r\n                            return [2 /*return*/, proofString];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        this.decodeProof = function (proofString, skipSignatureValidation) {\r\n            if (skipSignatureValidation === void 0) { skipSignatureValidation = false; }\r\n            return __awaiter(_this, void 0, void 0, function () {\r\n                var parts, prefix, address, messageBase64, signature, extra, message, claims, proof, isValid;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            parts = proofString.split('.');\r\n                            if (parts.length < 4 || parts.length > 5) {\r\n                                throw new Error('ethauth: invalid proof string');\r\n                            }\r\n                            prefix = parts[0], address = parts[1], messageBase64 = parts[2], signature = parts[3], extra = parts[4];\r\n                            // check prefix\r\n                            if (prefix !== ETHAuthPrefix) {\r\n                                throw new Error('ethauth: not an ethauth proof');\r\n                            }\r\n                            message = Base64.decode(messageBase64);\r\n                            claims = JSON.parse(message);\r\n                            proof = new Proof({ address: address, claims: claims, signature: signature, extra: extra });\r\n                            return [4 /*yield*/, this.validateProof(proof, skipSignatureValidation)];\r\n                        case 1:\r\n                            isValid = _a.sent();\r\n                            if (!isValid) {\r\n                                throw new Error(\"ethauth: proof is invalid\");\r\n                            }\r\n                            return [2 /*return*/, proof];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        this.validateProof = function (proof, skipSignatureValidation) {\r\n            if (skipSignatureValidation === void 0) { skipSignatureValidation = false; }\r\n            return __awaiter(_this, void 0, void 0, function () {\r\n                var isValidClaims, isValidSig;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            isValidClaims = this.validateProofClaims(proof);\r\n                            if (isValidClaims.err) {\r\n                                throw new Error(\"ethauth: proof claims are invalid \".concat(isValidClaims.err));\r\n                            }\r\n                            if (!(skipSignatureValidation !== true)) return [3 /*break*/, 2];\r\n                            return [4 /*yield*/, this.validateProofSignature(proof)];\r\n                        case 1:\r\n                            isValidSig = _a.sent();\r\n                            if (isValidSig !== true) {\r\n                                throw new Error('ethauth: proof signature is invalid');\r\n                            }\r\n                            _a.label = 2;\r\n                        case 2: return [2 /*return*/, true];\r\n                    }\r\n                });\r\n            });\r\n        };\r\n        this.validateProofSignature = function (proof) { return __awaiter(_this, void 0, void 0, function () {\r\n            var retIsValid, i, validator, isValid, i;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        retIsValid = [];\r\n                        i = 0;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!(i < this.validators.length)) return [3 /*break*/, 6];\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        _a.trys.push([2, 4, , 5]);\r\n                        validator = this.validators[i];\r\n                        return [4 /*yield*/, validator(this.provider, this.chainId, proof)];\r\n                    case 3:\r\n                        isValid = (_a.sent()).isValid;\r\n                        if (isValid === true) {\r\n                            // preemptively return true if we've determined it to be valid\r\n                            return [2 /*return*/, true];\r\n                        }\r\n                        retIsValid.push(isValid);\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        _a.sent();\r\n                        retIsValid.push(false);\r\n                        return [3 /*break*/, 5];\r\n                    case 5:\r\n                        i++;\r\n                        return [3 /*break*/, 1];\r\n                    case 6:\r\n                        for (i = 0; i < retIsValid.length; i++) {\r\n                            if (retIsValid[i]) {\r\n                                return [2 /*return*/, true];\r\n                            }\r\n                        }\r\n                        return [2 /*return*/, false];\r\n                }\r\n            });\r\n        }); };\r\n        this.validateProofClaims = function (proof) {\r\n            return proof.validateClaims();\r\n        };\r\n        if (validators.length == 0) {\r\n            this.validators = [ValidateEOAProof, ValidateContractAccountProof];\r\n        }\r\n        else {\r\n            this.validators = validators;\r\n        }\r\n    }\r\n    return ETHAuth;\r\n}());\n\nexport { ETHAuth, ETHAuthEIP712Domain, ETHAuthPrefix, ETHAuthVersion, IsValidSignatureBytes32MagicValue, Proof, ValidateContractAccountProof, ValidateEOAProof, encodeTypedDataDigest, encodeTypedDataHash, validateClaims };\n","/* tslint:disable */\n\n/**\n    Minimal upgradeable proxy implementation, delegates all calls to the address\n    defined by the storage slot matching the wallet address.\n\n    Inspired by EIP-1167 Implementation (https://eips.ethereum.org/EIPS/eip-1167)\n\n    deployed code:\n\n        0x00    0x36         0x36      CALLDATASIZE      cds\n        0x01    0x3d         0x3d      RETURNDATASIZE    0 cds\n        0x02    0x3d         0x3d      RETURNDATASIZE    0 0 cds\n        0x03    0x37         0x37      CALLDATACOPY\n        0x04    0x3d         0x3d      RETURNDATASIZE    0\n        0x05    0x3d         0x3d      RETURNDATASIZE    0 0\n        0x06    0x3d         0x3d      RETURNDATASIZE    0 0 0\n        0x07    0x36         0x36      CALLDATASIZE      cds 0 0 0\n        0x08    0x3d         0x3d      RETURNDATASIZE    0 cds 0 0 0\n        0x09    0x30         0x30      ADDRESS           addr 0 cds 0 0 0\n        0x0A    0x54         0x54      SLOAD             imp 0 cds 0 0 0\n        0x0B    0x5a         0x5a      GAS               gas imp 0 cds 0 0 0\n        0x0C    0xf4         0xf4      DELEGATECALL      suc 0\n        0x0D    0x3d         0x3d      RETURNDATASIZE    rds suc 0\n        0x0E    0x82         0x82      DUP3              0 rds suc 0\n        0x0F    0x80         0x80      DUP1              0 0 rds suc 0\n        0x10    0x3e         0x3e      RETURNDATACOPY    suc 0\n        0x11    0x90         0x90      SWAP1             0 suc\n        0x12    0x3d         0x3d      RETURNDATASIZE    rds 0 suc\n        0x13    0x91         0x91      SWAP2             suc 0 rds\n        0x14    0x60 0x18    0x6018    PUSH1             0x18 suc 0 rds\n    /-- 0x16    0x57         0x57      JUMPI             0 rds\n    |   0x17    0xfd         0xfd      REVERT\n    \\-> 0x18    0x5b         0x5b      JUMPDEST          0 rds\n        0x19    0xf3         0xf3      RETURN\n\n    flat deployed code: 0x363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n\n    deploy function:\n\n        0x00    0x60 0x3a    0x603a    PUSH1             0x3a\n        0x02    0x60 0x0e    0x600e    PUSH1             0x0e 0x3a\n        0x04    0x3d         0x3d      RETURNDATASIZE    0 0x0e 0x3a\n        0x05    0x39         0x39      CODECOPY\n        0x06    0x60 0x1a    0x601a    PUSH1             0x1a\n        0x08    0x80         0x80      DUP1              0x1a 0x1a\n        0x09    0x51         0x51      MLOAD             imp 0x1a\n        0x0A    0x30         0x30      ADDRESS           addr imp 0x1a\n        0x0B    0x55         0x55      SSTORE            0x1a\n        0x0C    0x3d         0x3d      RETURNDATASIZE    0 0x1a\n        0x0D    0xf3         0xf3      RETURN\n        [...deployed code]\n\n    flat deploy function: 0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3\n*/\n\nexport const WalletContractBytecode = '0x603a600e3d39601a805130553df3363d3d373d3d3d363d30545af43d82803e903d91601857fd5bf3'\n","import { WalletConfig } from './config'\n\nconst maxCachedConfigs = 10\n\nconst listKey = '@sequence.config.imageHashes'\nconst configKey = (imageHash: string) => `@sequence.config.${imageHash}`\n\nlet storage: {\n  getItem(key: string): string | null\n  setItem(key: string, value: string): void\n  removeItem(key: string): void\n}\n\ntry {\n  storage = localStorage\n} catch {\n  const map: Map<string, string> = new Map()\n  storage = {\n    getItem: key => map.get(key) ?? null,\n    setItem: (key, value) => map.set(key, value),\n    removeItem: key => map.delete(key)\n  }\n}\n\nexport function getCachedConfig(imageHash: string): WalletConfig | undefined {\n  const config = JSON.parse(storage.getItem(configKey(imageHash)) ?? 'null')\n  if (config) {\n    pushImageHash(imageHash)\n    return config\n  } else {\n    return\n  }\n}\n\nexport function cacheConfig(imageHash: string, config: WalletConfig) {\n  storage.setItem(configKey(imageHash), JSON.stringify(config))\n  pushImageHash(imageHash)\n}\n\nfunction pushImageHash(imageHash: string) {\n  let imageHashes: string[] = JSON.parse(storage.getItem(listKey) ?? '[]')\n  imageHashes = imageHashes.filter(hash => hash !== imageHash)\n  imageHashes.push(imageHash)\n  while (imageHashes.length > maxCachedConfigs) {\n    storage.removeItem(configKey(imageHashes.shift()!))\n  }\n  storage.setItem(listKey, JSON.stringify(imageHashes))\n}\n","import { ethers, Signer as AbstractSigner } from 'ethers'\nimport { WalletContext } from '@0xsequence/network'\nimport { WalletContractBytecode } from './bytecode'\nimport { cacheConfig } from './cache'\n\n// WalletConfig is the configuration of key signers that can access\n// and control the wallet\nexport interface WalletConfig {  \n  threshold: number\n  signers: {\n    weight: number\n    address: string\n  }[]\n\n  address?: string\n  chainId?: number\n}\n\nexport interface WalletState {\n  context: WalletContext\n  config?: WalletConfig\n\n  // the wallet address\n  address: string\n  \n  // the chainId of the network\n  chainId: number\n\n  // whether the wallet has been ever deployed\n  deployed: boolean\n  \n  // the imageHash of the `config` WalletConfig\n  imageHash: string\n\n  // the last imageHash of a WalletConfig, stored on-chain\n  lastImageHash?: string\n  \n  // whether the WalletConfig object itself has been published to logs\n  published?: boolean\n}\n\n// TODO: createWalletConfig and genConfig are very similar, lets update + remove one\nexport const createWalletConfig = async (threshold: number, signers: { weight: number, signer: string | AbstractSigner }[]): Promise<WalletConfig> => {\n  const config: WalletConfig = {\n    threshold,\n    signers: []\n  }\n  signers.forEach(async s => {\n    config.signers.push({\n      weight: s.weight,\n      address: AbstractSigner.isSigner(s.signer) ? await s.signer.getAddress() : s.signer,\n    })\n  })\n  if (!isUsableConfig(config)) {\n    throw new Error('wallet config is not usable')\n  }\n  return config\n}\n\n// isUsableConfig checks if a the sum of the owners in the configuration meets the necessary threshold to sign a transaction\n// a wallet that has a non-usable configuration is not able to perform any transactions, and can be considered as destroyed\nexport const isUsableConfig = (config: WalletConfig): boolean => {\n  const sum = config.signers.reduce((p, c) => ethers.BigNumber.from(c.weight).add(p), ethers.constants.Zero)\n  return sum.gte(ethers.BigNumber.from(config.threshold))\n}\n\n\nexport const isValidConfigSigners = (config: WalletConfig, signers: string[]): boolean => {\n  if (signers.length === 0) return true\n  const a = config.signers.map(s => ethers.utils.getAddress(s.address))\n  const b = signers.map(s => ethers.utils.getAddress(s))\n  let valid = true\n  b.forEach(s => {\n    if (!a.includes(s)) valid = false\n  })\n  return valid\n}\n\nexport const addressOf = (salt: WalletConfig | string, context: WalletContext, ignoreAddress: boolean = false): string => {\n  if (typeof salt === 'string') {\n    const codeHash = ethers.utils.keccak256(\n      ethers.utils.solidityPack(['bytes', 'bytes32'], [WalletContractBytecode, ethers.utils.hexZeroPad(context.mainModule, 32)])\n    )\n  \n    const hash = ethers.utils.keccak256(\n      ethers.utils.solidityPack(['bytes1', 'address', 'bytes32', 'bytes32'], ['0xff', context.factory, salt, codeHash])\n    )\n  \n    return ethers.utils.getAddress(ethers.utils.hexDataSlice(hash, 12))\n  }\n\n  if (salt.address && !ignoreAddress) return salt.address\n  return addressOf(imageHash(salt), context)\n}\n\nexport const imageHash = (config: WalletConfig): string => {\n  config = sortConfig(config)\n\n  const imageHash = config.signers.reduce(\n    (imageHash, signer) => ethers.utils.keccak256(\n      ethers.utils.defaultAbiCoder.encode(\n        ['bytes32', 'uint8', 'address'],\n        [imageHash, signer.weight, signer.address]\n      )\n    ),\n    ethers.utils.solidityPack(['uint256'], [config.threshold])\n  )\n\n  cacheConfig(imageHash, config)\n\n  return imageHash\n}\n\n// sortConfig normalizes the list of signer addreses in a WalletConfig\nexport const sortConfig = (config: WalletConfig): WalletConfig => {\n  config.signers.sort((a, b) => compareAddr(a.address, b.address))\n\n  // normalize\n  config.signers.forEach(s => s.address = ethers.utils.getAddress(s.address))\n  if (config.address) config.address = ethers.utils.getAddress(config.address)\n\n  // ensure no duplicate signers in the config\n  const signers = config.signers.map(s => s.address)\n  const signerDupes = signers.filter((c, i) => signers.indexOf(c) !== i)\n  if (signerDupes.length > 0) {\n    throw new Error('invalid wallet config: duplicate signer addresses detected in the config, ${signerDupes}')\n  }\n\n  return config\n}\n\nexport const isConfigEqual = (a: WalletConfig, b: WalletConfig): boolean => {\n  return imageHash(a) === imageHash(b)\n}\n\nexport const compareAddr = (a: string, b: string): number => {\n  const bigA = ethers.BigNumber.from(a)\n  const bigB = ethers.BigNumber.from(b)\n\n  if (bigA.lt(bigB)) {\n    return -1\n  } else if (bigA.eq(bigB)) {\n    return 0\n  } else {\n    return 1\n  }\n}\n\nexport function editConfig(config: WalletConfig, args: {\n  threshold?: ethers.BigNumberish,\n  set?: { weight: ethers.BigNumberish, address: string }[],\n  del?: { address: string }[]\n}): WalletConfig {\n  const normSigner = (s: { weight: ethers.BigNumberish, address: string }) => ({ weight: ethers.BigNumber.from(s.weight).toNumber(), address: ethers.utils.getAddress(s.address) })\n\n  const normSrcSigners = config.signers.map(normSigner)\n\n  const normSetSigners = args.set ? args.set.map(normSigner) : []\n  const normDelAddress = args.del ? args.del.map((a) => ethers.utils.getAddress(a.address)) : []\n\n  const normSetAddress = normSetSigners.map((s) => s.address)\n\n  const newSigners = normSrcSigners\n    .filter((s) => normDelAddress.indexOf(s.address) === -1 && normSetAddress.indexOf(s.address) === -1)\n    .concat(...normSetSigners)\n\n  return sortConfig({\n    address: config.address,\n    threshold: args.threshold ? ethers.BigNumber.from(args.threshold).toNumber() : config.threshold,\n    signers: newSigners\n  })\n}\n\n// TODO: very similar to createWalletConfig, but doesn't allow an AbstractSigner object\n// TODO: lets also check isUsableConfig before returning it\nexport function genConfig(threshold: ethers.BigNumberish, signers: { weight: ethers.BigNumberish, address: string }[]): WalletConfig {\n  return sortConfig({\n    threshold: ethers.BigNumber.from(threshold).toNumber(),\n    signers: signers.map((s) => ({ weight: ethers.BigNumber.from(s.weight).toNumber(), address: ethers.utils.getAddress(s.address) }))\n  })\n}\n","import { Base64 } from 'js-base64'\n\nexport const base64Encode = (val: string): string => {\n  return Base64.encode(val, true)\n}\n\nexport const base64EncodeObject = (obj: any): string => {\n  return Base64.encode(JSON.stringify(obj), true)\n}\n\nexport const base64Decode = (encodedString: string): string | undefined => {\n  if (encodedString === null || encodedString === undefined) {\n    return undefined\n  }\n  return Base64.decode(encodedString)\n}\n\nexport const base64DecodeObject = <T = any>(encodedObject: string | null): T | undefined => {\n  if (encodedObject === null || encodedObject === undefined) {\n    return undefined\n  }\n  return JSON.parse(Base64.decode(encodedObject)) as T\n}\n","import { ethers } from 'ethers'\n\nexport const encodeMessageDigest = (message: string | Uint8Array) => {\n  if (typeof(message) === 'string') {\n    return ethers.utils.arrayify(ethers.utils.keccak256(ethers.utils.toUtf8Bytes(message)))\n  } else {\n    return ethers.utils.arrayify(ethers.utils.keccak256(message))\n  }\n}\n\n// packMessageData encodes the specified data ready for the Sequence Wallet contracts.\nexport const packMessageData = (walletAddress: string, chainId: ethers.BigNumberish, digest: ethers.BytesLike): string => {\n  return ethers.utils.solidityPack(\n    ['string', 'uint256', 'address', 'bytes32'],\n    ['\\x19\\x01', chainId, walletAddress, digest]\n  )\n}\n\nexport const subDigestOf = (address: string, chainId: ethers.BigNumberish, digest: ethers.BytesLike): string => {\n  return ethers.utils.keccak256(\n    packMessageData(address, chainId, digest)\n  )\n}\n","export const isNode = () => {\n  if (typeof window === 'undefined' && typeof process === 'object') {\n    return true\n  } else {\n    return false\n  }\n}\n\nexport const isBrowser = () => !isNode()\n","import { Base64 } from 'js-base64'\n\nexport const jwtDecodeClaims =  <T = any>(jwt: string) => {\n  const parts = jwt.split('.')\n  if (parts.length !== 3) {\n    throw new Error('invalid jwt')\n  }\n  const claims = JSON.parse(Base64.decode(parts[1])) as T\n  return claims\n}\n","export type LogLevel = 'DEBUG' | 'INFO' | 'WARN' | 'ERROR' | 'DISABLED'\n\nenum logLevel {\n  DEBUG = 1,\n  INFO = 2,\n  WARN = 3,\n  ERROR = 4,\n  DISABLED = 5\n}\n\nexport interface LoggerConfig {\n  logLevel: LogLevel\n  silence?: boolean\n\n  onwarn?: (message: any, ...optionalParams: any[]) => void\n  onerror?: (message: any, ...optionalParams: any[]) => void\n}\n\nexport class Logger {\n  logLevel: logLevel\n\n  constructor(private config: LoggerConfig) {\n    this.configure(config)\n  }\n\n  configure(config: Partial<LoggerConfig>) {\n    this.config = { ...this.config, ...config}\n    switch (this.config.logLevel) {\n      case 'DEBUG':\n        this.logLevel = logLevel.DEBUG\n        break\n      case 'INFO':\n        this.logLevel = logLevel.INFO\n        break\n      case 'WARN':\n        this.logLevel = logLevel.WARN\n        break\n      case 'ERROR':\n        this.logLevel = logLevel.ERROR\n        break\n      case 'DISABLED':\n        this.logLevel = logLevel.DISABLED\n        break\n      default:\n        this.logLevel = logLevel.INFO\n        break\n    }\n\n    // undefined silence value will disable the default silence flag\n    if (this.config.silence === undefined) {\n      this.config.silence = false\n    }\n  }\n\n  debug(message: any, ...optionalParams: any[]) {\n    if (this.config.silence === true) return\n    if (this.logLevel === logLevel.DEBUG) {\n      console.log(message, ...optionalParams)\n    }\n  }\n\n  info(message: any, ...optionalParams: any[]) {\n    if (this.config.silence === true) return\n    if (this.logLevel <= logLevel.INFO) {\n      console.log(message, ...optionalParams)\n    }\n  }\n\n  warn(message: any, ...optionalParams: any[]) {\n    if (this.config.silence === true) return\n    if (this.logLevel <= logLevel.WARN) {\n      console.warn(message, ...optionalParams)\n      if (this.config.onwarn) {\n        this.config.onwarn(message, optionalParams)\n      }\n    }\n  }\n\n  error(message: any, ...optionalParams: any[]) {\n    if (this.config.silence === true) return\n    if (this.logLevel <= logLevel.ERROR) {\n      console.error(message, ...optionalParams)\n      if (this.config.onerror) {\n        this.config.onerror(message, optionalParams)\n      }\n    }\n  }\n}\n\nexport const logger = new Logger({\n  logLevel: 'INFO',\n\n  // By default we silence the logger. In tests we should call `configureLogger`\n  // below to set silence: false.\n  silence: true \n})\n\nexport const configureLogger = (config: Partial<LoggerConfig>) => logger.configure(config)\n","export function promisify<T>(f: (cb: (err: any, res: T) => void) => void, thisContext?: any): () => Promise<T>\nexport function promisify<A, T>(f: (arg: A, cb: (err: any, res: T) => void) => void, thisContext?: any): (arg: A) => Promise<T>\nexport function promisify<A, A2, T>(f: (arg: A, arg2: A2, cb: (err: any, res: T) => void) => void, thisContext?: any): (arg: A, arg2: A2) => Promise<T>\nexport function promisify<A, A2, A3, T>(f: (arg: A, arg2: A2, arg3: A3, cb: (err: any, res: T) => void) => void, thisContext?: any): (arg: A, arg2: A2, arg3: A3) => Promise<T>\nexport function promisify<A, A2, A3, A4, T>(f: (arg: A, arg2: A2, arg3: A3, arg4: A4, cb: (err: any, res: T) => void) => void, thisContext?: any): (arg: A, arg2: A2, arg3: A3, arg4: A4) => Promise<T>\nexport function promisify<A, A2, A3, A4, A5, T>(f: (arg: A, arg2: A2, arg3: A3, arg4: A4, arg5: A5, cb: (err: any, res: T) => void) => void, thisContext?: any): (arg: A, arg2: A2, arg3: A3, arg4: A4, arg5: A5) => Promise<T>\n\nexport function promisify(f: any, thisContext?: any) {\n  return function(...a: any[]) {\n    const args = Array.prototype.slice.call(a)\n    return new Promise(async (resolve, reject) => {\n      try {\n        args.push((err: any, result: any) => err ? reject(err) : resolve(result))\n        await f.apply(thisContext, args)\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n}\n","export const getRandomInt = (min: number = 0, max: number = Number.MAX_SAFE_INTEGER): number => {\n  min = Math.ceil(min)\n  max = Math.floor(max)\n  return Math.floor(Math.random() * (max - min + 1)) + min\n}\n","\n// sanitizeNumberString accepts a number string and returns back a clean number string.\n// For example, input '1234.5678' will return '1234.5678' but '12javascript:{}etc' will return '12'\nexport const sanitizeNumberString = (numString: string | null): string => {\n  if (!numString || typeof(numString) !== 'string') {\n    return ''\n  }\n  const v = numString.match(/[\\d.]+/)\n  return v && v.length > 0 ? v[0].trim() : ''\n}\n\n// sanitizeAlphanumeric accepts any string and returns alphanumeric contents only\nexport const sanitizeAlphanumeric = (alphanum: string): string => {\n  if (!alphanum || typeof(alphanum) !== 'string') {\n    return ''\n  }\n  const v = alphanum.match(/[\\w\\s\\d]+/)\n  return v && v.length > 0 ? v[0].trim() : ''\n}\n\n// sanitizeHost accepts any string and returns valid host string\nexport const sanitizeHost = (host: string): string => {\n  if (!host || typeof(host) !== 'string') {\n    return ''\n  }\n  const v = host.match(/[\\w\\d.\\-:\\/]+/)\n  return v && v.length > 0 ? v[0].trim() : ''\n}\n","import { ethers, TypedDataDomain, TypedDataField } from 'ethers'\n\nexport interface TypedData {\n  domain: TypedDataDomain\n  types: Record<string, Array<TypedDataField>>\n  message: Record<string, any>\n  primaryType?: string\n}\n\nexport type { TypedDataDomain, TypedDataField }\n\nexport const encodeTypedDataHash = (typedData: TypedData): string => {\n  const types = { ...typedData.types }\n  \n  // remove EIP712Domain key from types as ethers will auto-gen it in\n  // the hash encoder below\n  delete types['EIP712Domain']\n\n  return ethers.utils._TypedDataEncoder.hash(typedData.domain, types, typedData.message)\n}\n\nexport const encodeTypedDataDigest = (typedData: TypedData): Uint8Array => {\n  return ethers.utils.arrayify(encodeTypedDataHash(typedData))\n}\n","import { utils } from 'ethers'\n\ntype Deferrable<T> = utils.Deferrable<T>\n\nconst {\n  defineReadOnly, getStatic, resolveProperties, checkProperties, shallowCopy, deepCopy\n} = utils\n\nexport type { Deferrable }\n\nexport {\n  defineReadOnly, getStatic, resolveProperties, checkProperties, shallowCopy, deepCopy\n}\n\nexport type Optionals<T extends object> = Omit<T, Exclude<{\n  [K in keyof T]: T extends Record<K, T[K]>\n    ? K\n    : never\n}[keyof T], undefined>>\n\nexport type Mask<T, K> = Omit<T, keyof K>\n\nexport type Forbid<T, K extends keyof any> = T & {\n  [P in K]?: never;\n}\n","import { BigNumber, BigNumberish, utils } from 'ethers'\n\n// ethers implement this method but doesn't exports it\nexport function isBigNumberish(value: any): value is BigNumberish {\n  return (value != null) && (\n      BigNumber.isBigNumber(value) ||\n      (typeof(value) === \"number\" && (value % 1) === 0) ||\n      (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\n      utils.isHexString(value) ||\n      (typeof(value) === \"bigint\") ||\n      utils.isBytes(value)\n  )\n}\n","import { Contract, ethers } from 'ethers'\nimport { addressOf, imageHash, WalletConfig } from '..'\nimport { getCachedConfig } from '../cache'\nimport { ConfigFinder } from './config-finder'\nimport { walletContracts } from '@0xsequence/abi'\nimport { WalletContext } from '@0xsequence/network'\nimport { logger } from '@0xsequence/utils'\n\nexport class SequenceUtilsFinder implements ConfigFinder {\n  constructor(public authProvider: ethers.providers.Provider) {}\n\n  findCurrentConfig = async (args: {\n    address: string\n    provider: ethers.providers.Provider\n    context: WalletContext\n    knownConfigs?: WalletConfig[]\n    ignoreIndex?: boolean\n    requireIndex?: boolean\n    skipCache?: boolean\n  }): Promise<{ config: WalletConfig | undefined }> => {\n    const { provider, context, ignoreIndex, requireIndex, skipCache } = args\n    const address = ethers.utils.getAddress(args.address)\n\n    logger.info(`[findCurrentConfig] address:${address}, ignoreIndex:${ignoreIndex}, requireIndex:${requireIndex}`)\n\n    if (requireIndex && ignoreIndex) throw Error(`findCurrentConfig: can't ignore index and require index`)\n\n    const chainIdPromise = provider.getNetwork()\n    const knownConfigs = args.knownConfigs ? args.knownConfigs : []\n\n    // Get imageHash of wallet\n    const { imageHash, config } = await this.findCurrentImageHash(context, provider, address, knownConfigs, skipCache)\n    if (imageHash === undefined) return { config: undefined }\n\n    // Get config for that imageHash\n    const found = await this.findConfigForImageHash(\n      context,\n      imageHash,\n      config ? [config, ...knownConfigs] : knownConfigs,\n      skipCache\n    )\n    const chainId = (await chainIdPromise).chainId\n\n    return {\n      config: found ? { ...found, chainId, address } : undefined\n    }\n  }\n\n  findLastWalletOfInitialSigner = async (args: {\n    signer: string\n    provider: ethers.providers.Provider\n    context: WalletContext\n    ignoreIndex?: boolean\n    requireIndex?: boolean\n  }): Promise<{ wallet: string | undefined }> => {\n    const { signer, context, ignoreIndex, requireIndex } = args\n\n    logger.info(`[findLastWalletOfInitialSigner] signer:${signer}`)\n\n    if (requireIndex && ignoreIndex) throw Error(`findCurrentConfig: can't ignore index and require index`)\n\n    const authContract = new Contract(context.sequenceUtils!, walletContracts.sequenceUtils.abi, this.authProvider)\n    const logBlockHeight = ignoreIndex ? 0 : (await authContract.lastSignerUpdate(signer)).toNumber()\n    if (requireIndex && logBlockHeight === 0) return { wallet: undefined }\n    const filter = authContract.filters.RequiredSigner(null, signer)\n    const lastLog = await this.findLatestLog(this.authProvider, {\n      ...filter,\n      fromBlock: logBlockHeight,\n      toBlock: logBlockHeight !== 0 ? logBlockHeight : 'latest'\n    })\n    if (lastLog === undefined) {\n      logger.warn('publishConfig: wallet config last log not found')\n      return { wallet: undefined }\n    }\n    const event = authContract.interface.decodeEventLog('RequiredSigner', lastLog.data, lastLog.topics)\n    return { wallet: event._wallet }\n  }\n\n  findConfigForImageHash = async (\n    context: WalletContext,\n    image: string,\n    knownConfigs: WalletConfig[] = [],\n    skipCache: boolean = false\n  ): Promise<WalletConfig | undefined> => {\n    // Lookup config in known configurations\n    const found = knownConfigs.find(kc => imageHash(kc) === image)\n    if (found) return found\n\n    // Lookup config in cached configurations\n    if (!skipCache) {\n      const cached = getCachedConfig(image)\n      if (cached) {\n        return cached\n      }\n    }\n\n    logger.info(`[findConfigForImageHash] image:${image}`)\n\n    // Load index for last imageHash update\n    const authContract = new Contract(context.sequenceUtils!, walletContracts.sequenceUtils.abi, this.authProvider)\n    const imageHashHeight = (await authContract.lastImageHashUpdate(image)).toNumber() as number\n\n    // Get requireConfig with imageHash info\n    const filter = authContract.filters.RequiredConfig(undefined, image)\n    const lastLog = await this.findLatestLog(this.authProvider, {\n      ...filter,\n      fromBlock: imageHashHeight,\n      toBlock: imageHashHeight !== 0 ? imageHashHeight : 'latest'\n    })\n\n    // If there is no log, and no knownConfig...\n    // the config is not found\n    if (lastLog === undefined) return undefined\n\n    const event = authContract.interface.decodeEventLog('RequiredConfig', lastLog.data, lastLog.topics)\n    const signers = ethers.utils.defaultAbiCoder.decode(\n      [\n        `tuple(\n        uint256 weight,\n        address signer\n      )[]`\n      ],\n      event._signers\n    )[0]\n\n    const config = {\n      threshold: ethers.BigNumber.from(event._threshold).toNumber(),\n      signers: signers.map((s: any) => ({\n        address: s.signer,\n        weight: ethers.BigNumber.from(s.weight).toNumber()\n      }))\n    }\n\n    // Cache this config\n    imageHash(config)\n\n    return config\n  }\n\n  findCurrentImageHash = async (\n    context: WalletContext,\n    provider: ethers.providers.Provider,\n    address: string,\n    knownConfigs: WalletConfig[] = [],\n    skipCache?: boolean\n  ): Promise<{ imageHash?: string; config?: WalletConfig }> => {\n    logger.info(`[findCurrentImageHash] address:${address}`)\n\n    const walletContract = new Contract(address, walletContracts.mainModuleUpgradable.abi, provider)\n    const currentImageHash = (await walletContract.functions.imageHash.call([]).catch(() => [])) as string[]\n\n    // Wallet is not counterfactual and has a defined imageHash\n    if (currentImageHash[0] !== undefined) {\n      return {\n        imageHash: currentImageHash[0],\n        config: skipCache ? undefined : getCachedConfig(currentImageHash[0])\n      }\n    }\n\n    // Wallet is in counter-factual mode\n    // Lookup config in known configurations\n    const normalizedAddress = ethers.utils.getAddress(address)\n    const found = knownConfigs.find(kc => addressOf(kc, context, true) === normalizedAddress)\n    if (found) return { imageHash: imageHash(found), config: found }\n\n    // Call wallet index\n    const authContract = new Contract(context.sequenceUtils!, walletContracts.sequenceUtils.abi, this.authProvider)\n    const knownImageHash = (await authContract.knownImageHashes(address)) as string\n\n    if (knownImageHash !== ethers.constants.HashZero) {\n      if (addressOf(knownImageHash, context) !== address) throw Error('findCurrentImageHash: inconsistent RequireUtils results')\n      return { imageHash: knownImageHash }\n    }\n\n    // Get known image hash from raw logs, as last resort\n    const filter = authContract.filters.RequiredConfig(address)\n    const log = await this.findFirstLog(this.authProvider, filter)\n\n    if (log !== undefined) {\n      const event = authContract.interface.decodeEventLog('RequiredConfig', log.data, log.topics)\n      const signers = ethers.utils.defaultAbiCoder.decode(\n        [\n          `tuple(\n          uint256 weight,\n          address signer\n        )[]`\n        ],\n        event._signers\n      )[0]\n\n      const config = {\n        threshold: ethers.BigNumber.from(event._threshold).toNumber(),\n        signers: signers.map((s: any) => ({\n          address: s.signer,\n          weight: ethers.BigNumber.from(s.weight).toNumber()\n        }))\n      }\n\n      const gotImageHash = imageHash(config)\n      if (addressOf(gotImageHash, context) === address) {\n        return { imageHash: gotImageHash, config }\n      }\n    }\n\n    // Counter-factual imageHash not found\n    return {}\n  }\n\n  private findLatestLog = async (\n    provider: ethers.providers.Provider,\n    filter: ethers.providers.Filter\n  ): Promise<ethers.providers.Log | undefined> => {\n    const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : (filter.toBlock as number)\n    const fromBlock = filter.fromBlock as number\n\n    if (fromBlock === 0) {\n      logger.warn(`findLatestLog: expensive getLogs query fromBlock 0 toBlock ${toBlock}`)\n    }\n\n    try {\n      const logs = await provider.getLogs({ ...filter, toBlock: toBlock })\n      return logs.length === 0 ? undefined : logs[logs.length - 1]\n    } catch (e) {\n      // TODO Don't assume all errors are bad\n      const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock)\n      const nhalf = await this.findLatestLog(provider, { ...filter, fromBlock: pivot, toBlock: toBlock })\n      if (nhalf !== undefined) return nhalf\n      return this.findLatestLog(provider, { ...filter, fromBlock: fromBlock, toBlock: pivot })\n    }\n  }\n\n  private findFirstLog = async (\n    provider: ethers.providers.Provider,\n    filter: ethers.providers.Filter\n  ): Promise<ethers.providers.Log | undefined> => {\n    const toBlock = filter.toBlock === 'latest' || !filter.toBlock ? await provider.getBlockNumber() : (filter.toBlock as number)\n    const fromBlock = filter.fromBlock ? (filter.fromBlock as number) : 0\n\n    if (fromBlock === 0) {\n      logger.warn(`findFirstLog: expensive getLogs query fromBlock 0 toBlock ${toBlock}`)\n    }\n\n    try {\n      const logs = await provider.getLogs({ ...filter, fromBlock, toBlock })\n      return logs.length === 0 ? undefined : logs[0]\n    } catch (e) {\n      // TODO Don't assume all errors are bad\n      const pivot = Math.floor((toBlock - fromBlock) / 2 + fromBlock)\n      const nhalf = await this.findFirstLog(provider, { ...filter, fromBlock, toBlock: pivot })\n      if (nhalf !== undefined) return nhalf\n      return this.findFirstLog(provider, { ...filter, fromBlock: pivot, toBlock })\n    }\n  }\n}\n","\nexport enum JsonRpcMethod {\n  ethCall = \"eth_call\",\n  ethGetBalance = \"eth_getBalance\",\n  ethGetCode = \"eth_getCode\",\n}\n","import { BigNumber, BigNumberish } from 'ethers'\n\nexport async function safeSolve<T>(promise: Promise<T>, def: T | ((e: any) => T)): Promise<T> {\n  try {\n    return await promise\n  } catch (e) {\n    const d = def instanceof Function ? def(e) : def\n    return d\n  }\n}\n\nexport function partition<T>(array: T[], callback: (v: T, i: number) => boolean): [T[], T[]] {\n  return array.reduce(function(result, element, i) {\n      callback(element, i) ? result[0].push(element) : result[1].push(element)\n      return result\n    }, [[] as any[], [] as any[]]\n  )\n}\n\nexport type BlockTag = 'earliest' | 'latest' | 'pending' | BigNumber\n\nexport function parseBlockTag(cand: string | BigNumberish | undefined): BlockTag {\n  if (cand === undefined) return 'latest'\n\n  switch (cand) {\n    case 'earliest':\n    case 'latest':\n    case 'pending':\n      return cand\n  }\n\n  return BigNumber.from(cand)\n}\n\nexport function eqBlockTag(a: BlockTag, b: BlockTag): boolean {\n  if (a === b) return true\n\n  if (BigNumber.isBigNumber(a)) {\n    if (BigNumber.isBigNumber(b)) return a.eq(b)\n    return false\n  }\n\n  if (BigNumber.isBigNumber(b)) return false\n  return a === b\n}\n","import { ethers, BigNumberish } from 'ethers'\nimport { ChainIdLike } from '.'\nimport { NetworkConfig } from './config'\n\nexport function isNetworkConfig(cand: any): cand is NetworkConfig {\n  return cand && cand.chainId !== undefined && cand.name !== undefined && cand.rpcUrl !== undefined && cand.relayer !== undefined\n}\n\nexport const getChainId = (chainId: ChainIdLike): number => {\n  if (typeof chainId === 'number') {\n    return chainId\n  }\n  if ((<NetworkConfig>chainId).chainId) {\n    return (<NetworkConfig>chainId).chainId\n  }\n  return ethers.BigNumber.from(chainId as BigNumberish).toNumber()\n}\n\nexport const maybeChainId = (chainId?: ChainIdLike): number | undefined => {\n  if (!chainId) return undefined\n  return getChainId(chainId)\n}\n\nexport const getAuthNetwork = (networks: NetworkConfig[]): NetworkConfig | undefined => {\n  return networks.find(network => network.isAuthChain)\n}\n\nexport const isValidNetworkConfig = (\n  networkConfig: NetworkConfig | NetworkConfig[],\n  raise: boolean = false,\n  skipRelayerCheck: boolean = false\n): boolean => {\n  if (!networkConfig) throw new Error(`invalid network config: empty config`)\n\n  const configs: NetworkConfig[] = []\n  if (Array.isArray(networkConfig)) {\n    configs.push(...networkConfig)\n  } else {\n    configs.push(networkConfig)\n  }\n\n  if (configs.length === 0) {\n    if (raise) throw new Error(`invalid network config: empty config`)\n    return false\n  }\n\n  // Ensure distinct chainId configs\n  const chainIds = configs.map(c => c.chainId).sort()\n  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i)\n  if (dupes.length > 0) {\n    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`)\n    return false\n  }\n\n  // Downcase all network names\n  configs.forEach(c => (c.name = c.name.toLowerCase()))\n\n  // Ensure distinct network names\n  const names = configs.map(c => c.name).sort()\n  const nameDupes = names.filter((c, i) => names.indexOf(c) !== i)\n  if (nameDupes.length > 0) {\n    if (raise) throw new Error(`invalid network config: duplicate network names ${nameDupes}`)\n    return false\n  }\n\n  // Ensure rpcUrl or provider is specified\n  // Ensure relayerUrl or relayer is specified\n  // Ensure one default chain\n  // Ensure one auth chain\n  let defaultChain = false\n  let authChain = false\n  for (let i = 0; i < configs.length; i++) {\n    const c = configs[i]\n    if ((!c.rpcUrl || c.rpcUrl === '') && !c.provider) {\n      if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: rpcUrl or provider must be provided`)\n      return false\n    }\n    if (!skipRelayerCheck) {\n      if (!c.relayer) {\n        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: relayer must be provided`)\n        return false\n      }\n    }\n    if (c.isDefaultChain) {\n      if (defaultChain) {\n        if (raise)\n          throw new Error(`invalid network config for chainId ${c.chainId}: DefaultChain is already set by another config`)\n        return false\n      }\n      defaultChain = true\n    }\n    if (c.isAuthChain) {\n      if (authChain) {\n        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: AuthChain is already set by another config`)\n      }\n      authChain = true\n    }\n  }\n\n  if (!defaultChain) {\n    if (raise) throw new Error(`invalid network config: DefaultChain must be set`)\n    return false\n  }\n  if (!authChain) {\n    if (raise) throw new Error(`invalid network config: AuthChain must be set`)\n    return false\n  }\n\n  return true\n}\n\nexport const ensureValidNetworks = (networks: NetworkConfig[], skipRelayerCheck: boolean = false): NetworkConfig[] => {\n  isValidNetworkConfig(networks, true, skipRelayerCheck)\n  return networks\n}\n\nexport const ensureUniqueNetworks = (networks: NetworkConfig[], raise: boolean = true): boolean => {\n  const chainIds = networks.map(c => c.chainId).sort()\n  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i)\n  if (dupes.length > 0) {\n    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`)\n    return false\n  }\n  return true\n}\n\nexport const updateNetworkConfig = (src: Partial<NetworkConfig>, dest: NetworkConfig) => {\n  if (!src || !dest) return\n\n  if (!src.chainId && !src.name) {\n    throw new Error('failed to update network config: source config is missing chainId or name')\n  }\n  if (src.chainId !== dest.chainId && src.name !== dest.name) {\n    throw new Error('failed to update network config: one of chainId or name must match')\n  }\n\n  if (src.rpcUrl) {\n    dest.rpcUrl = src.rpcUrl\n    dest.provider = undefined\n  }\n  if (src.provider) {\n    dest.provider = src.provider\n  }\n  if (src.relayer) {\n    dest.relayer = src.relayer\n  }\n  // NOTE: we do not set default or auth chain from here\n  // if (src.isDefaultChain) {\n  //   dest.isDefaultChain = src.isDefaultChain\n  // }\n  // if (src.isAuthChain) {\n  //   dest.isAuthChain = src.isAuthChain\n  // }\n}\n\nexport const validateAndSortNetworks = (networks: NetworkConfig[]) => {\n  return ensureValidNetworks(sortNetworks(networks))\n}\n\nexport const findNetworkConfig = (networks: NetworkConfig[], chainId: ChainIdLike): NetworkConfig | undefined => {\n  if (typeof chainId === 'string') {\n    if (chainId.startsWith('0x')) {\n      const id = ethers.BigNumber.from(chainId).toNumber()\n      return networks.find(n => n.chainId === id)\n    } else {\n      return networks.find(n => n.name === chainId)\n    }\n  } else if (typeof chainId === 'number') {\n    return networks.find(n => n.chainId === chainId)\n  } else if ((<NetworkConfig>chainId).chainId) {\n    return networks.find(n => n.chainId === (<NetworkConfig>chainId).chainId)\n  } else {\n    return undefined\n  }\n}\n\nexport const checkNetworkConfig = (network: NetworkConfig, chainId: string | number): boolean => {\n  if (!network) return false\n  if (network.name === chainId) return true\n  if (network.chainId === chainId) return true\n  return false\n}\n\nexport const networksIndex = (networks: NetworkConfig[]): { [key: string]: NetworkConfig } => {\n  const index: { [key: string]: NetworkConfig } = {}\n  for (let i = 0; i < networks.length; i++) {\n    index[networks[i].name] = networks[i]\n  }\n  return index\n}\n\n// TODO: we should remove sortNetworks in the future but this is a breaking change for dapp integrations on older versions <-> wallet\n// sortNetworks orders the network config list by: defaultChain, authChain, ..rest by chainId ascending numbers\nexport const sortNetworks = (networks: NetworkConfig[]): NetworkConfig[] => {\n  if (!networks) {\n    return []\n  }\n\n  const config = networks.sort((a, b) => {\n    if (a.chainId === b.chainId) return 0\n    return a.chainId < b.chainId ? -1 : 1\n  })\n\n  // DefaultChain goes first\n  const defaultConfigIdx = config.findIndex(c => c.isDefaultChain)\n  if (defaultConfigIdx > 0) config.splice(0, 0, config.splice(defaultConfigIdx, 1)[0])\n\n  // AuthChain goes second\n  const authConfigIdx = config.findIndex(c => c.isAuthChain && c.isDefaultChain !== true)\n  if (authConfigIdx > 0) config.splice(1, 0, config.splice(authConfigIdx, 1)[0])\n\n  return config\n}\n\nexport const stringTemplate = (sTemplate: string, mData: any) => {\n  if (typeof sTemplate === 'string') {\n    mData = mData ? mData : {}\n    return sTemplate.replace(/\\$\\{\\s*([$#@\\-\\d\\w]+)\\s*\\}/gim, function (fullMath, grp) {\n      let val = mData[grp]\n      if (typeof val === 'function') {\n        val = val()\n      } else if (val === null || val === undefined) {\n        val = ''\n      } else if (typeof val === 'object' || typeof val === 'symbol') {\n        val = val.toString()\n      } else {\n        val = val.valueOf()\n      }\n      return val\n    })\n  }\n  return ''\n}\n","import { BigNumberish, providers } from 'ethers'\nimport { Indexer } from '@0xsequence/indexer'\nimport { Relayer, RpcRelayerOptions } from '@0xsequence/relayer'\nimport { stringTemplate, validateAndSortNetworks } from './utils'\n\nexport enum ChainId {\n  // Ethereum\n  MAINNET = 1,\n  ROPSTEN = 3,\n  RINKEBY = 4,\n  GOERLI = 5,\n  KOVAN = 42,\n\n  // Polygon\n  POLYGON = 137,\n  POLYGON_MUMBAI = 80001,\n  POLYGON_ZKEVM = 1101,\n\n  // BSC\n  BSC = 56,\n  BSC_TESTNET = 97,\n\n  // Optimism\n  OPTIMISM = 10,\n  OPTIMISM_TESTNET = 69,\n\n  // Arbitrum One\n  ARBITRUM = 42161,\n  ARBITRUM_GOERLI = 421613,\n\n  // Arbitrum Nova\n  ARBITRUM_NOVA = 42170,\n\n  // Avalanche\n  AVALANCHE = 43114,\n  AVALANCHE_TESTNET = 43113,\n\n  // Fantom\n  FANTOM = 250,\n  FANTOM_TESTNET = 4002,\n\n  // Gnosis Chain (XDAI)\n  GNOSIS = 100,\n\n  // AURORA\n  AURORA = 1313161554,\n  AURORA_TESTNET = 1313161556,\n\n  // BASE\n  BASE_GOERLI = 84531\n}\n\nexport interface NetworkConfig {\n  title?: string\n  name: string\n  chainId: number\n  testnet?: boolean\n\n  blockExplorer?: BlockExplorerConfig\n  ensAddress?: string\n\n  rpcUrl?: string\n  provider?: providers.JsonRpcProvider\n  indexerUrl?: string\n  indexer?: Indexer\n  relayer?: Relayer | RpcRelayerOptions\n\n  // isDefaultChain identifies the default network. For example, a dapp may run on the Polygon\n  // network and may configure the wallet to use it as its main/default chain.\n  isDefaultChain?: boolean\n\n  // isAuthChain identifies the network containing wallet config contents.\n  isAuthChain?: boolean\n\n  // Disabled / deprecated chain\n  disabled?: boolean\n}\n\nexport type BlockExplorerConfig = {\n  name?: string\n  rootUrl: string\n  addressUrl?: string\n  txnHashUrl?: string\n}\n\nexport const indexerURL = (network: string) => stringTemplate('https://${network}-indexer.sequence.app', { network: network })\nexport const relayerURL = (network: string) => stringTemplate('https://${network}-relayer.sequence.app', { network: network })\nexport const nodesURL = (network: string) => stringTemplate('https://nodes.sequence.app/${network}', { network: network })\n\nexport const networks: Record<ChainId, NetworkConfig> = {\n  [ChainId.MAINNET]: {\n    chainId: ChainId.MAINNET,\n    name: 'mainnet',\n    title: 'Ethereum',\n    blockExplorer: {\n      name: 'Etherscan',\n      rootUrl: 'https://etherscan.io/'\n    },\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  },\n  [ChainId.ROPSTEN]: {\n    chainId: ChainId.ROPSTEN,\n    name: 'ropsten',\n    title: 'Ropsten',\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Ropsten)',\n      rootUrl: 'https://ropsten.etherscan.io/'\n    },\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  },\n  [ChainId.RINKEBY]: {\n    chainId: ChainId.RINKEBY,\n    name: 'rinkeby',\n    title: 'Rinkeby',\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Rinkeby)',\n      rootUrl: 'https://rinkeby.etherscan.io/'\n    },\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n    disabled: true\n  },\n  [ChainId.GOERLI]: {\n    chainId: ChainId.GOERLI,\n    name: 'goerli',\n    title: 'Goerli',\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Goerli)',\n      rootUrl: 'https://goerli.etherscan.io/'\n    },\n    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'\n  },\n  [ChainId.KOVAN]: {\n    chainId: ChainId.KOVAN,\n    name: 'kovan',\n    title: 'Kovan',\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Kovan)',\n      rootUrl: 'https://kovan.etherscan.io/'\n    }\n  },\n  [ChainId.POLYGON]: {\n    chainId: ChainId.POLYGON,\n    name: 'polygon',\n    title: 'Polygon',\n    blockExplorer: {\n      name: 'Polygonscan',\n      rootUrl: 'https://polygonscan.com/'\n    }\n  },\n  [ChainId.POLYGON_MUMBAI]: {\n    chainId: ChainId.POLYGON_MUMBAI,\n    name: 'mumbai',\n    title: 'Polygon Mumbai',\n    testnet: true,\n    blockExplorer: {\n      name: 'Polygonscan (Mumbai)',\n      rootUrl: 'https://mumbai.polygonscan.com/'\n    }\n  },\n  [ChainId.POLYGON_ZKEVM]: {\n    chainId: ChainId.POLYGON_ZKEVM,\n    name: 'polygon-zkevm',\n    title: 'Polygon zkEVM',\n    blockExplorer: {\n      name: 'Polygonscan (zkEVM)',\n      rootUrl: 'https://zkevm.polygonscan.com/'\n    }\n  },\n  [ChainId.BSC]: {\n    chainId: ChainId.BSC,\n    name: 'bsc',\n    title: 'BNB Smart Chain',\n    blockExplorer: {\n      name: 'BSCScan',\n      rootUrl: 'https://bscscan.com/'\n    }\n  },\n  [ChainId.BSC_TESTNET]: {\n    chainId: ChainId.BSC_TESTNET,\n    name: 'bsc-testnet',\n    title: 'BNB Smart Chain Testnet',\n    testnet: true,\n    blockExplorer: {\n      name: 'BSCScan (Testnet)',\n      rootUrl: 'https://testnet.bscscan.com/'\n    }\n  },\n  [ChainId.OPTIMISM]: {\n    chainId: ChainId.OPTIMISM,\n    name: 'optimism',\n    title: 'Optimism',\n    blockExplorer: {\n      name: 'Etherscan (Optimism)',\n      rootUrl: 'https://optimistic.etherscan.io/'\n    }\n  },\n  [ChainId.OPTIMISM_TESTNET]: {\n    chainId: ChainId.OPTIMISM_TESTNET,\n    name: 'optimism-testnet',\n    title: 'Optimistic Kovan',\n    testnet: true,\n    blockExplorer: {\n      name: 'Etherscan (Optimism Testnet)',\n      rootUrl: 'https://kovan-optimistic.etherscan.io/'\n    }\n  },\n  [ChainId.ARBITRUM]: {\n    chainId: ChainId.ARBITRUM,\n    name: 'arbitrum',\n    title: 'Arbitrum One',\n    blockExplorer: {\n      name: 'Arbiscan',\n      rootUrl: 'https://arbiscan.io/'\n    }\n  },\n  [ChainId.ARBITRUM_GOERLI]: {\n    chainId: ChainId.ARBITRUM_GOERLI,\n    name: 'arbitrum-goerli',\n    title: 'Arbitrum Goerli',\n    testnet: true,\n    blockExplorer: {\n      name: 'Arbiscan (Testnet)',\n      rootUrl: 'https://testnet.arbiscan.io/'\n    }\n  },\n  [ChainId.ARBITRUM_NOVA]: {\n    chainId: ChainId.ARBITRUM_NOVA,\n    name: 'arbitrum-nova',\n    title: 'Arbitrum Nova',\n    blockExplorer: {\n      name: 'Nova Explorer',\n      rootUrl: 'https://nova-explorer.arbitrum.io/'\n    }\n  },\n  [ChainId.AVALANCHE]: {\n    chainId: ChainId.AVALANCHE,\n    name: 'avalanche',\n    title: 'Avalanche',\n    blockExplorer: {\n      name: 'Snowtrace',\n      rootUrl: 'https://snowtrace.io/'\n    }\n  },\n  [ChainId.AVALANCHE_TESTNET]: {\n    chainId: ChainId.AVALANCHE_TESTNET,\n    name: 'avalanche-testnet',\n    title: 'Avalanche Testnet',\n    testnet: true,\n    blockExplorer: {\n      name: 'Snowtrace (Testnet)',\n      rootUrl: 'https://testnet.snowtrace.io/'\n    }\n  },\n  [ChainId.FANTOM]: {\n    chainId: ChainId.FANTOM,\n    name: 'fantom',\n    title: 'Fantom',\n    blockExplorer: {\n      name: 'FTMScan',\n      rootUrl: 'https://ftmscan.com/'\n    }\n  },\n  [ChainId.FANTOM_TESTNET]: {\n    chainId: ChainId.FANTOM_TESTNET,\n    name: 'fantom-testnet',\n    title: 'Fantom Testnet',\n    testnet: true,\n    blockExplorer: {\n      name: 'FTMScan (Testnet)',\n      rootUrl: 'https://testnet.ftmscan.com/'\n    }\n  },\n  [ChainId.GNOSIS]: {\n    chainId: ChainId.GNOSIS,\n    name: 'gnosis',\n    title: 'Gnosis Chain',\n    blockExplorer: {\n      name: 'Gnosis Chain Explorer',\n      rootUrl: 'https://blockscout.com/xdai/mainnet/'\n    }\n  },\n  [ChainId.AURORA]: {\n    chainId: ChainId.AURORA,\n    name: 'aurora',\n    title: 'Aurora',\n    blockExplorer: {\n      name: 'Aurora Explorer',\n      rootUrl: 'https://aurorascan.dev/'\n    }\n  },\n  [ChainId.AURORA_TESTNET]: {\n    chainId: ChainId.AURORA_TESTNET,\n    name: 'aurora-testnet',\n    title: 'Aurora Testnet',\n    blockExplorer: {\n      name: 'Aurora Explorer (Testnet)',\n      rootUrl: 'https://testnet.aurorascan.dev/'\n    }\n  },\n  [ChainId.BASE_GOERLI]: {\n    chainId: ChainId.BASE_GOERLI,\n    name: 'base-goerli',\n    title: 'Base Goerli',\n    blockExplorer: {\n      name: 'Base Goerli Explorer',\n      rootUrl: 'https://goerli.basescan.org/'\n    }\n  }\n}\n\nexport type ChainIdLike = NetworkConfig | BigNumberish\n\nexport const mainnetNetworks = validateAndSortNetworks([\n  {\n    ...networks[ChainId.MAINNET],\n    rpcUrl: nodesURL('mainnet'),\n    relayer: { url: relayerURL('mainnet') },\n    indexerUrl: indexerURL('mainnet')\n  },\n  {\n    ...networks[ChainId.POLYGON],\n    rpcUrl: nodesURL('polygon'),\n    relayer: { url: relayerURL('polygon') },\n    indexerUrl: indexerURL('polygon'),\n    isDefaultChain: true,\n    isAuthChain: true\n  },\n  {\n    ...networks[ChainId.BSC],\n    rpcUrl: nodesURL('bsc'),\n    indexerUrl: indexerURL('bsc'),\n    relayer: { url: relayerURL('bsc') }\n  },\n  {\n    ...networks[ChainId.AVALANCHE],\n    rpcUrl: nodesURL('avalanche'),\n    indexerUrl: indexerURL('avalanche'),\n    relayer: { url: relayerURL('avalanche') }\n  },\n  {\n    ...networks[ChainId.ARBITRUM],\n    rpcUrl: nodesURL('arbitrum'),\n    indexerUrl: indexerURL('arbitrum'),\n    relayer: { url: relayerURL('arbitrum') }\n  },\n  {\n    ...networks[ChainId.ARBITRUM_NOVA],\n    rpcUrl: nodesURL('arbitrum-nova'),\n    indexerUrl: indexerURL('arbitrum-nova'),\n    relayer: { url: relayerURL('arbitrum-nova') }\n  },\n  {\n    ...networks[ChainId.OPTIMISM],\n    rpcUrl: nodesURL('optimism'),\n    indexerUrl: indexerURL('optimism'),\n    relayer: { url: relayerURL('optimism') }\n  },\n  {\n    ...networks[ChainId.POLYGON_ZKEVM],\n    rpcUrl: nodesURL('polygon-zkevm'),\n    indexerUrl: indexerURL('polygon-zkevm'),\n    relayer: { url: relayerURL('polygon-zkevm') }\n  },\n  {\n    ...networks[ChainId.GNOSIS],\n    rpcUrl: nodesURL('gnosis'),\n    indexerUrl: indexerURL('gnosis'),\n    relayer: { url: relayerURL('gnosis') }\n  }\n])\n\nexport const testnetNetworks = validateAndSortNetworks([\n  {\n    ...networks[ChainId.RINKEBY],\n    rpcUrl: nodesURL('rinkeby'),\n    relayer: { url: relayerURL('rinkeby') },\n    indexerUrl: indexerURL('rinkeby')\n  },\n  {\n    ...networks[ChainId.GOERLI],\n    rpcUrl: nodesURL('goerli'),\n    relayer: { url: relayerURL('goerli') },\n    indexerUrl: indexerURL('goerli')\n  },\n  {\n    ...networks[ChainId.POLYGON_MUMBAI],\n    rpcUrl: nodesURL('mumbai'),\n    relayer: { url: relayerURL('mumbai') },\n    indexerUrl: indexerURL('mumbai'),\n    isDefaultChain: true,\n    isAuthChain: true\n  },\n  {\n    ...networks[ChainId.BSC_TESTNET],\n    rpcUrl: nodesURL('bsc-testnet'),\n    relayer: { url: relayerURL('bsc-testnet') },\n    indexerUrl: indexerURL('bsc-testnet')\n  },\n  {\n    ...networks[ChainId.ARBITRUM_GOERLI],\n    rpcUrl: nodesURL('arbitrum-goerli'),\n    relayer: { url: relayerURL('arbitrum-goerli') },\n    indexerUrl: indexerURL('arbitrum-goerli')\n  },\n  {\n    ...networks[ChainId.BASE_GOERLI],\n    rpcUrl: nodesURL('base-goerli'),\n    relayer: { url: relayerURL('base-goerli') },\n    indexerUrl: indexerURL('base-goerli')\n  }\n])\n","// WalletContext is the module addresses deployed on a network, aka the context / environment\n// of the Sequence Smart Wallet system on Ethereum.\nexport interface WalletContext {\n  factory: string\n  mainModule: string\n  mainModuleUpgradable: string\n  guestModule?: string\n  sequenceUtils?: string\n\n  libs?: {\n    requireFreshSigner?: string\n  }\n\n  nonStrict?: boolean\n}\n\n// sequenceContext are the deployed addresses of modules available on public networks.\nexport const sequenceContext: WalletContext = {\n  factory: '0xf9D09D634Fb818b05149329C1dcCFAeA53639d96',\n  mainModule: '0xd01F11855bCcb95f88D7A48492F66410d4637313',\n  mainModuleUpgradable: '0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118',\n  guestModule: '0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7',\n  sequenceUtils: '0xd130B43062D875a4B7aF3f8fc036Bc6e9D3E1B3E',\n  libs: {\n    requireFreshSigner: '0xE6B9B21C077F382333220a072e4c44280b873907'\n  }\n}\n","import { ProviderRpcError } from '@0xsequence/provider'\n\nexport const JsonRpcVersion = '2.0'\n\nexport interface JsonRpcRequest {\n  jsonrpc?: string\n  id?: number\n  method: string\n  params?: any[]\n}\n\nexport interface JsonRpcResponse {\n  jsonrpc: string\n  id: number\n  result: any\n  error?: ProviderRpcError\n}\n\nexport type JsonRpcResponseCallback = (error?: ProviderRpcError, response?: JsonRpcResponse) => void\n\nexport type JsonRpcHandlerFunc = (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => void\n\nexport interface JsonRpcHandler {\n  sendAsync: JsonRpcHandlerFunc\n}\n\nexport type JsonRpcFetchFunc = (method: string, params?: any[], chainId?: number) => Promise<any>\n\n// EIP-1193 function signature\nexport type JsonRpcRequestFunc = (request: { method: string; params?: any[] }, chainId?: number) => Promise<any>\n\nexport type JsonRpcMiddleware = (next: JsonRpcHandlerFunc) => JsonRpcHandlerFunc\n\nexport interface JsonRpcMiddlewareHandler {\n  sendAsyncMiddleware: JsonRpcMiddleware\n}\n","import {\n  JsonRpcHandlerFunc,\n  JsonRpcRequest,\n  JsonRpcResponseCallback,\n  JsonRpcHandler,\n  JsonRpcMiddleware,\n  JsonRpcMiddlewareHandler\n} from './types'\n\nexport class JsonRpcRouter implements JsonRpcHandler {\n  private sender: JsonRpcHandler\n  private handler: JsonRpcHandlerFunc\n\n  constructor(middlewares: Array<JsonRpcMiddleware | JsonRpcMiddlewareHandler>, sender: JsonRpcHandler) {\n    this.sender = sender\n    if (middlewares) {\n      this.setMiddleware(middlewares)\n    }\n  }\n\n  setMiddleware(middlewares: Array<JsonRpcMiddleware | JsonRpcMiddlewareHandler>) {\n    this.handler = createJsonRpcMiddlewareStack(middlewares, this.sender.sendAsync)\n  }\n\n  sendAsync(request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) {\n    try {\n      this.handler(request, callback, chainId)\n    } catch (err) {\n      callback(err, undefined)\n    }\n  }\n\n  // createWeb3Provider(network?: Networkish): EthersWeb3Provider {\n  //   return new EthersWeb3Provider(this.sender, network)\n  // }\n}\n\nexport const createJsonRpcMiddlewareStack = (\n  middlewares: Array<JsonRpcMiddleware | JsonRpcMiddlewareHandler>,\n  handler: JsonRpcHandlerFunc\n): JsonRpcHandlerFunc => {\n  if (middlewares.length === 0) return handler\n\n  const toMiddleware = (v: any): JsonRpcMiddleware => {\n    if (v.sendAsyncMiddleware) {\n      return (v as JsonRpcMiddlewareHandler).sendAsyncMiddleware\n    } else {\n      return v\n    }\n  }\n\n  let chain: JsonRpcHandlerFunc\n  chain = toMiddleware(middlewares[middlewares.length - 1])(handler)\n  for (let i = middlewares.length - 2; i >= 0; i--) {\n    chain = toMiddleware(middlewares[i])(chain)\n  }\n  return chain\n}\n","import { providers } from 'ethers'\nimport { JsonRpcHandler } from './types'\n\nexport function isJsonRpcProvider(cand: any): cand is providers.JsonRpcProvider {\n  return (\n    cand !== undefined &&\n    cand.send !== undefined &&\n    cand.constructor.defaultUrl !== undefined &&\n    cand.detectNetwork !== undefined &&\n    cand.getSigner !== undefined &&\n    cand.perform !== undefined\n  )\n}\n\nexport function isJsonRpcHandler(cand: any): cand is JsonRpcHandler {\n  return cand !== undefined && cand.sendAsync !== undefined\n}\n","import { providers } from 'ethers'\nimport {\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcResponseCallback,\n  JsonRpcHandler,\n  JsonRpcFetchFunc,\n  JsonRpcRequestFunc,\n  JsonRpcVersion\n} from './types'\nimport { isJsonRpcProvider, isJsonRpcHandler } from './utils'\n\ntype ExternalProvider = providers.ExternalProvider\n\nlet _nextId = 0\n\nexport class JsonRpcSender implements JsonRpcHandler {\n  readonly send: JsonRpcFetchFunc\n  readonly request: JsonRpcRequestFunc\n  readonly defaultChainId?: number\n\n  constructor(provider: providers.JsonRpcProvider | JsonRpcHandler | JsonRpcFetchFunc, defaultChainId?: number) {\n    this.defaultChainId = defaultChainId\n\n    if (isJsonRpcProvider(provider)) {\n      // we can ignore defaultChainId for JsonRpcProviders as they are already chain-bound\n      this.send = provider.send.bind(provider)\n    } else if (isJsonRpcHandler(provider)) {\n      this.send = (method: string, params?: Array<any>, chainId?: number): Promise<any> => {\n        return new Promise((resolve, reject) => {\n          provider.sendAsync(\n            {\n              // TODO: really shouldn't have to set these here?\n              jsonrpc: JsonRpcVersion,\n              id: ++_nextId,\n              method,\n              params\n            },\n            (error: any, response?: JsonRpcResponse) => {\n              if (error) {\n                reject(error)\n              } else if (response) {\n                resolve(response.result)\n              } else {\n                resolve(undefined)\n              }\n            },\n            chainId || this.defaultChainId\n          )\n        })\n      }\n    } else {\n      this.send = provider\n    }\n\n    this.request = (request: { method: string; params?: any[] }, chainId?: number): Promise<any> => {\n      return this.send(request.method, request.params, chainId)\n    }\n  }\n\n  sendAsync = (\n    request: JsonRpcRequest,\n    callback: JsonRpcResponseCallback | ((error: any, response: any) => void),\n    chainId?: number\n  ) => {\n    this.send(request.method, request.params, chainId || this.defaultChainId)\n      .then(r => {\n        callback(undefined, {\n          jsonrpc: '2.0',\n          id: request.id,\n          result: r\n        })\n      })\n      .catch(e => {\n        callback(e, undefined)\n      })\n  }\n}\n\nexport class JsonRpcExternalProvider implements ExternalProvider, JsonRpcHandler {\n  constructor(private provider: providers.JsonRpcProvider) {}\n\n  sendAsync = (request: JsonRpcRequest, callback: JsonRpcResponseCallback | ((error: any, response: any) => void)) => {\n    this.provider\n      .send(request.method, request.params!)\n      .then(r => {\n        callback(undefined, {\n          jsonrpc: '2.0',\n          id: request.id,\n          result: r\n        })\n      })\n      .catch(e => {\n        callback(e, undefined)\n      })\n  }\n\n  send = this.sendAsync\n}\n","import { JsonRpcHandlerFunc, JsonRpcRequest, JsonRpcResponseCallback, JsonRpcMiddleware, JsonRpcMiddlewareHandler } from '../types'\n\nexport class AllowProvider implements JsonRpcMiddlewareHandler {\n\n  sendAsyncMiddleware: JsonRpcMiddleware\n\n  private isAllowedFunc: (request: JsonRpcRequest) => boolean\n\n  constructor(isAllowedFunc?: (request: JsonRpcRequest) => boolean) {\n    if (isAllowedFunc) {\n      this.isAllowedFunc = isAllowedFunc\n    } else {\n      this.isAllowedFunc = (request: JsonRpcRequest): boolean => true\n    }\n\n    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc)\n  }\n\n  setIsAllowedFunc(fn: (request: JsonRpcRequest) => boolean) {\n    this.isAllowedFunc = fn\n    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc)\n  }\n\n}\n\nexport const allowProviderMiddleware = (isAllowed: (request: JsonRpcRequest) => boolean): JsonRpcMiddleware => (next: JsonRpcHandlerFunc) => {\n  return (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n    // ensure precondition is met or do not allow the request to continue\n    if (!isAllowed(request)) {\n      throw new Error('allowProvider middleware precondition is unmet.')\n    }\n\n    // request is allowed. keep going..\n    next(request, callback, chainId)\n  }\n}\n","import { JsonRpcHandlerFunc, JsonRpcRequest, JsonRpcResponse, JsonRpcResponseCallback, JsonRpcMiddlewareHandler } from '../types'\n\nexport interface CachedProviderOptions {\n  // defaultChainId passes a chainId to provider handler if one isn't passed.\n  // This is used in multi-chain mode \n  defaultChainId?: number\n\n  // blockCache toggle, with option to pass specific set of methods to use with\n  // the block cache.\n  blockCache?: boolean | string[]\n}\n\nexport class CachedProvider implements JsonRpcMiddlewareHandler {\n\n  // cachableJsonRpcMethods which can be permanently cached for lifetime\n  // of the provider.\n  private cachableJsonRpcMethods = [\n    'net_version', 'eth_chainId', 'eth_accounts',\n    'sequence_getWalletContext', 'sequence_getNetworks'\n  ]\n\n  // cachableJsonRpcMethodsByBlock which can be temporarily cached for a short\n  // period of time, essentially by block time. As we support chains fast blocks,\n  // we keep the values here cachable only for 1.5 seconds. This is still useful to\n  // memoize the calls within app-code that calls out to fetch these values within\n  // a short period of time.\n  private cachableJsonRpcMethodsByBlock: string[] = [\n    'eth_call', 'eth_getCode'\n  ]\n\n  // cache for life-time of provider (unless explicitly cleared)\n  private cache: {[key: string]: any}\n  \n  // cache by block, simulated by using a 1 second life-time\n  private cacheByBlock: {[key: string]: any}\n  private cacheByBlockResetLock: boolean = false\n\n  // onUpdateCallback callback to be notified when cache values are set.\n  private onUpdateCallback?: (key?: string, value?: any) => void\n\n  // defaultChainId is used for default chain select with used with multi-chain provider\n  readonly defaultChainId?: number\n\n  constructor(options?: CachedProviderOptions) {\n    this.cache = {}\n    this.cacheByBlock = {}\n    this.defaultChainId = options?.defaultChainId\n    if (!options?.blockCache) {\n      this.cachableJsonRpcMethodsByBlock = []\n    } else if (options?.blockCache !== true) {\n      this.cachableJsonRpcMethodsByBlock = options?.blockCache\n    }\n  }\n\n  sendAsyncMiddleware = (next: JsonRpcHandlerFunc) => {\n    return (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n\n      // Respond early with cached result\n      if (this.cachableJsonRpcMethods.includes(request.method) || this.cachableJsonRpcMethodsByBlock.includes(request.method)) {\n        const key = this.cacheKey(request.method, request.params!, chainId || this.defaultChainId)\n        const result = this.getCacheValue(key)\n        if (result && result !== '') {\n          callback(undefined, {\n            jsonrpc: '2.0',\n            id: request.id!,\n            result: result\n          })\n          return\n        }\n      }\n  \n      // Continue down the handler chain\n      next(request, (error: any, response?: JsonRpcResponse, chainId?: number) => {\n        // Store result in cache and continue\n        if (this.cachableJsonRpcMethods.includes(request.method) || this.cachableJsonRpcMethodsByBlock.includes(request.method)) {\n          if (response && response.result && this.shouldCacheResponse(request, response)) {\n            // cache the value\n            const key = this.cacheKey(request.method, request.params!, chainId || this.defaultChainId)\n            \n            if (this.cachableJsonRpcMethods.includes(request.method)) {\n              this.setCacheValue(key, response.result)\n            } else {\n              this.setCacheByBlockValue(key, response.result)              \n            }\n          }\n        }\n  \n        // Exec next handler\n        callback(error, response)\n      }, chainId || this.defaultChainId)\n    }\n  }\n\n  cacheKey = (method: string, params: any[], chainId?: number) => {\n    let key = ''\n    if (chainId) {\n      key = `${chainId}:${method}:`\n    } else {\n      key = `:${method}:`\n    }\n    if (!params || params.length === 0) {\n      return key+'[]'\n    }\n    return key+JSON.stringify(params)\n  }\n\n  getCache = () => this.cache\n\n  setCache = (cache: {[key: string]: any}) => {\n    this.cache = cache\n    if (this.onUpdateCallback) {\n      this.onUpdateCallback()\n    }\n  }\n\n  getCacheValue = (key: string): any => {\n    if (this.cache[key]) {\n      return this.cache[key]\n    }\n    if (this.cacheByBlock[key]) {\n      return this.cacheByBlock[key]\n    }\n    return undefined\n  }\n\n  setCacheValue = (key: string, value: any) => {\n    this.cache[key] = value\n    if (this.onUpdateCallback) {\n      this.onUpdateCallback(key, value)\n    }\n  }\n\n  setCacheByBlockValue = (key: string, value: any) => {\n    this.cacheByBlock[key] = value\n   \n    // clear the cacheByBlock once every X period of time\n    if (!this.cacheByBlockResetLock) {\n      this.cacheByBlockResetLock = true\n      setTimeout(() => {\n        this.cacheByBlockResetLock = false\n        this.cacheByBlock = {}\n      }, 1500) // 1.5 second cache lifetime\n    }\n  }\n\n  shouldCacheResponse = (request: JsonRpcRequest, response?: JsonRpcResponse): boolean => {\n    // skip if we do not have response result\n    if (!response || !response.result) {\n      return false\n    }\n\n    // skip caching eth_getCode where resposne value is '0x' or empty\n    if (request.method === 'eth_getCode' && response.result.length <= 2) {\n      return false\n    }\n\n    // all good -- signal to cache the result\n    return true\n  }\n\n  onUpdate(callback: (key?: string, value?: any) => void) {\n    this.onUpdateCallback = callback\n  }\n\n  clearCache = () => {\n    this.cache = {}\n    this.cacheByBlock = {}\n  }\n}\n","import { ethers } from 'ethers'\nimport { JsonRpcHandlerFunc, JsonRpcRequest, JsonRpcResponseCallback, JsonRpcResponse, JsonRpcMiddlewareHandler } from '../types'\nimport { WalletContext } from '../../context'\n\n// EagerProvider will eagerly respond to a provider request from pre-initialized data values.\n//\n// This is useful for saving a few remote calls for responses we're already expecting when\n// communicating to a specific network provider.\n\nexport type EagerProviderOptions = {\n  accountAddress?: string,\n  chainId?: number,\n  walletContext?: WalletContext\n}\n\nexport class EagerProvider implements JsonRpcMiddlewareHandler {\n\n  readonly options: EagerProviderOptions\n\n  constructor(options: EagerProviderOptions) {\n    this.options = options\n  }\n\n  sendAsyncMiddleware = (next: JsonRpcHandlerFunc) => {\n    return (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n\n      const { id, method } = request\n\n      switch (method) {\n        case 'net_version':\n          if (this.options.chainId) {\n            callback(undefined, { jsonrpc: '2.0', id: id!, result: `${this.options.chainId}` })\n            return\n          }\n          break\n\n        case 'eth_chainId':\n          if (this.options.chainId) {\n            callback(undefined, { jsonrpc: '2.0', id: id!, result: ethers.utils.hexlify(this.options.chainId) })\n            return\n          }\n          break\n\n        case 'eth_accounts':\n          if (this.options.accountAddress) {\n            callback(undefined, { jsonrpc: '2.0', id: id!, result: [ethers.utils.getAddress(this.options.accountAddress)] })\n            return\n          }\n          break\n\n        case 'sequence_getWalletContext':\n          if (this.options.walletContext) {\n            callback(undefined, { jsonrpc: '2.0', id: id!, result: this.options.walletContext })\n            return\n          }\n          break\n\n        default:\n      }\n\n      next(request, callback, chainId)\n\n    }\n  }\n\n}\n","import { JsonRpcHandlerFunc, JsonRpcRequest, JsonRpcResponse, JsonRpcResponseCallback, JsonRpcMiddleware } from '../types'\n\nexport const exceptionProviderMiddleware: JsonRpcMiddleware = (next: JsonRpcHandlerFunc) => {\n  return (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n    next(request, (error: any, response?: JsonRpcResponse) => {\n\n      if (!error && response && response.error) {\n        if (typeof(response.error) === 'string') {\n          throw new Error(response.error)\n        } else {\n          throw new Error(response.error.message)\n        }\n      }\n\n      callback(error, response)\n    }, chainId)\n  }\n}\n","import { JsonRpcHandlerFunc, JsonRpcRequest, JsonRpcResponse, JsonRpcResponseCallback, JsonRpcMiddleware } from '../types'\nimport { logger } from '@0xsequence/utils'\n\n// TODO: rename to loggerMiddleware\nexport const loggingProviderMiddleware: JsonRpcMiddleware = (next: JsonRpcHandlerFunc) => {\n  return (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n    const chainIdLabel = chainId ? ` chainId:${chainId}` : ''\n    logger.info(`[provider request]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params)\n\n    next(request, (error: any, response?: JsonRpcResponse) => {\n      if (error) {\n        logger.warn(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `error:`, error)\n      } else {\n        logger.info(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `response:`, response)\n      }\n      callback(error, response)\n    }, chainId)\n  }\n}\n","import { ethers } from 'ethers'\nimport { JsonRpcHandlerFunc, JsonRpcRequest, JsonRpcResponseCallback, JsonRpcMiddleware, JsonRpcMiddlewareHandler } from '../types'\n\nexport const networkProviderMiddleware = (getChainId: (request: JsonRpcRequest) => number): JsonRpcMiddleware => (next: JsonRpcHandlerFunc) => {\n  return (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n\n    const networkChainId = getChainId(request)\n\n    const { id, method } = request\n\n    switch (method) {\n      case 'net_version':\n        callback(undefined, { jsonrpc: '2.0', id: id!, result: `${networkChainId}` })\n        return\n\n      case 'eth_chainId':\n        callback(undefined, { jsonrpc: '2.0', id: id!, result: ethers.utils.hexlify(networkChainId) })\n        return\n\n      default:\n    }\n\n    // request is allowed. keep going..\n    next(request, callback, chainId)\n  }\n}\n","import { JsonRpcHandlerFunc, JsonRpcRequest, JsonRpcResponse, JsonRpcResponseCallback, JsonRpcMiddlewareHandler, JsonRpcHandler } from '../types'\n\nexport const SignerJsonRpcMethods = [\n  'personal_sign', 'eth_sign', 'eth_signTypedData', 'eth_signTypedData_v4',\n  'eth_sendTransaction', 'eth_sendRawTransaction',\n  \n  'sequence_getWalletContext', 'sequence_getWalletConfig', 'sequence_getWalletState', 'sequence_getNetworks',\n  'sequence_updateConfig', 'sequence_publishConfig', 'sequence_gasRefundOptions',\n  'sequence_getNonce', 'sequence_relay',\n\n  'eth_decrypt', 'eth_getEncryptionPublicKey',\n  'wallet_addEthereumChain', 'wallet_switchEthereumChain',\n  'wallet_registerOnboarding', 'wallet_watchAsset',\n  'wallet_scanQRCode'\n]\n\nexport class SigningProvider implements JsonRpcMiddlewareHandler {\n\n  private provider: JsonRpcHandler\n\n  constructor(provider: JsonRpcHandler) {\n    this.provider = provider\n  }\n\n  sendAsyncMiddleware = (next: JsonRpcHandlerFunc) => {\n    return (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n      // Forward signing requests to the signing provider\n      if (SignerJsonRpcMethods.includes(request.method)) {\n        this.provider.sendAsync(request, callback, chainId)\n        return\n      }\n\n      // Continue to next handler\n      next(request, callback, chainId)\n    }\n  }\n\n}\n","import { JsonRpcHandlerFunc, JsonRpcRequest, JsonRpcResponse, JsonRpcResponseCallback, JsonRpcMiddlewareHandler } from '../types'\n\nexport class SingleflightMiddleware implements JsonRpcMiddlewareHandler {\n\n  private singleflightJsonRpcMethods = [\n    'eth_chainId',\n    'net_version',\n    'eth_call',\n    'eth_getCode',\n    'eth_blockNumber',\n    'eth_getBalance',\n    'eth_getStorageAt',\n    'eth_getTransactionCount',\n    'eth_getBlockTransactionCountByHash',\n    'eth_getBlockTransactionCountByNumber',\n    'eth_getUncleCountByBlockHash',\n    'eth_getUncleCountByBlockNumber',\n    'eth_getBlockByHash',\n    'eth_getBlockByNumber',\n    'eth_getTransactionByHash',\n    'eth_getTransactionByBlockHashAndIndex',\n    'eth_getTransactionByBlockNumberAndIndex',\n    'eth_getTransactionReceipt',\n    'eth_getUncleByBlockHashAndIndex',\n    'eth_getUncleByBlockNumberAndIndex',\n    'eth_getLogs'\n  ]\n\n  inflight: {[key: string]: { id: number, callback: JsonRpcResponseCallback }[]}\n\n  constructor() {\n    this.inflight = {}\n  }\n\n  sendAsyncMiddleware = (next: JsonRpcHandlerFunc) => {\n    return (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n\n      // continue to next handler if method isn't part of methods list\n      if (!this.singleflightJsonRpcMethods.includes(request.method)) {\n        next(request, callback, chainId)\n        return\n      }\n\n      const key = this.requestKey(request.method, request.params || [], chainId)\n\n      if (!this.inflight[key]) {\n        // first request -- init the empty list\n        this.inflight[key] = []\n      } else {\n        // already in-flight, add the callback to the list and return\n        this.inflight[key].push({ id: request.id!, callback })\n        return\n      }\n\n      // Continue down the handler chain\n      next(request, (error: any, response?: JsonRpcResponse, chainId?: number) => {\n        // callback the original request\n        callback(error, response)\n\n        // callback all other requests of the same kind in queue, with the\n        // same response result as from the first response.\n        for (let i=0; i < this.inflight[key].length; i++) {\n          const sub = this.inflight[key][i]\n          if (error) {\n            sub.callback(error, response)\n          } else if (response) {\n            sub.callback(undefined, {\n              jsonrpc: '2.0',\n              id: sub.id,\n              result: response!.result\n            })\n          }\n        }\n\n        // clear request key\n        delete(this.inflight[key])\n      }, chainId)\n    }\n  }\n\n  requestKey = (method: string, params: any[], chainId?: number) => {\n    let key = ''\n    if (chainId) {\n      key = `${chainId}:${method}:`\n    } else {\n      key = `:${method}:`\n    }\n    if (!params || params.length === 0) {\n      return key+'[]'\n    }\n    return key+JSON.stringify(params)\n  }\n}","import { ethers } from 'ethers'\nimport { JsonRpcRouter, JsonRpcSender, loggingProviderMiddleware, EagerProvider, SingleflightMiddleware, CachedProvider, JsonRpcMiddleware, JsonRpcMiddlewareHandler } from './json-rpc'\nimport { networks, ChainId } from './config'\n\nexport interface JsonRpcProviderOptions {\n  // ..\n  chainId? :number\n\n  // ..\n  middlewares?: Array<JsonRpcMiddleware | JsonRpcMiddlewareHandler>\n\n  // ..\n  blockCache?: boolean | string[]\n}\n\n// JsonRpcProvider with a middleware stack. By default it will use a simple caching middleware.\nexport class JsonRpcProvider extends ethers.providers.JsonRpcProvider {\n  private _chainId?: number\n  private _sender: JsonRpcSender\n\n  constructor(url: ethers.utils.ConnectionInfo | string, options?: JsonRpcProviderOptions) {\n    super(url, options?.chainId)\n\n    const chainId = options?.chainId\n    const middlewares = options?.middlewares\n    const blockCache = options?.blockCache\n\n    this._chainId = chainId\n\n    // NOTE: it will either use the middleware stack passed to the constructor\n    // or it will use the default caching middleware provider. It does not concat them,\n    // so if you set middlewares, make sure you set the caching middleware yourself if you'd\n    // like to keep using it.\n    const router = new JsonRpcRouter(\n      middlewares ?? \n      [\n        // loggingProviderMiddleware,\n        new EagerProvider({ chainId }),\n        new SingleflightMiddleware(),\n        new CachedProvider({ defaultChainId: chainId, blockCache: blockCache })\n      ],\n      new JsonRpcSender(this.fetch, chainId)\n    )\n\n    this._sender = new JsonRpcSender(router, chainId)\n  }\n\n  async getNetwork(): Promise<ethers.providers.Network> {\n    const chainId = this._chainId\n    if (chainId) {\n      const network = networks[chainId as ChainId]\n      const name = network?.name || ''\n      const ensAddress = network?.ensAddress\n      return {\n        name: name,\n        chainId: chainId,\n        ensAddress: ensAddress\n      }\n    } else {\n      const chainIdHex = await this.send('eth_chainId', [])\n      this._chainId = ethers.BigNumber.from(chainIdHex).toNumber()\n      return this.getNetwork()\n    }\n  }\n\n  send = (method: string, params: Array<any>): Promise<any> => {\n    return this._sender.send(method, params)\n  }\n\n  private fetch = (method: string, params: Array<any>): Promise<any> => {\n    const request = {\n      method: method,\n      params: params,\n      id: (this._nextId++),\n      jsonrpc: '2.0'\n    }\n\n    const result = ethers.utils.fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n      return result\n    }, (error) => {\n      throw error\n    })\n\n    return result\n  }\n}\n\nfunction getResult(payload: { error?: { code?: number, data?: any, message?: string }, result?: any }): any {\n  if (payload.error) {\n    // @TODO: not any\n    const error: any = new Error(payload.error.message)\n    error.code = payload.error.code\n    error.data = payload.error.data\n    throw error\n  }\n  return payload.result\n}\n","import { BigNumber, ethers } from 'ethers'\nimport { walletContracts } from '@0xsequence/abi'\nimport { JsonRpcMethod } from './constants'\nimport { BlockTag, eqBlockTag, parseBlockTag, partition, safeSolve } from './utils'\nimport { promisify, getRandomInt } from '@0xsequence/utils'\nimport { JsonRpcVersion, JsonRpcRequest, JsonRpcResponseCallback, JsonRpcHandlerFunc, sequenceContext } from \"@0xsequence/network\"\n\nexport type MulticallOptions = {\n  // number of calls to enqueue before calling.\n  batchSize: number,\n\n  // number of calls to batch within a time window (in milliseconds). If 0, will disable timeWindow.\n  timeWindow: number,\n\n  // contract is the address of the Sequence MultiCallUtils smart contract where\n  // the batched multicall is sent to an Ethereum node.\n  contract: string,\n\n  // logs details about aggregated calls\n  verbose: boolean\n}\n\ntype QueueEntry = {\n  request: JsonRpcRequest,\n  callback: JsonRpcResponseCallback,\n  next: JsonRpcHandlerFunc,\n  error?: boolean,\n  result?: JsonRpcResponseCallback\n}\n\nconst DefaultMulticallOptions = {\n  batchSize: 50,\n  timeWindow: 50,\n  contract: sequenceContext.sequenceUtils!,\n  verbose: false\n}\n\nexport class Multicall {\n  public static DefaultOptions = { ... DefaultMulticallOptions }\n\n  readonly batchableJsonRpcMethods = [\n    JsonRpcMethod.ethCall,\n    JsonRpcMethod.ethGetCode,\n    JsonRpcMethod.ethGetBalance\n  ]\n\n  readonly multicallInterface = new ethers.utils.Interface(walletContracts.sequenceUtils.abi)\n\n  public options: MulticallOptions\n\n  constructor(options?: Partial<MulticallOptions>) {\n    this.options = options ? { ...Multicall.DefaultOptions, ...options } : Multicall.DefaultOptions\n    if (this.options.batchSize <= 0) throw new Error(`Invalid batch size of ${this.options.batchSize}`)\n  }\n\n  private timeout: NodeJS.Timeout | undefined\n  private queue = [] as QueueEntry[]\n\n  scheduleExecution = () => {\n    if (this.queue.length > 0) {\n      if (this.timeout) clearTimeout(this.timeout)\n      this.timeout = setTimeout(this.run, this.options.timeWindow)\n    }\n  }\n\n  handle = (next: JsonRpcHandlerFunc, request: JsonRpcRequest, callback: JsonRpcResponseCallback) => {\n    // Schedule for batching and return\n    if (this.batchableJsonRpcMethods.find((m) => m === request.method)) {\n      this.queue.push({\n        request: request,\n        callback: callback,\n        next: next\n      })\n      if (this.options.verbose) console.log('Scheduling call', request.method)\n      this.scheduleExecution()\n      return\n    }\n\n    if (this.options.verbose) console.log('Forwarded call', request.method)\n\n    // Move to next handler\n    return next(request, callback)\n  }\n\n  run = async () => {\n    /* eslint-disable no-var */\n    if (this.options.verbose) console.log('Processing multicall')\n\n    // Read items from queue\n    const limit = Math.min(this.options.batchSize, this.queue.length)\n    if (limit === 0) return\n\n    // Skip multicall on single item\n    if (limit === 1) {\n      this.forward(this.queue[0])\n      this.queue = []\n      if (this.options.verbose) console.log('Skip multicall, single item')\n      return\n    }\n\n    if (this.options.verbose) console.log('Resolving', limit)\n\n    // Get batch from queue\n    var items = this.queue.slice(0, limit)\n\n    // Update queue\n    this.queue = limit === this.queue.length ? [] : this.queue.slice(limit)\n    if (this.options.verbose) console.log('Updated queue', this.queue.length)\n\n    if (this.queue.length !== 0) {\n      this.scheduleExecution()\n    }\n\n    // Get next candidate\n    const next = items[0].next as JsonRpcHandlerFunc\n    let blockTag: BlockTag | undefined\n\n    // Partition incompatible calls\n    var [items, discartItems] = partition(items, (item) => {\n      try {\n        // Mixed next callbacks\n        if (item.next !== next) return false\n\n        switch (item.request.method) {\n          case JsonRpcMethod.ethCall:\n            // Unsupported eth_call parameters\n            if (\n              item.request.params![0].from ||\n              item.request.params![0].gasPrice ||\n              item.request.params![0].value\n            ) {\n              return false  \n            }\n          case JsonRpcMethod.ethGetBalance:\n          case JsonRpcMethod.ethGetCode:\n            // Mixed blockTags\n            const itemBlockTag = parseBlockTag(item.request.params![1])\n            if (blockTag === undefined) blockTag = itemBlockTag\n            if (!eqBlockTag(itemBlockTag, blockTag)) return false\n        }\n\n        return true\n      } catch {\n        return false\n      }\n    })\n\n    // Forward discarted items\n    // end execution if no items remain\n    if (discartItems.length !== 0) {\n      if (this.options.verbose) console.log('Forwarding incompatible calls', discartItems.length)\n      this.forward(discartItems)\n      if (items.length === 0) return\n    }\n\n    // Aggregate all calls\n    let callParams = items.map((v) => {\n      try {\n        switch (v.request.method) {\n          case JsonRpcMethod.ethCall:\n            return {\n              delegateCall: false,\n              revertOnError: false,\n              target: v.request.params![0].to,\n              data: v.request.params![0].data,\n              gasLimit: v.request.params![0].gas ? v.request.params![0].gas : 0,\n              value: 0\n            }\n          case JsonRpcMethod.ethGetCode:\n            return {\n              delegateCall: false,\n              revertOnError: false,\n              target: this.options.contract,\n              gasLimit: 0,\n              value: 0,\n              data: this.multicallInterface.encodeFunctionData(\n                this.multicallInterface.getFunction('callCode'), [v.request.params![0]]\n              )\n            }\n          case JsonRpcMethod.ethGetBalance:\n            return {\n              delegateCall: false,\n              revertOnError: false,\n              target: this.options.contract,\n              gasLimit: 0,\n              value: 0,\n              data: this.multicallInterface.encodeFunctionData(\n                this.multicallInterface.getFunction('callBalanceOf'), [v.request.params![0]]\n              )\n            }\n          default:\n            return null\n          }\n        } catch {\n          return null\n        }\n      }\n    )\n\n    // Filter calls with enconding errors and forward items\n    var [items, discartItems] = partition(items, (_, i: number) => callParams[i] !== undefined)\n    callParams = callParams.filter((c) => c)\n\n    if (discartItems.length !== 0) {\n      if (this.options.verbose) console.log('Forwarding calls on error', discartItems.length)\n      this.forward(discartItems)\n      if (items.length === 0) return\n    }\n\n    // Encode multicall\n    let encodedCall: string\n    try {\n      encodedCall = this.multicallInterface.encodeFunctionData(\n        this.multicallInterface.getFunction('multiCall'), [callParams]\n      )\n    } catch {\n      this.forward(items)\n      return\n    }\n\n    // Forward single multicall rpc call\n    const reqId = getRandomInt()\n\n    // TODO: fix types below..\n\n    const res = await safeSolve(\n      // @ts-ignore\n      promisify<JsonRpcRequest, JsonRpcResponse>(next)({\n        id: reqId!,\n        jsonrpc: JsonRpcVersion!,\n        method: JsonRpcMethod.ethCall!,\n        params: [{\n          to: this.options.contract!,\n          value: 0,\n          data: encodedCall!\n        }, BigNumber.isBigNumber(blockTag) ? blockTag.toNumber() : blockTag]\n      // @ts-ignore\n      }), (e) => ({\n        jsonrpc: JsonRpcVersion!,\n        id: reqId!,\n        result: undefined,\n        error: e!\n      })\n    )\n    \n    // Error calling multicall\n    // Forward all calls to middleware\n    // @ts-ignore\n    if (res.error) {\n      return this.forward(items)\n    }\n\n    // Decode result from multicall\n    let decoded: ethers.utils.Result\n    try {\n      // @ts-ignore\n      decoded = this.multicallInterface.decodeFunctionResult(this.multicallInterface.getFunction('multiCall'), res.result)\n    } catch {\n      this.forward(items)\n      return\n    }\n\n    // Send results for each request\n    // errors fallback through the middleware\n    if (this.options.verbose) console.log('Got response for', items.length)\n    items.forEach((item, index) => {\n      if (!decoded[0][index]) {\n        this.forward(item)\n      } else {\n        switch (item.request.method) {\n          case JsonRpcMethod.ethCall:\n            item.callback(undefined, {\n              jsonrpc: item.request.jsonrpc!,\n              id: item.request.id!,\n              result: decoded[1][index]\n            })\n            break\n          case JsonRpcMethod.ethGetCode:\n            item.callback(undefined, {\n              jsonrpc: item.request.jsonrpc!,\n              id: item.request.id!,\n              result: ethers.utils.defaultAbiCoder.decode(['bytes'], decoded[1][index])[0]\n            })\n            break\n          case JsonRpcMethod.ethGetBalance:\n            item.callback(undefined, {\n              jsonrpc: item.request.jsonrpc!,\n              id: item.request.id!,\n              result: ethers.utils.defaultAbiCoder.decode(['uint256'], decoded[1][index])[0]\n            })\n            break\n        }\n      }\n    })\n  }\n\n  private forward(entries: QueueEntry[] | QueueEntry) {\n    if (Array.isArray(entries)) {\n      entries.forEach((e) => e.next(e.request, e.callback))\n    } else {\n      entries.next(entries.request, entries.callback)\n    }\n  }\n\n  static isMulticall(cand: any): cand is Multicall {\n    return (\n      cand &&\n      cand.handle !== undefined &&\n      cand.conf !== undefined &&\n      Multicall.isMulticallOptions(cand.options)\n    )\n  }\n\n  static isMulticallOptions(cand: any): cand is MulticallOptions {\n    return (\n      cand !== undefined &&\n      cand.batchSize !== undefined &&\n      cand.timeWindow !== undefined &&\n      cand.contract !== undefined\n    )\n  }\n}\n","import { ethers, BigNumber, utils } from 'ethers'\nimport { promisify, getRandomInt } from '@0xsequence/utils'\nimport { Multicall, MulticallOptions } from '../multicall'\nimport { JsonRpcMethod } from '../constants'\nimport { JsonRpcVersion, JsonRpcRequest, JsonRpcResponseCallback } from '@0xsequence/network'\n\nexport const ProxyMethods = [\n  'getNetwork',\n  'getBlockNumber',\n  'getGasPrice',\n  'getTransactionCount',\n  'getStorageAt',\n  'sendTransaction',\n  'estimateGas',\n  'getBlock',\n  'getTransaction',\n  'getTransactionReceipt',\n  'getLogs',\n  'emit',\n  'litenerCount',\n  'addListener',\n  'removeListener',\n  'waitForTransaction',\n  'detectNetwork',\n  'getBlockWithTransactions'\n]\n\nexport class MulticallProvider extends ethers.providers.BaseProvider {\n  private multicall: Multicall\n\n  constructor(private provider: ethers.providers.Provider, multicall?: Multicall | Partial<MulticallOptions>) {\n    super(provider.getNetwork())\n    this.multicall = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall)\n\n    ProxyMethods.forEach(m => {\n      if ((provider as any)[m] !== undefined) {\n        ;(this as any)[m] = (...args: any) => (provider as any)[m](...args)\n      }\n    })\n  }\n\n  listenerCount = this.provider.listenerCount\n\n  getResolver = async (name: string | Promise<string>) => {\n    const provider = this.provider as ethers.providers.BaseProvider\n\n    if (provider.getResolver) {\n      const ogResolver = await provider.getResolver(await name)\n      if (!ogResolver) return null\n      return new ethers.providers.Resolver(this as any, ogResolver.address, ogResolver.name)\n    }\n\n    return provider.getResolver(await name)\n  }\n\n  next = async (req: JsonRpcRequest, callback: JsonRpcResponseCallback) => {\n    try {\n      switch (req.method) {\n        case JsonRpcMethod.ethCall:\n          this.callback(req, callback, await this.provider.call(req.params![0], req.params![1]))\n          break\n\n        case JsonRpcMethod.ethGetCode:\n          this.callback(req, callback, await this.provider.getCode(req.params![0], req.params![1]))\n          break\n\n        case JsonRpcMethod.ethGetBalance:\n          this.callback(req, callback, await this.provider.getBalance(req.params![0], req.params![1]))\n          break\n      }\n    } catch (e) {\n      this.callback(req, callback, undefined, e)\n    }\n  }\n\n  private callback(req: JsonRpcRequest, callback: JsonRpcResponseCallback, resp: any, err?: any) {\n    callback(err, {\n      jsonrpc: JsonRpcVersion,\n      id: req.id!,\n      result: resp,\n      error: err\n    })\n  }\n\n  async call(\n    transaction: utils.Deferrable<ethers.providers.TransactionRequest>,\n    blockTag?: string | number | Promise<ethers.providers.BlockTag>\n  ): Promise<string> {\n    return this.rpcCall(JsonRpcMethod.ethCall, transaction, blockTag)\n  }\n\n  async getCode(\n    addressOrName: string | Promise<string>,\n    blockTag?: string | number | Promise<ethers.providers.BlockTag>\n  ): Promise<string> {\n    return this.rpcCall(JsonRpcMethod.ethGetCode, addressOrName, blockTag)\n  }\n\n  async getBalance(\n    addressOrName: string | Promise<string>,\n    blockTag?: string | number | Promise<ethers.providers.BlockTag>\n  ): Promise<BigNumber> {\n    return this.rpcCall(JsonRpcMethod.ethGetBalance, addressOrName, blockTag)\n  }\n\n  async rpcCall(method: string, ...params: any[]): Promise<any> {\n    const reqId = getRandomInt()\n    const resp = await promisify(this.multicall.handle)(this.next, {\n      jsonrpc: JsonRpcVersion,\n      id: reqId,\n      method: method,\n      params: params\n    })\n    return resp!.result\n  }\n}\n","import { providers } from 'ethers'\nimport { Multicall, MulticallOptions } from '../multicall'\nimport { JsonRpcRequest, JsonRpcResponseCallback } from '@0xsequence/network'\n\ntype ExternalProvider = providers.ExternalProvider\n\nexport class MulticallExternalProvider implements ExternalProvider {\n  private multicall: Multicall\n\n  constructor(private provider: providers.ExternalProvider, multicall?: Multicall | Partial<MulticallOptions>) {\n    this.multicall = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall!)\n\n    if (provider.send) {\n      const next = async (req: JsonRpcRequest, callback: JsonRpcResponseCallback) => {\n        provider.send!(req, callback)\n      }\n\n      ;(this as any).send = (request: JsonRpcRequest, callback: JsonRpcResponseCallback) => {\n        this.multicall.handle(next, request, callback)\n      }\n    }\n\n    if (provider.sendAsync) {\n      const next = async (req: JsonRpcRequest, callback: JsonRpcResponseCallback) => {\n        provider.sendAsync!(req, callback)\n      }\n\n      ;(this as any).sendAsync = (request: JsonRpcRequest, callback: JsonRpcResponseCallback) => {\n        this.multicall.handle(next, request, callback)\n      }\n    }\n  }\n\n  public get isMetaMask() {\n    return this.provider.isMetaMask\n  }\n\n  public get isStatus() {\n    return this.provider.isStatus\n  }\n}\n","import { Multicall, MulticallOptions } from '../multicall'\nimport { JsonRpcRequest, JsonRpcResponseCallback, JsonRpcHandlerFunc, JsonRpcMiddleware } from '@0xsequence/network'\n\nexport const multicallMiddleware =\n  (multicall?: Multicall | Partial<MulticallOptions>): JsonRpcMiddleware =>\n  (next: JsonRpcHandlerFunc) => {\n    const lib = Multicall.isMulticall(multicall) ? multicall : new Multicall(multicall!)\n    return (request: JsonRpcRequest, callback: JsonRpcResponseCallback) => {\n      return lib.handle(next, request, callback)\n    }\n  }\n","import * as multicall from '@0xsequence/multicall'\nimport { BytesLike, ethers } from 'ethers'\nimport { WalletConfig } from \".\"\n\nexport type DecodedSignature = {\n  threshold: number\n  signers: DecodedSignaturePart[]\n}\n\nexport type DecodedSignaturePart = DecodedAddressPart | DecodedEOASigner | DecodedEOASplitSigner | DecodedFullSigner\n\nexport type DecodedAddressPart = {\n  weight: number\n  address: string\n}\n\nexport type DecodedEOASigner = {\n  weight: number\n  signature: ethers.BytesLike\n}\n\nexport type DecodedEOASplitSigner = {\n  weight: number\n  r: string\n  s: string\n  v: number\n  t: number\n}\n\nexport type DecodedFullSigner = {\n  weight: number\n  address: string\n  signature: ethers.BytesLike\n}\n\nexport function isDecodedAddress(cand: DecodedSignaturePart): cand is DecodedAddressPart {\n  const c = cand as any; return c.address !== undefined && !isDecodedSigner(cand)\n}\n\nexport function isDecodedSigner(cand: DecodedSignaturePart): cand is DecodedEOASigner | DecodedEOASplitSigner | DecodedFullSigner {\n  return isDecodedEOASigner(cand) || isDecodedEOASplitSigner(cand) || isDecodedFullSigner(cand)\n}\n\nexport function isDecodedEOASigner(cand: DecodedSignaturePart): cand is DecodedEOASigner {\n  const c = cand as any\n\n  return (\n    c.signature !== undefined &&\n    c.address === undefined\n  )\n}\n\nexport function isDecodedEOASplitSigner(cand: DecodedSignaturePart): cand is DecodedEOASplitSigner {\n  const c = cand as any\n\n  return (\n    c.r !== undefined &&\n    c.s !== undefined &&\n    c.v !== undefined &&\n    c.t !== undefined\n  )\n}\n\nexport function isDecodedFullSigner(cand: DecodedSignaturePart): cand is DecodedFullSigner {\n  const c = cand as any\n\n  return (\n    c.address !== undefined &&\n    c.signature !== undefined\n  )\n}\n\nexport enum SignatureType {\n  EOA = 0,\n  Address = 1,\n  Full = 2\n}\n\n\nexport const decodeSignature = (signature: string | DecodedSignature): DecodedSignature => {\n  if (typeof signature !== 'string') return signature\n\n  const auxsig = signature.replace('0x', '')\n\n  const threshold = ethers.BigNumber.from(`0x${auxsig.slice(0, 4)}`).toNumber()\n\n  const signers: DecodedSignaturePart[] = []\n\n  for (let rindex = 4; rindex < auxsig.length; ) {\n    const signatureType = ethers.BigNumber.from(auxsig.slice(rindex, rindex + 2)).toNumber() as SignatureType\n    rindex += 2\n\n    const weight = ethers.BigNumber.from(`0x${auxsig.slice(rindex, rindex + 2)}`).toNumber()\n    rindex += 2\n\n    switch (signatureType) {\n      case SignatureType.Address:\n        const addr = ethers.utils.getAddress(auxsig.slice(rindex, rindex + 40))\n        rindex += 40\n  \n        signers.push({\n          weight: weight,\n          address: addr\n        })\n        break;\n    \n      case SignatureType.EOA:\n        const sig = ethers.utils.arrayify(`0x${auxsig.slice(rindex, rindex + 132)}`)\n        rindex += 132\n\n        const split = ethers.utils.splitSignature(sig.slice(0, 65))\n        const r = split.r\n        const s = split.s\n        const v = split.v\n  \n        const t = ethers.BigNumber.from(sig[sig.length - 1]).toNumber()\n  \n        signers.push({\n          weight: weight,\n          signature: sig,\n          r: r,\n          s: s,\n          v: v,\n          t: t\n        })\n\n        break\n\n      case SignatureType.Full:\n        const address = ethers.utils.getAddress(auxsig.slice(rindex, rindex + 40))\n        rindex += 40\n\n        const size = ethers.BigNumber.from(`0x${auxsig.slice(rindex, rindex + 4)}`).mul(2).toNumber()\n        rindex += 4\n\n        const signature = ethers.utils.arrayify(`0x${auxsig.slice(rindex, rindex + size)}`)\n        rindex += size\n\n        signers.push({\n          weight: weight,\n          address: address,\n          signature: signature\n        })\n        break\n\n      default:\n        throw Error('Signature type not supported')\n    }\n  }\n\n  return {\n    threshold: threshold,\n    signers: signers\n  }\n}\n\nconst SIG_TYPE_EIP712 = 1\nconst SIG_TYPE_ETH_SIGN = 2\nconst SIG_TYPE_WALLET_BYTES32 = 3\n\nexport const splitDecodedEOASigner = (sig: DecodedEOASigner): DecodedEOASplitSigner => {\n  const signature = ethers.utils.arrayify(sig.signature)\n  const split = ethers.utils.splitSignature(signature.slice(0, 65))\n  const t = ethers.BigNumber.from(signature[signature.length - 1]).toNumber()\n\n  return {\n    ...sig,\n    ...split,\n    t: t\n  }\n}\n\nexport const recoverEOASigner = (digest: BytesLike, sig: DecodedEOASigner | DecodedEOASplitSigner) => {\n  const signature = isDecodedEOASplitSigner(sig) ? sig : splitDecodedEOASigner(sig)\n\n  switch (signature.t) {\n    case SIG_TYPE_EIP712:\n      return ethers.utils.recoverAddress(digest, {\n        r: signature.r,\n        s: signature.s,\n        v: signature.v\n      })\n    case SIG_TYPE_ETH_SIGN:\n      const subDigest = ethers.utils.keccak256(\n        ethers.utils.solidityPack(\n          ['string', 'bytes32'],\n          ['\\x19Ethereum Signed Message:\\n32', digest]\n        )\n      )\n\n      return ethers.utils.recoverAddress(subDigest, {\n        r: signature.r,\n        s: signature.s,\n        v: signature.v\n      })\n    default:\n      throw new Error('Unknown signature')\n  }\n}\n\nexport const joinSignatures = (...signatures: Array<DecodedSignature | string>): DecodedSignature => {\n  const parts = signatures.map((s) => typeof s === 'string' ? decodeSignature(s) : s)\n  return parts.reduce((p, c) => joinTwoSignatures(p, c))\n}\n\nexport const joinTwoSignatures = (a: DecodedSignature, b: DecodedSignature): DecodedSignature => {\n  return { threshold: a.threshold, signers: a.signers.map((s, i) => isDecodedAddress(s) ? b.signers[i] : s) }\n}\n\nexport const encodeSignature = (sig: DecodedSignature | string): string => {\n  if (typeof sig === 'string') return encodeSignature(decodeSignature(sig))\n\n  const accountBytes = sig.signers.map(s => {\n    if (isDecodedAddress(s)) {\n      return ethers.utils.solidityPack(\n        ['uint8', 'uint8', 'address'],\n        [SignatureType.Address, s.weight, s.address]\n      )\n    }\n\n    if (isDecodedEOASplitSigner(s)) {\n      return ethers.utils.solidityPack(\n        ['uint8', 'uint8', 'bytes32', 'bytes32', 'uint8', 'uint8'],\n        [SignatureType.EOA, s.weight, s.r, s.s, s.v, s.t]\n      )\n    }\n\n    if (isDecodedFullSigner(s)) {\n      const signatureSize = ethers.utils.arrayify(s.signature).length\n      return ethers.utils.solidityPack(\n        ['uint8', 'uint8', 'address', 'uint16', 'bytes'],\n        [SignatureType.Full, s.weight, s.address, signatureSize, s.signature]\n      )\n    }\n\n    if (isDecodedEOASigner(s)) {\n      return ethers.utils.solidityPack(\n        ['uint8', 'uint8', 'bytes'], \n        [SignatureType.EOA, s.weight, s.signature]\n      )\n    }\n\n    throw Error('Unkwnown signature part type')\n  })\n\n  return ethers.utils.solidityPack(['uint16', ...Array(accountBytes.length).fill('bytes')], [sig.threshold, ...accountBytes])\n}\n\nexport function signerOf(part: DecodedSignaturePart, digest: BytesLike): string {\n  if (isDecodedAddress(part)) {\n    return part.address\n  }\n\n  if (isDecodedFullSigner(part)) {\n    return part.address\n  }\n\n  if (isDecodedEOASplitSigner(part) || isDecodedEOASigner(part)) {\n    return recoverEOASigner(digest, part)\n  }\n\n  throw Error('Unkwnown signature part type')\n}\n\nexport function mutateSignature(sig: DecodedSignature, config: WalletConfig, digest: BytesLike): DecodedSignature {\n  const allSigners = sig.signers.map((s) => signerOf(s, digest))\n\n  return {\n    threshold: config.threshold,\n    signers: config.signers.map((s) => {\n      const found = allSigners.indexOf(s.address)\n      if (found !== -1) {\n        const part = sig.signers[found]\n        return { ...part, weight: s.weight }\n      }\n\n      return {\n        weight: s.weight,\n        address: s.address\n      }\n    })\n  }\n}\n\nexport async function buildStubSignature(\n  provider: ethers.providers.Provider,\n  config: WalletConfig\n): Promise<DecodedSignature> {\n  const multicallProvider = new multicall.providers.MulticallProvider(provider)\n\n  // Pre-load if signers are EOAs or not\n  const signers = await Promise.all(\n    config.signers.map(async (s, i) => {\n      return {\n        ...s,\n        index: i,\n        isEOA: ethers.utils.arrayify((await multicallProvider.getCode(s.address))).length === 0\n      }\n    })\n  )\n\n  // Sort signers by weight\n  // and prepare them for selection\n  let sortedSigners: {\n    weight: number,\n    index: number,\n    address: string,\n    isEOA: boolean,\n    willSign?: boolean\n  }[] = signers.sort((a, b) => a.weight - b.weight)\n\n  // Keep track of the total signing power\n  let totalWeight = 0\n\n  // First pick non-eoa signers\n  sortedSigners = sortedSigners.map((s) => {\n    if (totalWeight >= config.threshold || s.isEOA) return s\n\n    totalWeight += s.weight\n    return { ...s, willSign: true }\n  })\n\n  // If we still haven't reached threshold\n  // start picking non-EOA signers\n  if (totalWeight < config.threshold) {\n    sortedSigners = sortedSigners.map((s) => {\n      if (s.willSign || totalWeight >= config.threshold) return s\n\n      totalWeight += s.weight\n      return { ...s, willSign: true }\n    })\n  }\n\n  // Stub signature part\n  // pre-determined signature, tailored for worse-case scenario in gas costs\n  const stubSig = ethers.utils.arrayify(\"0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a01b02\")\n\n  // Re-sort signers by original index\n  const finalSigners = sortedSigners.sort((a, b) => a.index - b.index)\n\n  // Map final signers to signature parts\n  return {\n    threshold: config.threshold,\n    signers: finalSigners.map((s) => {\n      // If wallet shouldn't sign\n      // just return address part\n      if (!s.willSign) {\n        return {\n          address: s.address,\n          weight: s.weight,\n        } as DecodedAddressPart\n      }\n\n      // If wallet is EOA return signature\n      // part is with stubSign\n      if (s.isEOA) {\n        return {\n          weight: s.weight,\n          signature: stubSig,\n        } as DecodedEOASigner\n      }\n\n      // If wallet is a contract\n      // build a stub nested signature\n      return {\n        weight: s.weight,\n        address: s.address,\n        signature: encodeSignature({\n          threshold: 1,\n          signers: [\n            {\n              address: ethers.Wallet.createRandom().address,\n              weight: 1,\n            },\n            {\n              weight: 1,\n              signature: stubSig\n            }\n          ]\n        }) + ethers.utils.hexlify(SIG_TYPE_WALLET_BYTES32).substring(2)\n      }\n    })\n  }\n}\n","/* eslint-disable */\n// sequence-indexer v0.4.0 3254a537c563d6b612b7ab5365c305664abb5951\n// --\n// Code generated by webrpc-gen@v0.10.x-dev with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=indexer.ridl -target=typescript -client -out=./clients/indexer.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = \"v1\"\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = \"v0.4.0\"\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = \"3254a537c563d6b612b7ab5365c305664abb5951\"\n\n//\n// Types\n//\n\n\nexport interface ContractInfo {\n  chainId: number\n  address: string\n  name: string\n  type: string\n  symbol: string\n  decimals?: number\n  logoURI: string\n  deployed: boolean\n  bytecodeHash: string\n  extensions: ContractInfoExtensions\n  \n}\n\nexport interface ContractInfoExtensions {\n  link: string\n  description: string\n  ogImage: string\n  originChainId: number\n  originAddress: string\n  blacklist: boolean\n}\n\nexport interface TokenMetadata {\n  tokenId: string\n  contractAddress: string\n  name: string\n  description: string\n  image: string\n  decimals: number\n  properties: {[key: string]: any}\n  video: string\n  audio: string\n  image_data: string\n  external_url: string\n  background_color: string\n  animation_url: string\n  attributes: Array<{[key: string]: any}>\n}\nexport enum ContractType {\n  UNKNOWN = 'UNKNOWN',\n  ERC20 = 'ERC20',\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n  SEQUENCE_WALLET = 'SEQUENCE_WALLET',\n  ERC20_BRIDGE = 'ERC20_BRIDGE',\n  ERC721_BRIDGE = 'ERC721_BRIDGE',\n  ERC1155_BRIDGE = 'ERC1155_BRIDGE'\n}\nexport enum EventLogType {\n  UNKNOWN = 'UNKNOWN',\n  BLOCK_ADDED = 'BLOCK_ADDED',\n  BLOCK_REMOVED = 'BLOCK_REMOVED'\n}\nexport enum EventLogDataType {\n  UNKNOWN = 'UNKNOWN',\n  TOKEN_TRANSFER = 'TOKEN_TRANSFER',\n  NATIVE_TOKEN_TRANSFER = 'NATIVE_TOKEN_TRANSFER',\n  SEQUENCE_TXN = 'SEQUENCE_TXN'\n}\nexport enum TxnTransferType {\n  UNKNOWN = 'UNKNOWN',\n  SEND = 'SEND',\n  RECEIVE = 'RECEIVE'\n}\nexport enum TransactionStatus {\n  FAILED = 'FAILED',\n  SUCCESSFUL = 'SUCCESSFUL'\n}\nexport enum TransactionType {\n  LegacyTxnType = 'LegacyTxnType',\n  AccessListTxnType = 'AccessListTxnType',\n  DynamicFeeTxnType = 'DynamicFeeTxnType'\n}\nexport enum SortOrder {\n  DESC = 'DESC',\n  ASC = 'ASC'\n}\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  indexerEnabled: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n  chainID: number\n  checks: RuntimeChecks\n}\n\nexport interface RuntimeChecks {\n  running: boolean\n  cgoEnabled: boolean\n  syncMode: string\n  lastBlockNum: number\n  lastBlockNumWithState: number\n}\n\nexport interface EtherBalance {\n  accountAddress: string\n  balanceWei: string\n}\n\nexport interface IndexState {\n  chainId: string\n  lastBlockNum: number\n  lastBlockHash: string\n}\n\nexport interface IndexedBlock {\n  blockNumber: number\n  blockShortHash: string\n}\n\nexport interface TxnData {\n  from: string\n  to: string\n  value: string\n}\n\nexport interface EventLog {\n  id: number\n  type: EventLogType\n  blockNumber: number\n  blockHash: string\n  parentBlockHash: string\n  contractAddress: string\n  contractType: ContractType\n  txnHash: string\n  txnIndex: number\n  txnData: TxnData\n  txnLogIndex: number\n  logDataType: EventLogDataType\n  ts: string\n  logData: string\n}\n\nexport interface TokenBalance {\n  contractType: ContractType\n  contractAddress: string\n  accountAddress: string\n  tokenID: string\n  balance: string\n  blockHash: string\n  blockNumber: number\n  chainId: number\n  \n  contractInfo?: ContractInfo\n  tokenMetadata?: TokenMetadata\n}\n\nexport interface TokenHistory {\n  blockNumber: number\n  blockHash: string\n  accountAddress: string\n  contractAddress: string\n  contractType: ContractType\n  fromAddress: string\n  toAddress: string\n  txnHash: string\n  txnIndex: number\n  txnLogIndex: number\n  logData: string\n  tokenIDs: string\n  Amounts: string\n  ts: string\n}\n\nexport interface TokenSupply {\n  tokenID: string\n  supply: string\n  chainId: number\n  contractInfo?: ContractInfo\n  tokenMetadata?: TokenMetadata\n}\n\nexport interface Transaction {\n  txnHash: string\n  blockNumber: number\n  blockHash: string\n  chainId: number\n  metaTxnID?: string\n  transfers?: Array<TxnTransfer>\n  timestamp: string\n}\n\nexport interface TxnTransfer {\n  transferType: TxnTransferType\n  contractAddress: string\n  contractType: ContractType\n  from: string\n  to: string\n  tokenIds?: Array<string>\n  amounts: Array<string>\n  logIndex: number\n  contractInfo?: ContractInfo\n  tokenMetadata?: {[key: string]: TokenMetadata}\n}\n\nexport interface TransactionHistoryFilter {\n  accountAddress?: string\n  contractAddress?: string\n  accountAddresses?: Array<string>\n  contractAddresses?: Array<string>\n  transactionHashes?: Array<string>\n  metaTransactionIDs?: Array<string>\n  fromBlock?: number\n  toBlock?: number\n  tokenID?: string\n}\n\nexport interface Filter {\n  txnHash?: string\n  from?: string\n  to?: string\n  contractAddress?: string\n  logTopic?: string\n}\n\nexport interface TransactionReceipt {\n  txnHash: string\n  txnStatus: TransactionStatus\n  txnIndex: number\n  txnType: TransactionType\n  blockHash: string\n  blockNumber: number\n  gasUsed: number\n  effectiveGasPrice: string\n  from: string\n  to: string\n  logs: Array<TransactionLog>\n  final: boolean\n  reorged: boolean\n}\n\nexport interface TransactionLog {\n  contractAddress: string\n  topics: Array<string>\n  data: string\n  index: number\n}\n\nexport interface Page {\n  page?: number\n  column?: string\n  before?: any\n  after?: any\n  sort?: Array<SortBy>\n  pageSize?: number\n  more?: boolean\n}\n\nexport interface SortBy {\n  column: string\n  order: SortOrder\n}\n\nexport interface Indexer {\n  ping(headers?: object): Promise<PingReturn>\n  version(headers?: object): Promise<VersionReturn>\n  runtimeStatus(headers?: object): Promise<RuntimeStatusReturn>\n  getChainID(headers?: object): Promise<GetChainIDReturn>\n  getEtherBalance(args: GetEtherBalanceArgs, headers?: object): Promise<GetEtherBalanceReturn>\n  getTokenBalances(args: GetTokenBalancesArgs, headers?: object): Promise<GetTokenBalancesReturn>\n  getTokenSupplies(args: GetTokenSuppliesArgs, headers?: object): Promise<GetTokenSuppliesReturn>\n  getTokenSuppliesMap(args: GetTokenSuppliesMapArgs, headers?: object): Promise<GetTokenSuppliesMapReturn>\n  getBalanceUpdates(args: GetBalanceUpdatesArgs, headers?: object): Promise<GetBalanceUpdatesReturn>\n  getTransactionHistory(args: GetTransactionHistoryArgs, headers?: object): Promise<GetTransactionHistoryReturn>\n  syncBalance(args: SyncBalanceArgs, headers?: object): Promise<SyncBalanceReturn>\n  fetchTransactionReceipt(args: FetchTransactionReceiptArgs, headers?: object): Promise<FetchTransactionReceiptReturn>\n  fetchTransactionReceiptWithFilter(args: FetchTransactionReceiptWithFilterArgs, headers?: object): Promise<FetchTransactionReceiptWithFilterReturn>\n}\n\nexport interface PingArgs {\n}\n\nexport interface PingReturn {\n  status: boolean  \n}\nexport interface VersionArgs {\n}\n\nexport interface VersionReturn {\n  version: Version  \n}\nexport interface RuntimeStatusArgs {\n}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus  \n}\nexport interface GetChainIDArgs {\n}\n\nexport interface GetChainIDReturn {\n  chainID: number  \n}\nexport interface GetEtherBalanceArgs {\n  accountAddress?: string\n}\n\nexport interface GetEtherBalanceReturn {\n  balance: EtherBalance  \n}\nexport interface GetTokenBalancesArgs {\n  accountAddress?: string\n  contractAddress?: string\n  tokenID?: string\n  includeMetadata?: boolean\n  page?: Page\n}\n\nexport interface GetTokenBalancesReturn {\n  page: Page\n  balances: Array<TokenBalance>  \n}\nexport interface GetTokenSuppliesArgs {\n  contractAddress: string\n  includeMetadata?: boolean\n  page?: Page\n}\n\nexport interface GetTokenSuppliesReturn {\n  page: Page\n  contractType: ContractType\n  tokenIDs: Array<TokenSupply>  \n}\nexport interface GetTokenSuppliesMapArgs {\n  tokenMap: {[key: string]: Array<string>}\n  includeMetadata?: boolean\n}\n\nexport interface GetTokenSuppliesMapReturn {\n  supplies: {[key: string]: Array<TokenSupply>}  \n}\nexport interface GetBalanceUpdatesArgs {\n  contractAddress: string\n  lastBlockNumber: number\n  lastBlockHash?: string\n  page?: Page\n}\n\nexport interface GetBalanceUpdatesReturn {\n  page: Page\n  balances: Array<TokenBalance>  \n}\nexport interface GetTransactionHistoryArgs {\n  filter: TransactionHistoryFilter\n  page?: Page\n  includeMetadata?: boolean\n}\n\nexport interface GetTransactionHistoryReturn {\n  page: Page\n  transactions: Array<Transaction>  \n}\nexport interface SyncBalanceArgs {\n  accountAddress: string\n  contractAddress: string\n  tokenID?: string\n}\n\nexport interface SyncBalanceReturn {  \n}\nexport interface FetchTransactionReceiptArgs {\n  txnHash: string\n  maxBlockWait?: number\n}\n\nexport interface FetchTransactionReceiptReturn {\n  receipt: TransactionReceipt  \n}\nexport interface FetchTransactionReceiptWithFilterArgs {\n  filter: Filter\n  maxBlockWait?: number\n}\n\nexport interface FetchTransactionReceiptWithFilterReturn {\n  receipt: TransactionReceipt  \n}\n\n\n  \n//\n// Client\n//\nexport class Indexer implements Indexer {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Indexer/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n  \n  ping = (headers?: object): Promise<PingReturn> => {\n    return this.fetch(\n      this.url('Ping'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status)\n        }\n      })\n    })\n  }\n  \n  version = (headers?: object): Promise<VersionReturn> => {\n    return this.fetch(\n      this.url('Version'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          version: <Version>(_data.version)\n        }\n      })\n    })\n  }\n  \n  runtimeStatus = (headers?: object): Promise<RuntimeStatusReturn> => {\n    return this.fetch(\n      this.url('RuntimeStatus'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <RuntimeStatus>(_data.status)\n        }\n      })\n    })\n  }\n  \n  getChainID = (headers?: object): Promise<GetChainIDReturn> => {\n    return this.fetch(\n      this.url('GetChainID'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          chainID: <number>(_data.chainID)\n        }\n      })\n    })\n  }\n  \n  getEtherBalance = (args: GetEtherBalanceArgs, headers?: object): Promise<GetEtherBalanceReturn> => {\n    return this.fetch(\n      this.url('GetEtherBalance'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          balance: <EtherBalance>(_data.balance)\n        }\n      })\n    })\n  }\n  \n  getTokenBalances = (args: GetTokenBalancesArgs, headers?: object): Promise<GetTokenBalancesReturn> => {\n    return this.fetch(\n      this.url('GetTokenBalances'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          balances: <Array<TokenBalance>>(_data.balances)\n        }\n      })\n    })\n  }\n  \n  getTokenSupplies = (args: GetTokenSuppliesArgs, headers?: object): Promise<GetTokenSuppliesReturn> => {\n    return this.fetch(\n      this.url('GetTokenSupplies'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          contractType: <ContractType>(_data.contractType), \n          tokenIDs: <Array<TokenSupply>>(_data.tokenIDs)\n        }\n      })\n    })\n  }\n  \n  getTokenSuppliesMap = (args: GetTokenSuppliesMapArgs, headers?: object): Promise<GetTokenSuppliesMapReturn> => {\n    return this.fetch(\n      this.url('GetTokenSuppliesMap'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          supplies: <{[key: string]: Array<TokenSupply>}>(_data.supplies)\n        }\n      })\n    })\n  }\n  \n  getBalanceUpdates = (args: GetBalanceUpdatesArgs, headers?: object): Promise<GetBalanceUpdatesReturn> => {\n    return this.fetch(\n      this.url('GetBalanceUpdates'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          balances: <Array<TokenBalance>>(_data.balances)\n        }\n      })\n    })\n  }\n  \n  getTransactionHistory = (args: GetTransactionHistoryArgs, headers?: object): Promise<GetTransactionHistoryReturn> => {\n    return this.fetch(\n      this.url('GetTransactionHistory'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          transactions: <Array<Transaction>>(_data.transactions)\n        }\n      })\n    })\n  }\n  \n  syncBalance = (args: SyncBalanceArgs, headers?: object): Promise<SyncBalanceReturn> => {\n    return this.fetch(\n      this.url('SyncBalance'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n        }\n      })\n    })\n  }\n  \n  fetchTransactionReceipt = (args: FetchTransactionReceiptArgs, headers?: object): Promise<FetchTransactionReceiptReturn> => {\n    return this.fetch(\n      this.url('FetchTransactionReceipt'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          receipt: <TransactionReceipt>(_data.receipt)\n        }\n      })\n    })\n  }\n  \n  fetchTransactionReceiptWithFilter = (args: FetchTransactionReceiptWithFilterArgs, headers?: object): Promise<FetchTransactionReceiptWithFilterReturn> => {\n    return this.fetch(\n      this.url('FetchTransactionReceiptWithFilter'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          receipt: <TransactionReceipt>(_data.receipt)\n        }\n      })\n    })\n  }\n  \n}\n\n  \nexport interface WebRPCError extends Error {\n  code: string\n  msg: string\n\tstatus: number\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {})\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch(err) {\n      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError\n    }\n    if (!res.ok) {\n      throw data // webrpc error response\n    }\n    return data\n  })\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n","export * from './indexer.gen'\n\nimport { Indexer as IndexerRpc } from './indexer.gen'\n\n// TODO: rename to SequenceIndexerNetworks\nexport enum SequenceIndexerServices {\n  MAINNET = 'https://mainnet-indexer.sequence.app',\n\n  POLYGON = 'https://polygon-indexer.sequence.app',\n  POLYGON_MUMBAI = 'https://mumbai-indexer.sequence.app',\n  \n  POLYGON_ZKEVM = 'https://polygon-zkevm-indexer.sequence.app',\n\n  ARBITRUM = 'https://arbitrum-indexer.sequence.app',\n  ARBITRUM_NOVA = 'https://arbitrum-nova-indexer.sequence.app',\n\n  OPTIMISM = 'https://optimism-indexer.sequence.app',\n  AVALANCHE = 'https://avalanche-indexer.sequence.app',\n  GNOSIS = 'https://gnosis-indexer.sequence.app',\n\n  BSC = 'https://bsc-indexer.sequence.app',\n  BSC_TESTNET = 'https://bsc-testnet-indexer.sequence.app',\n\n  GOERLI = 'https://goerli-indexer.sequence.app'\n}\n\nconst fetch = typeof global === 'object' ? global.fetch : window.fetch\n\nexport class SequenceIndexerClient extends IndexerRpc {\n  constructor(hostname: string, public jwtAuth?: string) {\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch)\n    this.fetch = this._fetch\n  }\n\n  _fetch = (input: RequestInfo, init?: RequestInit): Promise<Response> => {\n    // automatically include jwt auth header to requests\n    // if its been set on the api client\n    const headers: { [key: string]: any } = {}\n    if (this.jwtAuth && this.jwtAuth.length > 0) {\n      headers['Authorization'] = `BEARER ${this.jwtAuth}`\n    }\n\n    // before the request is made\n    init!.headers = { ...init!.headers, ...headers }\n\n    return fetch(input, init)\n  }\n}\n\n\n// const SequenceIndexerServices: { [key: string]: string } = {}\n\n// {\n//   [ ...mainnetNetworks, ...testnetNetworks ].forEach(n => {\n//     if (n.indexerUrl) {\n//       SequenceIndexerServices[n.name.toUpperCase()] = n.indexerUrl\n//     }\n//   })\n// }\n\n// export { SequenceIndexerServices }\n","/* eslint-disable */\n// sequence-metadata v0.4.0 5d87d77b951c5d197544d97d75241bf3d02679d9\n// --\n// Code generated by webrpc-gen@v0.10.x-dev with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=metadata.ridl -target=typescript -client -out=./clients/metadata.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = \"v1\"\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = \"v0.4.0\"\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = \"5d87d77b951c5d197544d97d75241bf3d02679d9\"\n\n//\n// Types\n//\n\nexport enum ContractType {\n  UNKNOWN = 'UNKNOWN',\n  ERC20 = 'ERC20',\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155'\n}\nexport enum PropertyType {\n  INT = 'INT',\n  STRING = 'STRING',\n  ARRAY = 'ARRAY',\n  GENERIC = 'GENERIC'\n}\nexport enum SwapType {\n  UNKNOWN = 'UNKNOWN',\n  BUY = 'BUY',\n  SELL = 'SELL'\n}\nexport enum SortOrder {\n  DESC = 'DESC',\n  ASC = 'ASC'\n}\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n  checks: RuntimeChecks\n}\n\nexport interface RuntimeChecks {\n}\n\nexport interface ContractIndex {\n  chainId: number\n  address: string\n  type: ContractType\n  metadata: {[key: string]: any}\n  contentHash: number\n  deployed: boolean\n  bytecodeHash: string\n  notFound: boolean\n  \n}\n\nexport interface TokenIndex {\n  key: string\n  chainId: number\n  contractAddress: string\n  tokenId: string\n  metadata: {[key: string]: any}\n  \n  notFound: boolean\n}\n\nexport interface ContractInfo {\n  chainId: number\n  address: string\n  name: string\n  type: string\n  symbol: string\n  decimals?: number\n  logoURI: string\n  deployed: boolean\n  bytecodeHash: string\n  extensions: ContractInfoExtensions\n  \n}\n\nexport interface ContractInfoExtensions {\n  link: string\n  description: string\n  ogImage: string\n  originChainId: number\n  originAddress: string\n  blacklist: boolean\n}\n\nexport interface TokenMetadata {\n  tokenId: string\n  contractAddress: string\n  name: string\n  description: string\n  image: string\n  decimals: number\n  properties: {[key: string]: any}\n  video: string\n  audio: string\n  image_data: string\n  external_url: string\n  background_color: string\n  animation_url: string\n  attributes: Array<{[key: string]: any}>\n}\n\nexport interface PropertyFilter {\n  name: string\n  type: PropertyType\n  min?: number\n  max?: number\n  values?: Array<any>\n}\n\nexport interface Filter {\n  text?: string\n  properties?: Array<PropertyFilter>\n}\n\nexport interface GetNiftyswapUnitPricesRequest {\n  swapType: SwapType\n  ids: Array<string>\n  amounts: Array<string>\n}\n\nexport interface GetNiftyswapUnitPricesResponse {\n  unitPrice: string\n  unitAmount: string\n  availableAmount: string\n}\n\nexport interface Page {\n  pageSize?: number\n  page?: number\n}\n\nexport interface SortBy {\n  column: string\n  order: SortOrder\n}\n\nexport interface Metadata {\n  ping(headers?: object): Promise<PingReturn>\n  version(headers?: object): Promise<VersionReturn>\n  runtimeStatus(headers?: object): Promise<RuntimeStatusReturn>\n  getTokenMetadata(args: GetTokenMetadataArgs, headers?: object): Promise<GetTokenMetadataReturn>\n  refreshTokenMetadata(args: RefreshTokenMetadataArgs, headers?: object): Promise<RefreshTokenMetadataReturn>\n  getTokenMetadataBatch(args: GetTokenMetadataBatchArgs, headers?: object): Promise<GetTokenMetadataBatchReturn>\n  searchTokenMetadata(args: SearchTokenMetadataArgs, headers?: object): Promise<SearchTokenMetadataReturn>\n  searchTokenIDs(args: SearchTokenIDsArgs, headers?: object): Promise<SearchTokenIDsReturn>\n  tokenCollectionFilters(args: TokenCollectionFiltersArgs, headers?: object): Promise<TokenCollectionFiltersReturn>\n  getContractInfo(args: GetContractInfoArgs, headers?: object): Promise<GetContractInfoReturn>\n  getContractInfoBatch(args: GetContractInfoBatchArgs, headers?: object): Promise<GetContractInfoBatchReturn>\n  searchContractInfo(args: SearchContractInfoArgs, headers?: object): Promise<SearchContractInfoReturn>\n  searchContractInfoBatch(args: SearchContractInfoBatchArgs, headers?: object): Promise<SearchContractInfoBatchReturn>\n  searchMetadata(args: SearchMetadataArgs, headers?: object): Promise<SearchMetadataReturn>\n  getNiftyswapTokenQuantity(args: GetNiftyswapTokenQuantityArgs, headers?: object): Promise<GetNiftyswapTokenQuantityReturn>\n  getNiftyswapUnitPrices(args: GetNiftyswapUnitPricesArgs, headers?: object): Promise<GetNiftyswapUnitPricesReturn>\n  getNiftyswapUnitPricesWithQuantities(args: GetNiftyswapUnitPricesWithQuantitiesArgs, headers?: object): Promise<GetNiftyswapUnitPricesWithQuantitiesReturn>\n}\n\nexport interface PingArgs {\n}\n\nexport interface PingReturn {\n  status: boolean  \n}\nexport interface VersionArgs {\n}\n\nexport interface VersionReturn {\n  version: Version  \n}\nexport interface RuntimeStatusArgs {\n}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus  \n}\nexport interface GetTokenMetadataArgs {\n  chainID: string\n  contractAddress: string\n  tokenIDs: Array<string>\n}\n\nexport interface GetTokenMetadataReturn {\n  tokenMetadata: Array<TokenMetadata>  \n}\nexport interface RefreshTokenMetadataArgs {\n  chainID: string\n  contractAddress: string\n  tokenIDs?: Array<string>\n  refreshAll?: boolean\n}\n\nexport interface RefreshTokenMetadataReturn {\n  status: {[key: string]: boolean}  \n}\nexport interface GetTokenMetadataBatchArgs {\n  chainID: string\n  contractTokenMap: {[key: string]: Array<string>}\n}\n\nexport interface GetTokenMetadataBatchReturn {\n  contractTokenMetadata: {[key: string]: Array<TokenMetadata>}  \n}\nexport interface SearchTokenMetadataArgs {\n  chainID: string\n  contractAddress: string\n  filter: Filter\n  page?: Page\n}\n\nexport interface SearchTokenMetadataReturn {\n  page: Page\n  tokenMetadata: Array<TokenMetadata>  \n}\nexport interface SearchTokenIDsArgs {\n  chainID: string\n  contractAddress: string\n  filter: Filter\n  page?: Page\n}\n\nexport interface SearchTokenIDsReturn {\n  page: Page\n  tokenIds: Array<string>  \n}\nexport interface TokenCollectionFiltersArgs {\n  chainID: string\n  contractAddress: string\n}\n\nexport interface TokenCollectionFiltersReturn {\n  filters: Array<PropertyFilter>  \n}\nexport interface GetContractInfoArgs {\n  chainID: string\n  contractAddress: string\n}\n\nexport interface GetContractInfoReturn {\n  contractInfo: ContractInfo  \n}\nexport interface GetContractInfoBatchArgs {\n  chainID: string\n  contractAddresses: Array<string>\n}\n\nexport interface GetContractInfoBatchReturn {\n  contractInfoMap: {[key: string]: ContractInfo}  \n}\nexport interface SearchContractInfoArgs {\n  contractAddress: string\n}\n\nexport interface SearchContractInfoReturn {\n  contractInfoList: Array<ContractInfo>  \n}\nexport interface SearchContractInfoBatchArgs {\n  contractAddresses: Array<string>\n}\n\nexport interface SearchContractInfoBatchReturn {\n  contractInfoByChain: {[key: string]: Array<ContractInfo>}  \n}\nexport interface SearchMetadataArgs {\n  filter: string\n}\n\nexport interface SearchMetadataReturn {\n  tokenMetadata: Array<TokenMetadata>\n  contractInfo: Array<ContractInfo>  \n}\nexport interface GetNiftyswapTokenQuantityArgs {\n  chainID: string\n  contractAddress: string\n  tokenIDs: Array<string>\n}\n\nexport interface GetNiftyswapTokenQuantityReturn {\n  quantity: {[key: string]: string}  \n}\nexport interface GetNiftyswapUnitPricesArgs {\n  chainID: string\n  contractAddress: string\n  req: GetNiftyswapUnitPricesRequest\n  fresh: boolean\n}\n\nexport interface GetNiftyswapUnitPricesReturn {\n  prices: {[key: string]: string}  \n}\nexport interface GetNiftyswapUnitPricesWithQuantitiesArgs {\n  chainID: string\n  contractAddress: string\n  req: GetNiftyswapUnitPricesRequest\n  fresh: boolean\n}\n\nexport interface GetNiftyswapUnitPricesWithQuantitiesReturn {\n  prices: {[key: string]: GetNiftyswapUnitPricesResponse}  \n}\n\n\n  \n//\n// Client\n//\nexport class Metadata implements Metadata {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Metadata/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n  \n  ping = (headers?: object): Promise<PingReturn> => {\n    return this.fetch(\n      this.url('Ping'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status)\n        }\n      })\n    })\n  }\n  \n  version = (headers?: object): Promise<VersionReturn> => {\n    return this.fetch(\n      this.url('Version'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          version: <Version>(_data.version)\n        }\n      })\n    })\n  }\n  \n  runtimeStatus = (headers?: object): Promise<RuntimeStatusReturn> => {\n    return this.fetch(\n      this.url('RuntimeStatus'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <RuntimeStatus>(_data.status)\n        }\n      })\n    })\n  }\n  \n  getTokenMetadata = (args: GetTokenMetadataArgs, headers?: object): Promise<GetTokenMetadataReturn> => {\n    return this.fetch(\n      this.url('GetTokenMetadata'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          tokenMetadata: <Array<TokenMetadata>>(_data.tokenMetadata)\n        }\n      })\n    })\n  }\n  \n  refreshTokenMetadata = (args: RefreshTokenMetadataArgs, headers?: object): Promise<RefreshTokenMetadataReturn> => {\n    return this.fetch(\n      this.url('RefreshTokenMetadata'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <{[key: string]: boolean}>(_data.status)\n        }\n      })\n    })\n  }\n  \n  getTokenMetadataBatch = (args: GetTokenMetadataBatchArgs, headers?: object): Promise<GetTokenMetadataBatchReturn> => {\n    return this.fetch(\n      this.url('GetTokenMetadataBatch'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          contractTokenMetadata: <{[key: string]: Array<TokenMetadata>}>(_data.contractTokenMetadata)\n        }\n      })\n    })\n  }\n  \n  searchTokenMetadata = (args: SearchTokenMetadataArgs, headers?: object): Promise<SearchTokenMetadataReturn> => {\n    return this.fetch(\n      this.url('SearchTokenMetadata'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          tokenMetadata: <Array<TokenMetadata>>(_data.tokenMetadata)\n        }\n      })\n    })\n  }\n  \n  searchTokenIDs = (args: SearchTokenIDsArgs, headers?: object): Promise<SearchTokenIDsReturn> => {\n    return this.fetch(\n      this.url('SearchTokenIDs'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          tokenIds: <Array<string>>(_data.tokenIds)\n        }\n      })\n    })\n  }\n  \n  tokenCollectionFilters = (args: TokenCollectionFiltersArgs, headers?: object): Promise<TokenCollectionFiltersReturn> => {\n    return this.fetch(\n      this.url('TokenCollectionFilters'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          filters: <Array<PropertyFilter>>(_data.filters)\n        }\n      })\n    })\n  }\n  \n  getContractInfo = (args: GetContractInfoArgs, headers?: object): Promise<GetContractInfoReturn> => {\n    return this.fetch(\n      this.url('GetContractInfo'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          contractInfo: <ContractInfo>(_data.contractInfo)\n        }\n      })\n    })\n  }\n  \n  getContractInfoBatch = (args: GetContractInfoBatchArgs, headers?: object): Promise<GetContractInfoBatchReturn> => {\n    return this.fetch(\n      this.url('GetContractInfoBatch'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          contractInfoMap: <{[key: string]: ContractInfo}>(_data.contractInfoMap)\n        }\n      })\n    })\n  }\n  \n  searchContractInfo = (args: SearchContractInfoArgs, headers?: object): Promise<SearchContractInfoReturn> => {\n    return this.fetch(\n      this.url('SearchContractInfo'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          contractInfoList: <Array<ContractInfo>>(_data.contractInfoList)\n        }\n      })\n    })\n  }\n  \n  searchContractInfoBatch = (args: SearchContractInfoBatchArgs, headers?: object): Promise<SearchContractInfoBatchReturn> => {\n    return this.fetch(\n      this.url('SearchContractInfoBatch'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          contractInfoByChain: <{[key: string]: Array<ContractInfo>}>(_data.contractInfoByChain)\n        }\n      })\n    })\n  }\n  \n  searchMetadata = (args: SearchMetadataArgs, headers?: object): Promise<SearchMetadataReturn> => {\n    return this.fetch(\n      this.url('SearchMetadata'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          tokenMetadata: <Array<TokenMetadata>>(_data.tokenMetadata), \n          contractInfo: <Array<ContractInfo>>(_data.contractInfo)\n        }\n      })\n    })\n  }\n  \n  getNiftyswapTokenQuantity = (args: GetNiftyswapTokenQuantityArgs, headers?: object): Promise<GetNiftyswapTokenQuantityReturn> => {\n    return this.fetch(\n      this.url('GetNiftyswapTokenQuantity'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          quantity: <{[key: string]: string}>(_data.quantity)\n        }\n      })\n    })\n  }\n  \n  getNiftyswapUnitPrices = (args: GetNiftyswapUnitPricesArgs, headers?: object): Promise<GetNiftyswapUnitPricesReturn> => {\n    return this.fetch(\n      this.url('GetNiftyswapUnitPrices'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          prices: <{[key: string]: string}>(_data.prices)\n        }\n      })\n    })\n  }\n  \n  getNiftyswapUnitPricesWithQuantities = (args: GetNiftyswapUnitPricesWithQuantitiesArgs, headers?: object): Promise<GetNiftyswapUnitPricesWithQuantitiesReturn> => {\n    return this.fetch(\n      this.url('GetNiftyswapUnitPricesWithQuantities'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          prices: <{[key: string]: GetNiftyswapUnitPricesResponse}>(_data.prices)\n        }\n      })\n    })\n  }\n  \n}\n\n  \nexport interface WebRPCError extends Error {\n  code: string\n  msg: string\n\tstatus: number\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {})\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch(err) {\n      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError\n    }\n    if (!res.ok) {\n      throw data // webrpc error response\n    }\n    return data\n  })\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n","export * from './metadata.gen'\n\nimport { Metadata as MetadataRpc } from './metadata.gen'\n\nconst fetch = typeof global === 'object' ? global.fetch : window.fetch\n\nexport class SequenceMetadataClient extends MetadataRpc {\n  constructor(hostname: string = 'https://metadata.sequence.app') {\n    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch)\n  }\n}\n","import { BytesLike, Signer as AbstractSigner, providers, TypedDataDomain, TypedDataField } from 'ethers'\nimport { NetworkConfig, ChainIdLike, WalletContext } from '@0xsequence/network'\nimport { FeeQuote, Relayer } from '@0xsequence/relayer'\nimport {\n  SignedTransactions,\n  Transactionish,\n  TransactionRequest,\n  Transaction,\n  TransactionResponse\n} from '@0xsequence/transactions'\nimport { Deferrable } from '@0xsequence/utils'\nimport { WalletConfig, WalletState } from '@0xsequence/config'\n\nexport abstract class Signer extends AbstractSigner {\n  static isSequenceSigner(cand: any): cand is Signer {\n    return isSequenceSigner(cand)\n  }\n\n  abstract getProvider(chainId?: number): Promise<providers.JsonRpcProvider | undefined>\n  abstract getRelayer(chainId?: number): Promise<Relayer | undefined>\n\n  abstract getWalletContext(): Promise<WalletContext>\n  abstract getWalletConfig(chainId?: ChainIdLike): Promise<WalletConfig[]>\n  abstract getWalletState(chainId?: ChainIdLike): Promise<WalletState[]>\n\n  abstract getNetworks(): Promise<NetworkConfig[]>\n\n  // getSigners returns a list of available / attached signers to the interface. Note: you need\n  // enough signers in order to meet the signing threshold that satisfies a wallet config.\n  abstract getSigners(): Promise<string[]>\n\n  // signMessage .....\n  abstract signMessage(message: BytesLike, chainId?: ChainIdLike, allSigners?: boolean, isDigest?: boolean): Promise<string>\n\n  // signTypedData ..\n  abstract signTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    message: Record<string, any>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<string>\n\n  // sendTransaction takes an unsigned transaction, or list of unsigned transactions, and then has it signed by\n  // the signer, and finally sends it to the relayer for submission to an Ethereum network.\n  abstract sendTransaction(\n    transaction: Deferrable<Transactionish>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean,\n    quote?: FeeQuote\n  ): Promise<TransactionResponse>\n\n  // sendTransactionBatch provides the ability to send an array/batch of transactions as a single native on-chain transaction.\n  // This method works identically to sendTransaction but offers a different syntax for convience, readability and type clarity.\n  abstract sendTransactionBatch(\n    transactions: Deferrable<TransactionRequest[] | Transaction[]>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean,\n    quote?: FeeQuote\n  ): Promise<TransactionResponse>\n\n  // Low-level methods to sign and send/relayer signed transactions separately. The combination of these methods\n  // is like calling just sendTransaction(..) above. Also note that sendSignedTransactions is identical\n  // to calling getRelayer().relay(signedTxs), but included in this interface for convenience.\n  abstract signTransactions(\n    txs: Deferrable<Transactionish>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<SignedTransactions>\n  abstract sendSignedTransactions(signedTxs: SignedTransactions, chainId?: ChainIdLike, quote?: FeeQuote): Promise<TransactionResponse>\n\n  // updateConfig will update the wallet image hash on-chain, aka deploying a smart wallet config to chain. If\n  // newConfig argument is undefined, then it will use the existing config. Config contents will also be\n  // automatically published to the authChain when updating the config image hash.\n  abstract updateConfig(newConfig?: WalletConfig): Promise<[WalletConfig, TransactionResponse | undefined]>\n\n  // publishConfig will store the raw WalletConfig object on-chain, note: this may be expensive,\n  // and is only necessary for config data-availability, in case of Account the contents are published\n  // to the authChain.\n  abstract publishConfig(): Promise<TransactionResponse | undefined>\n\n  // isDeployed ..\n  abstract isDeployed(chainId?: ChainIdLike): Promise<boolean>\n}\n\nexport type SignedTransactionsCallback = (signedTxs: SignedTransactions, metaTxnHash: string) => void\n\nexport function isSequenceSigner(signer: AbstractSigner): signer is Signer {\n  const cand = signer as Signer\n  return (\n    cand &&\n    cand.updateConfig !== undefined &&\n    cand.publishConfig !== undefined &&\n    cand.getWalletContext !== undefined &&\n    cand.getWalletConfig !== undefined\n  )\n}\n\n// TODO: move to error.ts, along with others..\nexport class InvalidSigner extends Error {}\n\nexport class NotEnoughSigners extends Error {}\n","import { ethers, Signer, BigNumberish, utils } from 'ethers'\nimport { walletContracts } from '@0xsequence/abi'\nimport { WalletContext } from '@0xsequence/network'\nimport { Transaction, TransactionRequest, Transactionish, TransactionEncoded, NonceDependency, SignedTransactions } from './types'\nimport { subDigestOf } from '@0xsequence/utils'\n\nexport const MetaTransactionsType = `tuple(\n  bool delegateCall,\n  bool revertOnError,\n  uint256 gasLimit,\n  address target,\n  uint256 value,\n  bytes data\n)[]`\n\nexport function packMetaTransactionsData(...txs: Transaction[]): string {\n  const nonce = readSequenceNonce(...txs)\n  if (nonce === undefined) throw new Error('Encoding transactions without defined nonce')\n  return packMetaTransactionsNonceData(nonce, ...txs)\n}\n\nexport function packMetaTransactionsNonceData(nonce: BigNumberish, ...txs: Transaction[]): string {\n  return ethers.utils.defaultAbiCoder.encode(['uint256', MetaTransactionsType], [nonce, sequenceTxAbiEncode(txs)])\n}\n\nexport function digestOfTransactions(...txs: Transaction[]): string {\n  const nonce = readSequenceNonce(...txs)\n  if (nonce === undefined) throw new Error('Computing hash for transactions without defined nonce')\n  return digestOfTransactionsNonce(nonce, ...txs)\n}\n\nexport function digestOfTransactionsNonce(nonce: BigNumberish, ...txs: Transaction[]) {\n  return ethers.utils.keccak256(packMetaTransactionsNonceData(nonce, ...txs))\n}\n\nexport function computeMetaTxnHash(address: string, chainId: BigNumberish, ...txs: Transaction[]): string {\n  return subDigestOf(address, chainId, digestOfTransactions(...txs)).replace(/^0x/, '')\n}\n\nexport async function toSequenceTransactions(\n  wallet: Signer | string,\n  txs: (Transaction | TransactionRequest)[],\n  revertOnError: boolean = false,\n  gasLimit?: BigNumberish\n): Promise<Transaction[]> {\n  // Bundles all transactions, including the auxiliary ones\n  const allTxs = flattenAuxTransactions(txs)\n\n  // Uses the lowest nonce found on TransactionRequest\n  // if there are no nonces, it leaves an undefined nonce\n  const nonces = (await Promise.all(txs.map(t => t.nonce))).filter(n => n !== undefined).map(n => ethers.BigNumber.from(n))\n  const nonce = nonces.length !== 0 ? nonces.reduce((p, c) => (p.lt(c) ? p : c)) : undefined\n\n  // Maps all transactions into SequenceTransactions\n  return Promise.all(allTxs.map(tx => toSequenceTransaction(wallet, tx, revertOnError, gasLimit, nonce)))\n}\n\nexport function flattenAuxTransactions(txs: Transactionish | Transactionish[]): (TransactionRequest | Transaction)[] {\n  if (!Array.isArray(txs)) {\n    if ('auxiliary' in txs) {\n      const aux = txs.auxiliary\n\n      const tx = { ...txs }\n      delete tx.auxiliary\n\n      if (aux) {\n        return [tx, ...flattenAuxTransactions(aux)]\n      } else {\n        return [tx]\n      }\n    } else {\n      return [txs]\n    }\n  }\n\n  return txs.flatMap(flattenAuxTransactions)\n}\n\nexport async function toSequenceTransaction(\n  wallet: Signer | string,\n  tx: TransactionRequest | Transaction,\n  revertOnError: boolean = false,\n  gasLimit?: BigNumberish,\n  nonce?: BigNumberish\n): Promise<Transaction> {\n  if (isSequenceTransaction(tx)) {\n    return tx as Transaction\n  }\n\n  const txGas = tx.gasLimit === undefined ? (<any>tx).gas : tx.gasLimit\n\n  if (tx.to) {\n    return {\n      delegateCall: false,\n      revertOnError: revertOnError,\n      gasLimit: txGas ? await txGas : gasLimit,\n      to: await tx.to,\n      value: tx.value ? await tx.value : 0,\n      data: (await tx.data)!,\n      nonce: nonce ? nonce : await tx.nonce\n    }\n  } else {\n    const walletInterface = new utils.Interface(walletContracts.mainModule.abi)\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('createContract'), [tx.data])\n    const address = typeof wallet === 'string' ? wallet : wallet.getAddress()\n\n    return {\n      delegateCall: false,\n      revertOnError: revertOnError,\n      gasLimit: txGas ? await txGas : gasLimit,\n      to: await address,\n      value: tx.value ? await tx.value : 0,\n      data: data,\n      nonce: nonce ? nonce : await tx.nonce\n    }\n  }\n}\n\nexport function isAsyncSendable(target: any) {\n  return target.send || target.sendAsync\n}\n\nexport function isSequenceTransaction(tx: any): tx is Transaction {\n  return tx.delegateCall !== undefined || tx.revertOnError !== undefined\n}\n\nexport function hasSequenceTransactions(txs: any[]) {\n  return txs.find(t => isSequenceTransaction(t)) !== undefined\n}\n\nexport function readSequenceNonce(...txs: Transaction[]): BigNumberish | undefined {\n  const sample = txs.find(t => t.nonce !== undefined)\n  if (!sample) {\n    return undefined\n  }\n  const sampleNonce = ethers.BigNumber.from(sample.nonce)\n\n  if (txs.find(t => t.nonce !== undefined && !ethers.BigNumber.from(t.nonce).eq(sampleNonce))) {\n    throw new Error('Mixed nonces on Sequence transactions')\n  }\n\n  return sample ? sample.nonce : undefined\n}\n\nexport function sequenceTxAbiEncode(txs: Transaction[]): TransactionEncoded[] {\n  return txs.map(t => ({\n    delegateCall: t.delegateCall === true,\n    revertOnError: t.revertOnError === true,\n    gasLimit: t.gasLimit !== undefined ? t.gasLimit : ethers.constants.Zero,\n    target: t.to ?? ethers.constants.AddressZero,\n    value: t.value !== undefined ? t.value : ethers.constants.Zero,\n    data: t.data !== undefined ? t.data : []\n  }))\n}\n\nexport function appendNonce(txs: Transaction[], nonce: BigNumberish): Transaction[] {\n  return txs.map((t: Transaction) => ({ ...t, nonce }))\n}\n\nexport function makeExpirable(context: WalletContext, txs: Transaction[], expiration: BigNumberish): Transaction[] {\n  const sequenceUtils = new utils.Interface(walletContracts.sequenceUtils.abi)\n\n  if (!context || !context.sequenceUtils) {\n    throw new Error('Undefined sequenceUtils')\n  }\n\n  return [\n    {\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: 0,\n      to: context.sequenceUtils,\n      value: 0,\n      data: sequenceUtils.encodeFunctionData(sequenceUtils.getFunction('requireNonExpired'), [expiration])\n    },\n    ...txs\n  ]\n}\n\nexport function makeAfterNonce(context: WalletContext, txs: Transaction[], dep: NonceDependency): Transaction[] {\n  const sequenceUtils = new utils.Interface(walletContracts.sequenceUtils.abi)\n\n  if (!context || !context.sequenceUtils) {\n    throw new Error('Undefined sequenceUtils')\n  }\n\n  return [\n    {\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: 0,\n      to: context.sequenceUtils,\n      value: 0,\n      data: sequenceUtils.encodeFunctionData(sequenceUtils.getFunction('requireMinNonce'), [\n        dep.address,\n        dep.space ? encodeNonce(dep.space, dep.nonce) : dep.nonce\n      ])\n    },\n    ...txs\n  ]\n}\n\nexport function encodeNonce(space: BigNumberish, nonce: BigNumberish): BigNumberish {\n  const bspace = ethers.BigNumber.from(space)\n  const bnonce = ethers.BigNumber.from(nonce)\n\n  const shl = ethers.constants.Two.pow(ethers.BigNumber.from(96))\n\n  if (!bnonce.div(shl).eq(ethers.constants.Zero)) {\n    throw new Error('Space already encoded')\n  }\n\n  return bnonce.add(bspace.mul(shl))\n}\n\nexport function decodeNonce(nonce: BigNumberish): [BigNumberish, BigNumberish] {\n  const bnonce = ethers.BigNumber.from(nonce)\n  const shr = ethers.constants.Two.pow(ethers.BigNumber.from(96))\n\n  return [bnonce.div(shr), bnonce.mod(shr)]\n}\n\nexport function isSignedTransactions(cand: any): cand is SignedTransactions {\n  return (\n    cand !== undefined &&\n    cand.chainId !== undefined &&\n    cand.config !== undefined &&\n    cand.context !== undefined &&\n    cand.signature !== undefined &&\n    cand.transactions !== undefined &&\n    Array.isArray(cand.transactions) &&\n    (<SignedTransactions>cand).transactions.reduce((p, c) => p && isSequenceTransaction(c), true)\n  )\n}\n\nexport async function fromTransactionish(\n  context: WalletContext,\n  wallet: string,\n  transaction: Transactionish\n): Promise<Transaction[]> {\n  let stx: Transaction[] = []\n\n  if (Array.isArray(transaction)) {\n    if (hasSequenceTransactions(transaction)) {\n      stx = flattenAuxTransactions(transaction) as Transaction[]\n    } else {\n      stx = await toSequenceTransactions(wallet, transaction)\n    }\n  } else if (isSequenceTransaction(transaction)) {\n    stx = flattenAuxTransactions([transaction]) as Transaction[]\n  } else {\n    stx = await toSequenceTransactions(wallet, [transaction])\n  }\n\n  // If transaction is marked as expirable\n  // append expirable require\n  if ((<TransactionRequest>transaction).expiration) {\n    stx = makeExpirable(context, stx, (<TransactionRequest>transaction).expiration!)\n  }\n\n  // If transaction depends on another nonce\n  // append after nonce requirement\n  if ((<TransactionRequest>transaction).afterNonce) {\n    const after = (<TransactionRequest>transaction).afterNonce\n    stx = makeAfterNonce(\n      context,\n      stx,\n      (<NonceDependency>after).address\n        ? {\n            address: (<NonceDependency>after).address,\n            nonce: (<NonceDependency>after).nonce,\n            space: (<NonceDependency>after).space\n          }\n        : {\n            address: wallet,\n            nonce: <BigNumberish>after\n          }\n    )\n  }\n\n  return stx\n}\n","import { BytesLike, Signer as AbstractSigner, providers, utils } from 'ethers'\nimport { ChainIdLike } from '@0xsequence/network'\n\ntype Provider = providers.Provider\ntype TransactionRequest = providers.TransactionRequest\ntype TransactionResponse = providers.TransactionResponse\ntype Deferrable<T> = utils.Deferrable<T>\n\nexport abstract class RemoteSigner extends AbstractSigner {\n  abstract signMessageWithData(message: BytesLike, data?: BytesLike, chainId?: ChainIdLike): Promise<string>\n\n  signMessage(message: BytesLike, chainId?: number): Promise<string> {\n    return this.signMessageWithData(message)\n  }\n\n  sendTransaction(_: TransactionRequest): Promise<TransactionResponse> {\n    throw new Error('sendTransaction method is not supported in RemoteSigner')\n  }\n\n  signTransaction(_: Deferrable<TransactionRequest>): Promise<string> {\n    throw new Error('signTransaction method is not supported in RemoteSigner')\n  }\n\n  connect(_: Provider): AbstractSigner {\n    throw new Error('connect method is not supported in RemoteSigner')\n  }\n\n  static signMessageWithData(signer: AbstractSigner, message: BytesLike, data?: BytesLike, chainId?: number): Promise<string> {\n    if (this.isRemoteSigner(signer)) {\n      return (signer as RemoteSigner).signMessageWithData(message, data, chainId)\n    }\n    return signer.signMessage(message)\n  }\n\n  static isRemoteSigner(signer: AbstractSigner): signer is RemoteSigner {\n    return (<RemoteSigner>signer).signMessageWithData !== undefined\n  }\n}\n","/* eslint-disable */\n// sequence-guard v0.4.0 98e0726794b2b5922a0e356280daac3a409602e4\n// --\n// Code generated by webrpc-gen@v0.10.x-dev with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=guard.ridl -target=typescript -client -out=./clients/guard.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = \"v1\"\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = \"v0.4.0\"\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = \"98e0726794b2b5922a0e356280daac3a409602e4\"\n\n//\n// Types\n//\n\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n}\n\nexport interface SequenceContext {\n  factory: string\n  mainModule: string\n  mainModuleUpgradable: string\n  guestModule: string\n  utils: string\n}\n\nexport interface WalletConfig {\n  address: string\n  signers: Array<WalletSigner>\n  threshold: number\n}\n\nexport interface WalletSigner {\n  address: string\n  weight: number\n}\n\nexport interface SignRequest {\n  chainId: number\n  msg: string\n  auxData: string\n}\n\nexport interface Guard {\n  ping(headers?: object): Promise<PingReturn>\n  version(headers?: object): Promise<VersionReturn>\n  runtimeStatus(headers?: object): Promise<RuntimeStatusReturn>\n  getSequenceContext(headers?: object): Promise<GetSequenceContextReturn>\n  getSignerConfig(headers?: object): Promise<GetSignerConfigReturn>\n  sign(args: SignArgs, headers?: object): Promise<SignReturn>\n}\n\nexport interface PingArgs {\n}\n\nexport interface PingReturn {\n  status: boolean  \n}\nexport interface VersionArgs {\n}\n\nexport interface VersionReturn {\n  version: Version  \n}\nexport interface RuntimeStatusArgs {\n}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus  \n}\nexport interface GetSequenceContextArgs {\n}\n\nexport interface GetSequenceContextReturn {\n  data: SequenceContext  \n}\nexport interface GetSignerConfigArgs {\n}\n\nexport interface GetSignerConfigReturn {\n  signerConfig: WalletConfig  \n}\nexport interface SignArgs {\n  request: SignRequest\n}\n\nexport interface SignReturn {\n  sig: string  \n}\n\n\n  \n//\n// Client\n//\nexport class Guard implements Guard {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Guard/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n  \n  ping = (headers?: object): Promise<PingReturn> => {\n    return this.fetch(\n      this.url('Ping'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status)\n        }\n      })\n    })\n  }\n  \n  version = (headers?: object): Promise<VersionReturn> => {\n    return this.fetch(\n      this.url('Version'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          version: <Version>(_data.version)\n        }\n      })\n    })\n  }\n  \n  runtimeStatus = (headers?: object): Promise<RuntimeStatusReturn> => {\n    return this.fetch(\n      this.url('RuntimeStatus'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <RuntimeStatus>(_data.status)\n        }\n      })\n    })\n  }\n  \n  getSequenceContext = (headers?: object): Promise<GetSequenceContextReturn> => {\n    return this.fetch(\n      this.url('GetSequenceContext'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          data: <SequenceContext>(_data.data)\n        }\n      })\n    })\n  }\n  \n  getSignerConfig = (headers?: object): Promise<GetSignerConfigReturn> => {\n    return this.fetch(\n      this.url('GetSignerConfig'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          signerConfig: <WalletConfig>(_data.signerConfig)\n        }\n      })\n    })\n  }\n  \n  sign = (args: SignArgs, headers?: object): Promise<SignReturn> => {\n    return this.fetch(\n      this.url('Sign'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          sig: <string>(_data.sig)\n        }\n      })\n    })\n  }\n  \n}\n\n  \nexport interface WebRPCError extends Error {\n  code: string\n  msg: string\n\tstatus: number\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {})\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch(err) {\n      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError\n    }\n    if (!res.ok) {\n      throw data // webrpc error response\n    }\n    return data\n  })\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n","import { ethers, utils } from 'ethers'\n\nexport async function resolveArrayProperties<T>(object: Readonly<utils.Deferrable<T>> | Readonly<utils.Deferrable<T>>[]): Promise<T> {\n  if (Array.isArray(object)) {\n    // T must include array type\n    return Promise.all(object.map((o) => utils.resolveProperties(o))) as any\n  }\n\n  return utils.resolveProperties(object)\n}\n\nexport async function findLatestLog(provider: ethers.providers.Provider, filter: ethers.providers.Filter): Promise<ethers.providers.Log | undefined> {\n  const toBlock = filter.toBlock === 'latest' ? await provider.getBlockNumber() : filter.toBlock as number\n  const fromBlock = filter.fromBlock as number\n\n  try {\n    const logs = await provider.getLogs({ ...filter, toBlock: toBlock })\n    return logs.length === 0 ? undefined : logs[logs.length - 1]\n  } catch (e) {\n    // TODO Don't assume all errors are bad\n    const pivot = Math.floor(((toBlock - fromBlock) / 2) + fromBlock)\n    const nhalf = await findLatestLog(provider, { ...filter, fromBlock: pivot, toBlock: toBlock })\n    if (nhalf !== undefined) return nhalf\n    return findLatestLog(provider, { ...filter, fromBlock: fromBlock, toBlock: pivot })\n  }\n}\n","import {\n  BytesLike,\n  BigNumber, BigNumberish,\n  ethers,\n  Signer as AbstractSigner,\n  providers,\n  utils,\n  TypedDataDomain, TypedDataField,\n} from 'ethers'\n\nimport { walletContracts } from '@0xsequence/abi'\n\nimport {\n  Transaction,\n  Transactionish,\n  TransactionRequest,\n  readSequenceNonce,\n  appendNonce,\n  sequenceTxAbiEncode,\n  SignedTransactions,\n  computeMetaTxnHash,\n  digestOfTransactionsNonce,\n  decodeNonce,\n  fromTransactionish,\n  TransactionResponse\n} from '@0xsequence/transactions'\n\nimport { FeeQuote, Relayer } from '@0xsequence/relayer'\n\nimport {\n  ChainIdLike,\n  WalletContext,\n  JsonRpcSender,\n  NetworkConfig,\n  isJsonRpcProvider,\n  sequenceContext,\n  getChainId,\n  JsonRpcProvider\n} from '@0xsequence/network'\n\nimport {\n  WalletConfig,\n  WalletState,\n  addressOf,\n  sortConfig,\n  compareAddr,\n  imageHash,\n  isUsableConfig,\n  DecodedSignature,\n  encodeSignature,\n  joinSignatures,\n  recoverEOASigner,\n  decodeSignature,\n  isDecodedSigner,\n  isDecodedFullSigner\n} from '@0xsequence/config'\n\nimport { encodeTypedDataDigest, subDigestOf } from '@0xsequence/utils'\n\nimport { RemoteSigner } from './remote-signers'\n\nimport { resolveArrayProperties } from './utils'\n\nimport { isSequenceSigner, Signer, SignedTransactionsCallback } from './signer'\nimport { fetchImageHash } from '.'\n\ntype BlockTag = providers.BlockTag\ntype ConnectionInfo = utils.ConnectionInfo\ntype Deferrable<T> = utils.Deferrable<T>\n\n// Wallet is a signer interface to a Smart Contract based Ethereum account.\n//\n// Wallet allows managing the account/wallet sub-keys, wallet address, signing\n// messages, signing transactions and updating/deploying the wallet config on a specific chain.\n//\n// Wallet instances represent a wallet at a particular config-state, in someways, the Wallet\n// instance is immutable, and if you update the config, then you'll need to call useConfig()\n// to instantiate a new Wallet instance with the updated config.\n\nexport interface WalletOptions {\n  // config is the wallet multi-sig configuration. Note: the first config of any wallet\n  // before it is deployed is used to derive it's the account address of the wallet.\n  config: WalletConfig\n\n  // context is the WalletContext of deployed wallet-contract modules for the Smart Wallet\n  context?: WalletContext\n\n  // strict mode will ensure the WalletConfig is usable otherwise throw (on by default)\n  strict?: boolean\n}\n\nexport class Wallet extends Signer {\n  readonly context: WalletContext\n  readonly config: WalletConfig\n\n  private readonly _signers: AbstractSigner[]\n\n  // provider is an Ethereum Json RPC provider that is connected to a particular network (aka chain)\n  // and access to the signer for signing transactions.\n  provider: providers.JsonRpcProvider\n\n  // sender is a minimal Json RPC sender interface. It's here for convenience for other web3\n  // interfaces to use.\n  sender: JsonRpcSender\n\n  // relayer dispatches transactions to an Ethereum node directly\n  // or through a remote transaction Web Service.\n  relayer: Relayer\n\n  // chainId is the node network id, used for memoization\n  chainId?: number\n\n  constructor(options: WalletOptions, ...signers: (BytesLike | AbstractSigner)[]) {\n    super()\n\n    const { config, context, strict } = options\n\n    if (context) {\n      this.context = { ...context }\n    } else {\n      // default context is to use @0xsequence/network deployed context\n      this.context = { ...sequenceContext }\n    }\n\n    if (strict === true) {\n      this.context.nonStrict = undefined\n    } else if (strict === false) {\n      this.context.nonStrict = true\n    }\n    if (!this.context.nonStrict && !isUsableConfig(config)) {\n      throw new Error('wallet config is not usable (strict mode)')\n    }\n\n    this.config = sortConfig(config)\n    this._signers = signers.map(s => (AbstractSigner.isSigner(s) ? s : new ethers.Wallet(s)))\n\n    // cache wallet config for future imageHash lookups\n    this.imageHash\n  }\n\n  // useConfig creates a new Wallet instance with the provided config, and uses the current provider\n  // and relayer. It's common to initialize a counter-factual / undeployed wallet by initializing\n  // it with the Wallet's init config, then calling useConfig() with the most-up-to-date config,\n  // ie. new Wallet({ config: initConfig }).useConfig(latestConfig).useSigners(signers)\n  useConfig(config: WalletConfig, strict?: boolean): Wallet {\n    return new Wallet({ config, context: this.context, strict }, ...this._signers)\n      .setProvider(this.provider, this.chainId)\n      .setRelayer(this.relayer)\n  }\n\n  useSigners(...signers: (BytesLike | AbstractSigner)[]): Wallet {\n    return new Wallet({ config: this.config, context: this.context }, ...signers)\n      .setProvider(this.provider, this.chainId)\n      .setRelayer(this.relayer)\n  }\n\n  // connect is a short-hand to create an Account instance and set the provider and relayer.\n  //\n  // The connect method is defined on the AbstractSigner as connect(Provider): AbstractSigner\n  connect(provider: providers.Provider, relayer?: Relayer): Wallet {\n    if (isJsonRpcProvider(provider)) {\n      return new Wallet({ config: this.config, context: this.context }, ...this._signers)\n        .setProvider(provider, this.chainId)\n        .setRelayer(relayer!)\n    } else {\n      throw new Error('Wallet provider argument is expected to be a JsonRpcProvider')\n    }\n  }\n\n  // setProvider assigns a json-rpc provider to this wallet instance\n  setProvider(provider: providers.JsonRpcProvider | ConnectionInfo | string, chainId?: number): Wallet {\n    if (provider === undefined) return this\n    if (providers.Provider.isProvider(provider)) {\n      this.provider = provider\n      this.sender = new JsonRpcSender(provider)\n    } else {\n      const jsonProvider = new JsonRpcProvider(<ConnectionInfo | string>provider, { chainId, blockCache: true })\n      this.provider = jsonProvider\n      this.sender = new JsonRpcSender(jsonProvider)\n    }\n    this.chainId = chainId // reset chainId value\n    return this\n  }\n\n  // setRelayer assigns a Sequence transaction relayer to this wallet instance\n  setRelayer(relayer: Relayer): Wallet {\n    if (relayer === undefined) return this\n    this.relayer = relayer\n    return this\n  }\n\n  async getProvider(chainId?: number): Promise<providers.JsonRpcProvider> {\n    if (chainId) await this.getChainIdNumber(chainId)\n    return this.provider\n  }\n\n  async getRelayer(chainId?: number): Promise<Relayer> {\n    if (chainId) await this.getChainIdNumber(chainId)\n    return this.relayer\n  }\n\n  async getWalletContext(): Promise<WalletContext> {\n    return this.context\n  }\n\n  async getWalletConfig(chainId?: ChainIdLike): Promise<WalletConfig[]> {\n    chainId = await this.getChainIdNumber(chainId)\n    const config = {\n      ...this.config,\n      chainId\n    }\n    return [config]\n  }\n\n  async getWalletState(_?: ChainIdLike): Promise<WalletState[]> {\n    const [address, chainId, isDeployed] = await Promise.all([this.getAddress(), this.getChainId(), this.isDeployed()])\n\n    const state: WalletState = {\n      context: this.context,\n      config: this.config,\n      address: address,\n      chainId: chainId,\n      deployed: isDeployed,\n      imageHash: this.imageHash,\n      lastImageHash: isDeployed ? await fetchImageHash(this) : undefined\n    }\n\n    // TODO: set published boolean by checking if we have the latest logs\n    // that compute to the same hash as in lastImageHash\n\n    return [state]\n  }\n\n  // connected reports if json-rpc provider has been connected\n  get connected(): boolean {\n    return this.sender !== undefined\n  }\n\n  // address returns the address of the wallet account address\n  get address(): string {\n    return addressOf(this.config, this.context)\n  }\n\n  // imageHash is the unique hash of the WalletConfig\n  get imageHash(): string {\n    return imageHash(this.config)\n  }\n\n  // getAddress returns the address of the wallet account address\n  //\n  // The getAddress method is defined on the AbstractSigner\n  async getAddress(): Promise<string> {\n    return this.address\n  }\n\n  // getSigners returns the list of public account addresses to the currently connected\n  // signer objects for this wallet. Note: for a complete list of configured signers\n  // on the wallet, query getWalletConfig()\n  async getSigners(): Promise<string[]> {\n    if (!this._signers || this._signers.length === 0) {\n      return []\n    }\n    return Promise.all(this._signers.map(s => s.getAddress().then(s => ethers.utils.getAddress(s))))\n  }\n\n  // chainId returns the network connected to this wallet instance\n  async getChainId(): Promise<number> {\n    if (this.chainId) return this.chainId\n    if (!this.provider) {\n      throw new Error('provider is not set, first connect a provider')\n    }\n\n    this.chainId = (await this.provider.getNetwork()).chainId\n    return this.chainId\n  }\n\n  async getNetworks(): Promise<NetworkConfig[]> {\n    const chainId = await this.getChainId()\n    return [\n      {\n        chainId: chainId,\n        name: '',\n        rpcUrl: ''\n      }\n    ]\n  }\n\n  // getNonce returns the transaction nonce for this wallet, via the relayer\n  async getNonce(blockTag?: BlockTag, space?: BigNumberish): Promise<BigNumberish> {\n    return this.relayer.getNonce(this.config, this.context, space, blockTag)\n  }\n\n  // getTransactionCount returns the number of transactions (aka nonce)\n  //\n  // getTransactionCount method is defined on the AbstractSigner\n  async getTransactionCount(blockTag?: BlockTag): Promise<number> {\n    const encodedNonce = await this.getNonce(blockTag, 0)\n    const [_, decodedNonce] = decodeNonce(encodedNonce)\n    return ethers.BigNumber.from(decodedNonce).toNumber()\n  }\n\n  // sendTransaction will dispatch the transaction to the relayer for submission to the network.\n  async sendTransaction(\n    transaction: Deferrable<Transactionish>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean,\n    quote?: FeeQuote,\n    callback?: SignedTransactionsCallback,\n    waitForReceipt?: boolean\n  ): Promise<TransactionResponse> {\n    const signedTxs = await this.signTransactions(transaction, chainId, allSigners)\n    if (callback) {\n      const address = addressOf(signedTxs.config, signedTxs.context)\n      const metaTxnHash = computeMetaTxnHash(address, signedTxs.chainId, ...signedTxs.transactions)\n      callback(signedTxs, metaTxnHash)\n    }\n    return this.relayer.relay(signedTxs, quote, waitForReceipt)\n  }\n\n  // sendTransactionBatch is a sugar for better readability, but is the same as sendTransaction\n  async sendTransactionBatch(\n    transactions: Deferrable<TransactionRequest[] | Transaction[]>,\n    chainId?: ChainIdLike,\n    allSigners: boolean = true,\n    quote?: FeeQuote,\n    callback?: SignedTransactionsCallback,\n    waitForReceipt?: boolean\n  ): Promise<TransactionResponse> {\n    return this.sendTransaction(transactions, chainId, allSigners, quote, callback, waitForReceipt)\n  }\n\n  // signTransactions will sign a Sequence transaction with the wallet signers\n  //\n  // NOTE: the txs argument of type Transactionish can accept one or many transactions.\n  async signTransactions(\n    txs: Deferrable<Transactionish>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<SignedTransactions> {\n    const signChainId = await this.getChainIdNumber(chainId)\n\n    const transaction = await resolveArrayProperties<Transactionish>(txs)\n\n    if (!this.provider) {\n      throw new Error('missing provider')\n    }\n    if (!this.relayer) {\n      throw new Error('missing relayer')\n    }\n\n    // Convert Transactionish into Sequence transactions\n    let stx = await fromTransactionish(this.context, this.address, transaction)\n\n    // Fill missing gas limits via simulation if needed\n    if (stx.some(transaction => transaction.gasLimit === undefined)) {\n      const results = await this.relayer.simulate(this.address, ...stx)\n      for (const i in stx) {\n        if (stx[i].gasLimit === undefined) {\n          stx[i].gasLimit = results[i].gasLimit\n        }\n      }\n    }\n\n    // If provided nonce append it to all other transactions\n    // otherwise get next nonce for this wallet\n    const providedNonce = readSequenceNonce(...stx)\n    const nonce = providedNonce ? providedNonce : await this.getNonce()\n    stx = appendNonce(stx, nonce)\n\n    // Get transactions digest\n    const digest = digestOfTransactionsNonce(nonce, ...stx)\n\n    // Bundle with signature\n    return {\n      digest: digest,\n      chainId: signChainId,\n      context: this.context,\n      config: this.config,\n      transactions: stx,\n      nonce,\n      signature: await this.sign(digest, true, chainId, allSigners)\n    }\n  }\n\n  async sendSignedTransactions(signedTxs: SignedTransactions, chainId?: ChainIdLike, quote?: FeeQuote): Promise<TransactionResponse> {\n    if (!this.relayer) {\n      throw new Error('relayer is not set, first connect a relayer')\n    }\n    await this.getChainIdNumber(chainId)\n    return this.relayer.relay(signedTxs, quote)\n  }\n\n  // signMessage will sign a message for a particular chainId with the wallet signers\n  //\n  // NOTE: signMessage(message: Bytes | string): Promise<string> is defined on AbstractSigner\n  async signMessage(message: BytesLike, chainId?: ChainIdLike, allSigners?: boolean, isDigest: boolean = false): Promise<string> {\n    const data = typeof message === 'string' && !message.startsWith('0x') ? ethers.utils.toUtf8Bytes(message) : message\n    return this.sign(data, isDigest, chainId, allSigners)\n  }\n\n  async signTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    message: Record<string, any>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<string> {\n    const signChainId = await this.getChainIdNumber(chainId)\n\n    const domainChainId = domain.chainId ? BigNumber.from(domain.chainId).toNumber() : undefined\n    if (domainChainId && domainChainId !== signChainId) {\n      throw new Error(`signTypedData: domain.chainId (${domain.chainId}) is expected to be ${signChainId}`)\n    }\n\n    const hash = encodeTypedDataDigest({ domain, types, message })\n    return this.sign(hash, true, signChainId, allSigners)\n  }\n\n  async _signTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    message: Record<string, any>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<string> {\n    return this.signTypedData(domain, types, message, chainId, allSigners)\n  }\n\n  async subDigest(digest: BytesLike, chainId?: ChainIdLike): Promise<Uint8Array> {\n    const solvedChainId = await this.getChainIdNumber(chainId)\n    return ethers.utils.arrayify(subDigestOf(this.address, solvedChainId, digest))\n  }\n\n  // sign is a helper method to sign a payload with the wallet signers\n  async sign(msg: BytesLike, isDigest: boolean = true, chainId?: ChainIdLike, allSigners?: boolean): Promise<string> {\n    const signChainId = await this.getChainIdNumber(chainId)\n\n    const digest = isDigest ? msg : ethers.utils.keccak256(msg)\n\n    // Generate sub-digest\n    const subDigest = await this.subDigest(digest, chainId)\n\n    // Sign sub-digest using a set of signers and some optional data\n    const signWith = async (signers: AbstractSigner[], auxData?: string): Promise<DecodedSignature> => {\n      const signersAddr = await Promise.all(signers.map(s => s.getAddress()))\n      const parts = await Promise.all(\n        this.config.signers.map(async s => {\n          try {\n            const signer = signers[signersAddr.indexOf(s.address)]\n\n            // Is not a signer, return config entry as-is\n            if (!signer) {\n              return s\n            }\n\n            // Is another Sequence wallet as signer, sign and append '03' (ERC1271 type)\n            if (isSequenceSigner(signer)) {\n              if (signer === this) throw Error(\"Can't sign transactions for self\")\n              const signature = (await signer.signMessage(subDigest, signChainId, allSigners, true)) + '03'\n\n              return {\n                ...s,\n                signature: signature\n              }\n            }\n\n            // Is remote signer, call and deduce signature type\n            if (RemoteSigner.isRemoteSigner(signer)) {\n              const signature = await signer.signMessageWithData(subDigest, auxData, signChainId)\n\n              try {\n                // Check if signature can be recovered as EOA signature\n                const isEOASignature = recoverEOASigner(subDigest, { weight: s.weight, signature: signature }) === s.address\n\n                if (isEOASignature) {\n                  // Exclude address on EOA signatures\n                  return {\n                    weight: s.weight,\n                    signature: signature\n                  }\n                }\n              } catch {}\n\n              // Prepare signature for full encoding\n              return {\n                ...s,\n                signature: signature\n              }\n            }\n\n            // Is EOA signer\n            return {\n              weight: s.weight,\n              signature: (await signer.signMessage(subDigest)) + '02'\n            }\n          } catch (err) {\n            if (allSigners) {\n              throw err\n            } else {\n              console.warn(`Skipped signer ${s.address}`)\n              return s\n            }\n          }\n        })\n      )\n\n      return {\n        threshold: this.config.threshold,\n        signers: parts\n      }\n    }\n\n    // Sign message first using localSigners\n    const localSigners = this._signers.filter(s => !RemoteSigner.isRemoteSigner(s))\n    const localSignature = await signWith(localSigners, this.packMsgAndSig(digest, [], signChainId))\n\n    // Skip remote signers if we already meet threshold\n    const totalWeight = localSignature.signers.filter(isDecodedSigner).reduce((totalWeight, signer) => totalWeight + signer.weight, 0)\n    if (totalWeight >= this.config.threshold) {\n      return encodeSignature(localSignature)\n    }\n\n    // include local signatures for remote signers\n    const remoteSigners = this._signers.filter(s => RemoteSigner.isRemoteSigner(s))\n    const remoteSignature = await signWith(\n      remoteSigners,\n      this.packMsgAndSig(digest, encodeSignature(localSignature), signChainId)\n    )\n\n    // Aggregate both local and remote signatures\n    return encodeSignature(joinSignatures(localSignature, remoteSignature))\n  }\n\n  // signWeight will return the total weight of all signers available based on the config\n  async signWeight(): Promise<BigNumber> {\n    const signers = await this.getSigners()\n    return signers.reduce((p, s) => {\n      const sconfig = this.config.signers.find(c => c.address === s)\n      if (!sconfig) return p\n      return p.add(sconfig.weight)\n    }, ethers.constants.Zero)\n  }\n\n  async isDeployed(chainId?: ChainIdLike): Promise<boolean> {\n    await this.getChainIdNumber(chainId)\n    const walletCode = await this.provider.getCode(this.address)\n    return !!walletCode && walletCode !== '0x'\n  }\n\n  // updateConfig will build an updated config transaction and send it to the Ethereum\n  // network via the relayer. Note, the updated wallet config is stored as an image hash,\n  // unlike `publishConfig` which will store the entire WalletConfig object in logs.\n  async updateConfig(\n    config?: WalletConfig,\n    nonce?: number,\n    publish = false,\n    indexed?: boolean,\n    quote?: FeeQuote,\n    callback?: SignedTransactionsCallback,\n    waitForReceipt?: boolean\n  ): Promise<[WalletConfig, TransactionResponse]> {\n    if (!config) config = this.config\n\n    const [txs, n] = await Promise.all([this.buildUpdateConfigTransaction(config, publish, indexed), nonce ?? this.getNonce()])\n\n    return [\n      { address: this.address, ...config },\n      await this.sendTransaction(appendNonce(txs, n), undefined, undefined, quote, callback, waitForReceipt)\n    ]\n  }\n\n  // publishConfig will publish the current wallet config to the network via the relayer.\n  // Publishing the config will also store the entire object of signers.\n  async publishConfig(\n    indexed?: boolean,\n    nonce?: number,\n    requireFreshSigners: string[] = [],\n    quote?: FeeQuote,\n    callback?: SignedTransactionsCallback,\n    waitForReceipt?: boolean\n  ): Promise<TransactionResponse> {\n    return this.sendTransaction(\n      this.config.address\n        ? this.buildPublishConfigTransaction(this.config, indexed, nonce)\n        : await this.buildPublishSignersTransaction(indexed, nonce, requireFreshSigners),\n      undefined,\n      undefined,\n      quote,\n      callback,\n      waitForReceipt\n    )\n  }\n\n  // buildUpdateConfigTransaction creates a transaction to update the imageHash of the wallet's config\n  // on chain. Note, the transaction is not sent to the network by this method.\n  //\n  // The `publish` argument when true will also store the contents of the WalletConfig to a chain's logs.\n  async buildUpdateConfigTransaction(config: WalletConfig, publish = false, indexed?: boolean): Promise<Transaction[]> {\n    if (!this.context.nonStrict && !isUsableConfig(config)) throw new Error('wallet config is not usable (strict mode)')\n\n    const isUpgradable = await (async () => {\n      try {\n        const implementation = await this.provider.getStorageAt(\n          this.address,\n          ethers.utils.defaultAbiCoder.encode(['address'], [this.address])\n        )\n        return compareAddr(implementation, this.context.mainModuleUpgradable) === 0\n      } catch {\n        return false\n      }\n    })()\n\n    const walletInterface = new utils.Interface(walletContracts.mainModule.abi)\n\n    // empirically, this seems to work for the tests:\n    // const gasLimit = 100000 + 1800 * config.signers.length\n    //\n    // but we're going to play it safe with this instead:\n    const gasLimit = 2 * (100000 + 1800 * config.signers.length)\n\n    const preTransaction = isUpgradable\n      ? []\n      : [\n          {\n            delegateCall: false,\n            revertOnError: true,\n            gasLimit: ethers.constants.Zero,\n            to: this.address,\n            value: ethers.constants.Zero,\n            data: walletInterface.encodeFunctionData(walletInterface.getFunction('updateImplementation'), [\n              this.context.mainModuleUpgradable\n            ])\n          }\n        ]\n\n    const mainModuleInterface = new utils.Interface(walletContracts.mainModuleUpgradable.abi)\n\n    const transaction = {\n      delegateCall: false,\n      revertOnError: true,\n      gasLimit: ethers.constants.Zero,\n      to: this.address,\n      value: ethers.constants.Zero,\n      data: mainModuleInterface.encodeFunctionData(mainModuleInterface.getFunction('updateImageHash'), [imageHash(config)])\n    }\n\n    const postTransaction = publish ? await this.buildPublishConfigTransaction(config, indexed) : []\n\n    const transactions = [...preTransaction, transaction, ...postTransaction]\n\n    // If update config reguires a single transaction\n    // skip nested selfExecute bundle\n    if (transactions.length === 1) {\n      return transactions\n    }\n\n    return [\n      {\n        delegateCall: false,\n        revertOnError: false,\n        gasLimit: gasLimit,\n        to: this.address,\n        value: ethers.constants.Zero,\n        data: walletInterface.encodeFunctionData(walletInterface.getFunction('selfExecute'), [sequenceTxAbiEncode(transactions)])\n      }\n    ]\n  }\n\n  buildPublishConfigTransaction(config: WalletConfig, indexed: boolean = true, nonce?: number): Transaction[] {\n    const sequenceUtilsInterface = new utils.Interface(walletContracts.sequenceUtils.abi)\n    return [\n      {\n        delegateCall: false,\n        revertOnError: true,\n        gasLimit: ethers.constants.Zero,\n        to: this.context.sequenceUtils!,\n        value: ethers.constants.Zero,\n        nonce: nonce,\n        data: sequenceUtilsInterface.encodeFunctionData(sequenceUtilsInterface.getFunction('publishConfig'), [\n          this.address,\n          config.threshold,\n          sortConfig(config).signers.map(s => ({\n            weight: s.weight,\n            signer: s.address\n          })),\n          indexed\n        ])\n      }\n    ]\n  }\n\n  async buildPublishSignersTransaction(\n    indexed: boolean = true,\n    nonce?: number,\n    requireFreshSigners: string[] = []\n  ): Promise<Transaction[]> {\n    const sequenceUtilsInterface = new utils.Interface(walletContracts.sequenceUtils.abi)\n    const requireFreshSignersInterface = new utils.Interface(walletContracts.requireFreshSigner.abi)\n\n    const message = ethers.utils.randomBytes(32)\n\n    const signature = await this.signMessage(message, this.chainId, false)\n\n    // TODO: This is only required because RequireUtils doesn't support dynamic signatures\n    // remove this filtering of dynamic once a new version of RequireUtils is deployed\n    const decodedSignature = decodeSignature(signature)\n    const filteredSignature = encodeSignature({\n      threshold: decodedSignature.threshold,\n      signers: decodedSignature.signers.map((s, i) => {\n        if (isDecodedFullSigner(s)) {\n          const a = this.config.signers[i]\n          return {\n            weight: a.weight,\n            address: a.address\n          }\n        }\n\n        return s\n      })\n    })\n\n    const contextRequireFreshSigner = this.context.libs?.requireFreshSigner\n    if (requireFreshSigners.length > 0 && contextRequireFreshSigner === undefined) {\n      throw Error('requireFreshSigners missing library')\n    }\n\n    return [\n      ...requireFreshSigners.map(signer => ({\n        delegateCall: false,\n        revertOnError: true,\n        gasLimit: ethers.constants.Zero,\n        to: contextRequireFreshSigner!,\n        value: ethers.constants.Zero,\n        nonce: nonce,\n        data: requireFreshSignersInterface.encodeFunctionData(requireFreshSignersInterface.getFunction('requireFreshSigner'), [\n          signer\n        ])\n      })),\n      {\n        delegateCall: false,\n        revertOnError: true,\n        gasLimit: ethers.constants.Zero,\n        to: this.context.sequenceUtils!,\n        value: ethers.constants.Zero,\n        nonce: nonce,\n        data: sequenceUtilsInterface.encodeFunctionData(sequenceUtilsInterface.getFunction('publishInitialSigners'), [\n          this.address,\n          ethers.utils.keccak256(message),\n          this.config.signers.length,\n          filteredSignature,\n          indexed\n        ])\n      }\n    ]\n  }\n\n  // getChainIdFromArgument will return the chainId of the argument, as well as ensure\n  // we're not providing an invalid chainId that isn't connected to this wallet.\n  private async getChainIdNumber(chainId?: ChainIdLike): Promise<number> {\n    if (!chainId) {\n      // it's valid for chainId argument to be undefined, in which case\n      // we will use the connected value\n      return await this.getChainId()\n    }\n\n    const id = getChainId(chainId)\n\n    if (this.context.nonStrict) {\n      // in non-strict mode, just return the chainId from argument\n      return id\n    }\n\n    const connectedChainId = await this.getChainId()\n    if (connectedChainId !== id) {\n      throw new Error(`the specified chainId ${id} does not match the wallet's connected chainId ${connectedChainId}`)\n    }\n\n    return connectedChainId\n  }\n\n  // packMsgAndSig is used by RemoteSigners to include details as a string blob of data.\n  private packMsgAndSig(msg: BytesLike, sig: BytesLike, chainId: BigNumberish): string {\n    return ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'bytes', 'bytes'], [this.address, chainId, msg, sig])\n  }\n\n  signTransaction(_: Deferrable<TransactionRequest>): Promise<string> {\n    throw new Error('signTransaction method is not supported in Wallet, please use signTransactions(...)')\n  }\n\n  // singleOwner will create a Wallet instance with a single signer (ie. from a single EOA account)\n  static async singleOwner(owner: BytesLike | AbstractSigner, context?: WalletContext): Promise<Wallet> {\n    const signer = AbstractSigner.isSigner(owner) ? owner : new ethers.Wallet(owner)\n    const config = {\n      threshold: 1,\n      signers: [\n        {\n          weight: 1,\n          address: ethers.utils.getAddress(await signer.getAddress())\n        }\n      ]\n    }\n    return new Wallet({ config, context }, signer)\n  }\n\n  async hasEnoughSigners(chainId?: ChainIdLike): Promise<boolean> {\n    if (chainId) await this.getChainIdNumber(chainId)\n    return (await this.signWeight()).gte(this.config.threshold)\n  }\n}\n","import { ethers, providers, utils } from 'ethers'\nimport { walletContracts } from '@0xsequence/abi'\nimport { WalletContext } from '@0xsequence/network'\nimport { WalletConfig, addressOf, imageHash, DecodedSignature, encodeSignature } from '@0xsequence/config'\nimport { SignedTransactions, Transaction, sequenceTxAbiEncode, readSequenceNonce } from '@0xsequence/transactions'\nimport { isBigNumberish, Optionals } from '@0xsequence/utils'\n\n\nexport interface BaseRelayerOptions {\n  bundleCreation?: boolean\n  creationGasLimit?: ethers.BigNumberish\n  provider?: ethers.providers.Provider\n}\n\nexport function isBaseRelayerOptions(obj: any): obj is BaseRelayerOptions {\n  return (\n    (obj.bundleCreation !== undefined && typeof obj.bundleCreation === 'boolean') ||\n    (obj.creationGasLimit !== undefined && isBigNumberish(obj.creationGasLimit)) ||\n    (obj.provider !== undefined && (providers.Provider.isProvider(obj.provider) || typeof obj.provider === 'string'))\n  )\n}\n\nexport const BaseRelayerDefaults: Omit<Required<Optionals<BaseRelayerOptions>>, 'provider'> = {\n  bundleCreation: true,\n  creationGasLimit: ethers.constants.Two.pow(17)\n}\n\nexport class BaseRelayer {\n  readonly provider: providers.Provider | undefined\n  public readonly bundleCreation: boolean\n  public creationGasLimit: ethers.BigNumber\n\n  constructor(options?: BaseRelayerOptions) {\n    const opts = { ...BaseRelayerDefaults, ...options }\n    this.bundleCreation = opts.bundleCreation\n    this.provider = opts.provider\n    this.creationGasLimit = ethers.BigNumber.from(opts.creationGasLimit)\n  }\n\n  async isWalletDeployed(walletAddress: string): Promise<boolean> {\n    if (!this.provider) throw new Error('Bundled creation provider not found')\n    return (await this.provider.getCode(walletAddress)) !== '0x'\n  }\n\n  prepareWalletDeploy(\n    config: WalletConfig,\n    context: WalletContext\n  ): { to: string, data: string} {\n    const factoryInterface = new utils.Interface(walletContracts.factory.abi)\n\n    return {\n      to: context.factory,\n      data: factoryInterface.encodeFunctionData(factoryInterface.getFunction('deploy'),\n        [context.mainModule, imageHash(config)]\n      )\n    }\n  }\n\n  async prependWalletDeploy(\n    signedTransactions: Pick<SignedTransactions, 'config' | 'context' | 'transactions' | 'nonce' | 'signature'>\n  ): Promise<{ to: string, execute: { transactions: Transaction[], nonce: ethers.BigNumber, signature: string } }> {\n    const { config, context, transactions, nonce, signature } = signedTransactions\n    const walletAddress = addressOf(config, context)\n    const walletInterface = new utils.Interface(walletContracts.mainModule.abi)\n\n    const encodedSignature = (async () => {\n      const sig = await signature\n\n      if (typeof sig === 'string') return sig\n      return encodeSignature(sig)\n    })()\n\n    if (this.bundleCreation && !(await this.isWalletDeployed(walletAddress))) {\n      return {\n        to: context.guestModule!,\n        execute: {\n          transactions: [\n            {\n              ...this.prepareWalletDeploy(config, context),\n              delegateCall: false,\n              revertOnError: false,\n              gasLimit: this.creationGasLimit,\n              value: ethers.constants.Zero\n            },\n            {\n              delegateCall: false,\n              revertOnError: true,\n              gasLimit: ethers.constants.Zero,\n              to: walletAddress,\n              value: ethers.constants.Zero,\n              data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), \n                [\n                  sequenceTxAbiEncode(transactions),\n                  nonce,\n                  await encodedSignature\n                ]\n              )\n            }\n          ],\n          nonce: ethers.constants.Zero,\n          signature: '0x'\n        }\n      }\n    } else {\n      return {\n        to: walletAddress,\n        execute: {\n          transactions,\n          nonce: ethers.BigNumber.from(nonce),\n          signature: await encodedSignature\n        }\n      }\n    }\n  }\n\n  async prepareTransactions(\n    config: WalletConfig,\n    context: WalletContext,\n    signature: string | Promise<string> | DecodedSignature | Promise<DecodedSignature>,\n    ...transactions: Transaction[]\n  ): Promise<{ to: string, data: string  }> { //, gasLimit?: ethers.BigNumberish }> {\n    const nonce = readSequenceNonce(...transactions)\n    if (!nonce) {\n      throw new Error('Unable to prepare transactions without a defined nonce')\n    }\n    const { to, execute } = await this.prependWalletDeploy({ config, context, transactions, nonce, signature })\n    const walletInterface = new utils.Interface(walletContracts.mainModule.abi)\n    return {\n      to, data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [\n        sequenceTxAbiEncode(execute.transactions),\n        execute.nonce,\n        execute.signature\n      ])\n    }\n  }\n}\n","import { ethers, providers } from 'ethers'\nimport { walletContracts } from '@0xsequence/abi'\nimport { computeMetaTxnHash, encodeNonce, SignedTransactions, Transaction, TransactionResponse } from '@0xsequence/transactions'\nimport { WalletContext } from '@0xsequence/network'\nimport { WalletConfig, addressOf } from '@0xsequence/config'\nimport { BaseRelayer, BaseRelayerOptions } from './base-relayer'\nimport { FeeOption, FeeQuote, Relayer, SimulateResult } from '.'\nimport { logger, Optionals, Mask } from '@0xsequence/utils'\n\nconst DEFAULT_GAS_LIMIT = ethers.BigNumber.from(800000)\n\nexport interface ProviderRelayerOptions extends BaseRelayerOptions {\n  provider: providers.Provider,\n  waitPollRate?: number,\n  deltaBlocksLog?: number,\n  fromBlockLog?: number\n}\n\nexport const ProviderRelayerDefaults: Required<Optionals<Mask<ProviderRelayerOptions, BaseRelayerOptions>>> = {\n  waitPollRate: 1000,\n  deltaBlocksLog: 12,\n  fromBlockLog: -1024\n}\n\nexport function isProviderRelayerOptions(obj: any): obj is ProviderRelayerOptions {\n  return obj.provider !== undefined && providers.Provider.isProvider(obj.provider)\n}\n\nexport abstract class ProviderRelayer extends BaseRelayer implements Relayer {\n  public provider: providers.Provider\n  public waitPollRate: number\n  public deltaBlocksLog: number\n  public fromBlockLog: number\n\n  constructor(options: ProviderRelayerOptions) {\n    super(options)\n    const opts = { ...ProviderRelayerDefaults, ...options }\n    this.provider = opts.provider\n    this.waitPollRate = opts.waitPollRate\n    this.deltaBlocksLog = opts.deltaBlocksLog\n    this.fromBlockLog = opts.fromBlockLog\n  }\n\n  abstract getFeeOptions(\n    config: WalletConfig,\n    context: WalletContext,\n    ...transactions: Transaction[]\n  ): Promise<{ options: FeeOption[], quote?: FeeQuote }>\n\n  abstract gasRefundOptions(\n    config: WalletConfig,\n    context: WalletContext,\n    ...transactions: Transaction[]\n  ): Promise<FeeOption[]>\n\n  abstract relay(signedTxs: SignedTransactions, quote?: FeeQuote, waitForReceipt?: boolean): Promise<TransactionResponse>\n\n  async simulate(wallet: string, ...transactions: Transaction[]): Promise<SimulateResult[]> {\n    return (await Promise.all(transactions.map(async tx => {\n      // Respect gasLimit request of the transaction (as long as its not 0)\n      if (tx.gasLimit && !ethers.BigNumber.from(tx.gasLimit || 0).eq(ethers.constants.Zero)) {\n        return tx.gasLimit\n      }\n\n      // Fee can't be estimated locally for delegateCalls\n      if (tx.delegateCall) {\n        return DEFAULT_GAS_LIMIT\n      }\n\n      // Fee can't be estimated for self-called if wallet hasn't been deployed\n      if (tx.to === wallet && !(await this.isWalletDeployed(wallet))) {\n        return DEFAULT_GAS_LIMIT\n      }\n\n      if (!this.provider) {\n        throw new Error('signer.provider is not set, but is required')\n      }\n\n      // TODO: If the wallet address has been deployed, gas limits can be\n      // estimated with more accurately by using self-calls with the batch transactions one by one\n      return this.provider.estimateGas({\n        from: wallet,\n        to: tx.to,\n        data: tx.data,\n        value: tx.value\n      })\n    }))).map(gasLimit => ({\n      executed: true,\n      succeeded: true,\n      gasUsed: ethers.BigNumber.from(gasLimit).toNumber(),\n      gasLimit: ethers.BigNumber.from(gasLimit).toNumber()\n    }))\n  }\n\n  async getNonce(\n    config: WalletConfig,\n    context: WalletContext,\n    space?: ethers.BigNumberish,\n    blockTag?: providers.BlockTag\n  ): Promise<ethers.BigNumberish> {\n    if (!this.provider) {\n      throw new Error('provider is not set')\n    }\n\n    const addr = addressOf(config, context)\n\n    if ((await this.provider.getCode(addr)) === '0x') {\n      return 0\n    }\n\n    if (space === undefined) {\n      space = 0\n    }\n\n    const module = new ethers.Contract(addr, walletContracts.mainModule.abi, this.provider)\n    const nonce = await module.readNonce(space, { blockTag: blockTag })\n    return encodeNonce(space, nonce)\n  }\n\n  async wait(\n    metaTxnId: string | SignedTransactions,\n    timeout?: number,\n    delay: number = this.waitPollRate,\n    maxFails: number = 5\n  ): Promise<providers.TransactionResponse & { receipt: providers.TransactionReceipt }> {\n    if (typeof metaTxnId !== 'string') {\n      logger.info('computing id', metaTxnId.config, metaTxnId.context, metaTxnId.chainId, ...metaTxnId.transactions)\n\n      metaTxnId = computeMetaTxnHash(addressOf(metaTxnId.config, metaTxnId.context), metaTxnId.chainId, ...metaTxnId.transactions)\n    }\n\n    let timedOut = false\n\n    const retry = async <T>(f: () => Promise<T>, errorMessage: string): Promise<T> => {\n      let fails = 0\n\n      while (!timedOut) {\n        try {\n          return await f()\n        } catch (error) {\n          fails++\n\n          if (maxFails !== undefined && fails >= maxFails) {\n            logger.error(`giving up after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ''}`, error)\n            throw error\n          } else {\n            logger.warn(`attempt #${fails} failed${errorMessage ? `: ${errorMessage}` : ''}`, error)\n          }\n        }\n\n        if (delay > 0) {\n          await new Promise(resolve => setTimeout(resolve, delay))\n        }\n      }\n\n      throw new Error(`timed out after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ''}`)\n    }\n\n    const waitReceipt = async (): Promise<providers.TransactionResponse & { receipt: providers.TransactionReceipt }> => {\n      // Transactions can only get executed on nonce change\n      // get all nonce changes and look for metaTxnIds in between logs\n      let lastBlock: number = this.fromBlockLog\n\n      if (lastBlock < 0) {\n        const block = await retry(() => this.provider.getBlockNumber(), 'unable to get latest block number')\n        lastBlock = block + lastBlock\n      }\n\n      if (typeof metaTxnId !== 'string') {\n        throw new Error('impossible')\n      }\n\n      const normalMetaTxnId = metaTxnId.replace('0x', '')\n\n      while (!timedOut) {\n        const block = await retry(() => this.provider.getBlockNumber(), 'unable to get latest block number')\n\n        const logs = await retry(\n          () =>\n            this.provider.getLogs({\n              fromBlock: Math.max(0, lastBlock - this.deltaBlocksLog),\n              toBlock: block,\n              // Nonce change event topic\n              topics: ['0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881']\n            }),\n          `unable to get NonceChange logs for blocks ${Math.max(0, lastBlock - this.deltaBlocksLog)} to ${block}`\n        )\n\n        lastBlock = block\n\n        // Get receipts of all transactions\n        const txs = await Promise.all(\n          logs.map(l =>\n            retry(\n              () => this.provider.getTransactionReceipt(l.transactionHash),\n              `unable to get receipt for transaction ${l.transactionHash}`\n            )\n          )\n        )\n\n        // Find a transaction with a TxExecuted log\n        const found = txs.find(tx =>\n          tx.logs.find(\n            l =>\n              (l.topics.length === 0 && l.data.replace('0x', '') === normalMetaTxnId) ||\n              (l.topics.length === 1 &&\n                // TxFailed event topic\n                l.topics[0] === '0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7' &&\n                l.data.length >= 64 &&\n                l.data.replace('0x', '').startsWith(normalMetaTxnId))\n          )\n        )\n\n        // If found return that\n        if (found) {\n          return {\n            receipt: found,\n            ...(await retry(\n              () => this.provider.getTransaction(found.transactionHash),\n              `unable to get transaction ${found.transactionHash}`\n            ))\n          }\n        }\n\n        // Otherwise wait and try again\n        if (!timedOut) {\n          await new Promise(r => setTimeout(r, delay))\n        }\n      }\n\n      throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`)\n    }\n\n    if (timeout !== undefined) {\n      return Promise.race([\n        waitReceipt(),\n        new Promise<providers.TransactionResponse & { receipt: providers.TransactionReceipt }>((_, reject) =>\n          setTimeout(() => {\n            timedOut = true\n            reject(`Timeout waiting for transaction receipt ${metaTxnId}`)\n          }, timeout)\n        )\n      ])\n    } else {\n      return waitReceipt()\n    }\n  }\n}\n","/* eslint-disable */\n// sequence-relayer v0.4.0 752f4f4274ca80d2fd974b5b44ed8245dfe40554\n// --\n// Code generated by webrpc-gen@v0.10.x-dev with typescript generator. DO NOT EDIT.\n//\n// webrpc-gen -schema=relayer.ridl -target=typescript -client -out=./clients/relayer.gen.ts\n\n// WebRPC description and code-gen version\nexport const WebRPCVersion = \"v1\"\n\n// Schema version of your RIDL schema\nexport const WebRPCSchemaVersion = \"v0.4.0\"\n\n// Schema hash generated from your RIDL schema\nexport const WebRPCSchemaHash = \"752f4f4274ca80d2fd974b5b44ed8245dfe40554\"\n\n//\n// Types\n//\n\nexport enum ETHTxnStatus {\n  UNKNOWN = 'UNKNOWN',\n  DROPPED = 'DROPPED',\n  QUEUED = 'QUEUED',\n  SENT = 'SENT',\n  SUCCEEDED = 'SUCCEEDED',\n  PARTIALLY_FAILED = 'PARTIALLY_FAILED',\n  FAILED = 'FAILED'\n}\nexport enum TransferType {\n  SEND = 'SEND',\n  RECEIVE = 'RECEIVE',\n  BRIDGE_DEPOSIT = 'BRIDGE_DEPOSIT',\n  BRIDGE_WITHDRAW = 'BRIDGE_WITHDRAW',\n  BURN = 'BURN',\n  UNKNOWN = 'UNKNOWN'\n}\nexport enum FeeTokenType {\n  UNKNOWN = 'UNKNOWN',\n  ERC20_TOKEN = 'ERC20_TOKEN',\n  ERC1155_TOKEN = 'ERC1155_TOKEN'\n}\nexport enum SortOrder {\n  DESC = 'DESC',\n  ASC = 'ASC'\n}\n\nexport interface Version {\n  webrpcVersion: string\n  schemaVersion: string\n  schemaHash: string\n  appVersion: string\n}\n\nexport interface RuntimeStatus {\n  healthOK: boolean\n  startTime: string\n  uptime: number\n  ver: string\n  branch: string\n  commitHash: string\n  senders: Array<SenderStatus>\n  checks: RuntimeChecks\n  numTxnsRelayed: number\n}\n\nexport interface SenderStatus {\n  index: number\n  address: string\n  etherBalance: number\n  active: boolean\n}\n\nexport interface RuntimeChecks {\n}\n\nexport interface SequenceContext {\n  factory: string\n  mainModule: string\n  mainModuleUpgradable: string\n  guestModule: string\n  utils: string\n}\n\nexport interface WalletConfig {\n  address: string\n  signers: Array<WalletSigner>\n  threshold: number\n  chainId?: number\n}\n\nexport interface WalletSigner {\n  address: string\n  weight: number\n}\n\nexport interface GasSponsor {\n  id: number\n  address: string\n  name: string\n  active: boolean\n  updatedAt: string\n  createdAt: string\n}\n\nexport interface GasSponsorUsage {\n  name: string\n  id: number\n  totalGasUsed: number\n  totalTxnFees: number\n  avgGasPrice: number\n  totalTxns: number\n  startTime: string\n  endTime: string\n}\n\nexport interface MetaTxn {\n  walletAddress: string\n  contract: string\n  input: string\n}\n\nexport interface MetaTxnLog {\n  id: number\n  txnHash: string\n  txnNonce: string\n  metaTxnID?: string\n  txnStatus: ETHTxnStatus\n  txnRevertReason: string\n  requeues: number\n  queuedAt: string\n  sentAt: string\n  minedAt: string\n  target: string\n  input: string\n  txnArgs: {[key: string]: any}\n  txnReceipt?: {[key: string]: any}\n  walletAddress: string\n  metaTxnNonce: string\n  gasLimit: number\n  gasPrice: string\n  gasUsed: number\n  isWhitelisted: boolean\n  gasSponsor?: number\n  updatedAt: string\n  createdAt: string\n}\n\nexport interface MetaTxnEntry {\n  id: number\n  metaTxnID: string\n  txnStatus: ETHTxnStatus\n  txnRevertReason: string\n  index: number\n  logs?: Array<any>\n  updatedAt: string\n  createdAt: string\n}\n\nexport interface MetaTxnReceipt {\n  id: string\n  status: string\n  revertReason?: string\n  index: number\n  logs: Array<MetaTxnReceiptLog>\n  receipts: Array<MetaTxnReceipt>\n  txnReceipt: string\n}\n\nexport interface MetaTxnReceiptLog {\n  address: string\n  topics: Array<string>\n  data: string\n}\n\nexport interface Transaction {\n  txnHash?: string\n  blockNumber: number\n  chainId: number\n  metaTxnID?: string\n  transfers?: Array<TxnLogTransfer>\n  users?: {[key: string]: TxnLogUser}\n  timestamp: string\n}\n\nexport interface TxnLogUser {\n  username: string\n}\n\nexport interface TxnLogTransfer {\n  transferType: TransferType\n  contractAddress: string\n  from: string\n  to: string\n  ids: Array<string>\n  amounts: Array<string>\n}\n\nexport interface SentTransactionsFilter {\n  pending?: boolean\n  failed?: boolean\n}\n\nexport interface SimulateResult {\n  executed: boolean\n  succeeded: boolean\n  result?: string\n  reason?: string\n  gasUsed: number\n  gasLimit: number\n}\n\nexport interface FeeOption {\n  token: FeeToken\n  to: string\n  value: string\n  gasLimit: number\n}\n\nexport interface FeeToken {\n  chainId: number\n  name: string\n  symbol: string\n  type: FeeTokenType\n  decimals?: number\n  logoURL: string\n  contractAddress?: string\n  tokenID?: string\n}\n\nexport interface Page {\n  pageSize?: number\n  page?: number\n  totalRecords?: number\n  column?: string\n  before?: any\n  after?: any\n  sort?: Array<SortBy>\n}\n\nexport interface SortBy {\n  column: string\n  order: SortOrder\n}\n\nexport interface Relayer {\n  ping(headers?: object): Promise<PingReturn>\n  version(headers?: object): Promise<VersionReturn>\n  runtimeStatus(headers?: object): Promise<RuntimeStatusReturn>\n  getSequenceContext(headers?: object): Promise<GetSequenceContextReturn>\n  getChainID(headers?: object): Promise<GetChainIDReturn>\n  sendMetaTxn(args: SendMetaTxnArgs, headers?: object): Promise<SendMetaTxnReturn>\n  getMetaTxnNonce(args: GetMetaTxnNonceArgs, headers?: object): Promise<GetMetaTxnNonceReturn>\n  getMetaTxnReceipt(args: GetMetaTxnReceiptArgs, headers?: object): Promise<GetMetaTxnReceiptReturn>\n  simulate(args: SimulateArgs, headers?: object): Promise<SimulateReturn>\n  updateMetaTxnGasLimits(args: UpdateMetaTxnGasLimitsArgs, headers?: object): Promise<UpdateMetaTxnGasLimitsReturn>\n  feeTokens(headers?: object): Promise<FeeTokensReturn>\n  feeOptions(args: FeeOptionsArgs, headers?: object): Promise<FeeOptionsReturn>\n  getMetaTxnNetworkFeeOptions(args: GetMetaTxnNetworkFeeOptionsArgs, headers?: object): Promise<GetMetaTxnNetworkFeeOptionsReturn>\n  sentTransactions(args: SentTransactionsArgs, headers?: object): Promise<SentTransactionsReturn>\n  pendingTransactions(args: PendingTransactionsArgs, headers?: object): Promise<PendingTransactionsReturn>\n  listGasSponsors(args: ListGasSponsorsArgs, headers?: object): Promise<ListGasSponsorsReturn>\n  addGasSponsor(args: AddGasSponsorArgs, headers?: object): Promise<AddGasSponsorReturn>\n  updateGasSponsor(args: UpdateGasSponsorArgs, headers?: object): Promise<UpdateGasSponsorReturn>\n  reportGasSponsorUsage(args: ReportGasSponsorUsageArgs, headers?: object): Promise<ReportGasSponsorUsageReturn>\n}\n\nexport interface PingArgs {\n}\n\nexport interface PingReturn {\n  status: boolean  \n}\nexport interface VersionArgs {\n}\n\nexport interface VersionReturn {\n  version: Version  \n}\nexport interface RuntimeStatusArgs {\n}\n\nexport interface RuntimeStatusReturn {\n  status: RuntimeStatus  \n}\nexport interface GetSequenceContextArgs {\n}\n\nexport interface GetSequenceContextReturn {\n  data: SequenceContext  \n}\nexport interface GetChainIDArgs {\n}\n\nexport interface GetChainIDReturn {\n  chainID: number  \n}\nexport interface SendMetaTxnArgs {\n  call: MetaTxn\n  quote?: string\n}\n\nexport interface SendMetaTxnReturn {\n  status: boolean\n  txnHash: string  \n}\nexport interface GetMetaTxnNonceArgs {\n  walletContractAddress: string\n  space?: string\n}\n\nexport interface GetMetaTxnNonceReturn {\n  nonce: string  \n}\nexport interface GetMetaTxnReceiptArgs {\n  metaTxID: string\n}\n\nexport interface GetMetaTxnReceiptReturn {\n  receipt: MetaTxnReceipt  \n}\nexport interface SimulateArgs {\n  wallet: string\n  transactions: string\n}\n\nexport interface SimulateReturn {\n  results: Array<SimulateResult>  \n}\nexport interface UpdateMetaTxnGasLimitsArgs {\n  walletAddress: string\n  walletConfig: WalletConfig\n  payload: string\n}\n\nexport interface UpdateMetaTxnGasLimitsReturn {\n  payload: string  \n}\nexport interface FeeTokensArgs {\n}\n\nexport interface FeeTokensReturn {\n  isFeeRequired: boolean\n  tokens: Array<FeeToken>  \n}\nexport interface FeeOptionsArgs {\n  wallet: string\n  to: string\n  data: string\n}\n\nexport interface FeeOptionsReturn {\n  options: Array<FeeOption>\n  quote?: string  \n}\nexport interface GetMetaTxnNetworkFeeOptionsArgs {\n  walletConfig: WalletConfig\n  payload: string\n}\n\nexport interface GetMetaTxnNetworkFeeOptionsReturn {\n  options: Array<FeeOption>  \n}\nexport interface SentTransactionsArgs {\n  filter?: SentTransactionsFilter\n  page?: Page\n}\n\nexport interface SentTransactionsReturn {\n  page: Page\n  transactions: Array<Transaction>  \n}\nexport interface PendingTransactionsArgs {\n  page?: Page\n}\n\nexport interface PendingTransactionsReturn {\n  page: Page\n  transactions: Array<Transaction>  \n}\nexport interface ListGasSponsorsArgs {\n  page?: Page\n}\n\nexport interface ListGasSponsorsReturn {\n  page: Page\n  gasSponsors: Array<GasSponsor>  \n}\nexport interface AddGasSponsorArgs {\n  address: string\n  name?: string\n  active?: boolean\n}\n\nexport interface AddGasSponsorReturn {\n  status: boolean\n  gasSponsor: GasSponsor  \n}\nexport interface UpdateGasSponsorArgs {\n  address: string\n  name?: string\n  active?: boolean\n}\n\nexport interface UpdateGasSponsorReturn {\n  status: boolean\n  gasSponsor: GasSponsor  \n}\nexport interface ReportGasSponsorUsageArgs {\n  startTime?: string\n  endTime?: string\n}\n\nexport interface ReportGasSponsorUsageReturn {\n  gasSponsorUsage: Array<GasSponsorUsage>  \n}\n\n\n  \n//\n// Client\n//\nexport class Relayer implements Relayer {\n  protected hostname: string\n  protected fetch: Fetch\n  protected path = '/rpc/Relayer/'\n\n  constructor(hostname: string, fetch: Fetch) {\n    this.hostname = hostname\n    this.fetch = (input: RequestInfo, init?: RequestInit) => fetch(input, init)\n  }\n\n  private url(name: string): string {\n    return this.hostname + this.path + name\n  }\n  \n  ping = (headers?: object): Promise<PingReturn> => {\n    return this.fetch(\n      this.url('Ping'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status)\n        }\n      })\n    })\n  }\n  \n  version = (headers?: object): Promise<VersionReturn> => {\n    return this.fetch(\n      this.url('Version'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          version: <Version>(_data.version)\n        }\n      })\n    })\n  }\n  \n  runtimeStatus = (headers?: object): Promise<RuntimeStatusReturn> => {\n    return this.fetch(\n      this.url('RuntimeStatus'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <RuntimeStatus>(_data.status)\n        }\n      })\n    })\n  }\n  \n  getSequenceContext = (headers?: object): Promise<GetSequenceContextReturn> => {\n    return this.fetch(\n      this.url('GetSequenceContext'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          data: <SequenceContext>(_data.data)\n        }\n      })\n    })\n  }\n  \n  getChainID = (headers?: object): Promise<GetChainIDReturn> => {\n    return this.fetch(\n      this.url('GetChainID'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          chainID: <number>(_data.chainID)\n        }\n      })\n    })\n  }\n  \n  sendMetaTxn = (args: SendMetaTxnArgs, headers?: object): Promise<SendMetaTxnReturn> => {\n    return this.fetch(\n      this.url('SendMetaTxn'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status), \n          txnHash: <string>(_data.txnHash)\n        }\n      })\n    })\n  }\n  \n  getMetaTxnNonce = (args: GetMetaTxnNonceArgs, headers?: object): Promise<GetMetaTxnNonceReturn> => {\n    return this.fetch(\n      this.url('GetMetaTxnNonce'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          nonce: <string>(_data.nonce)\n        }\n      })\n    })\n  }\n  \n  getMetaTxnReceipt = (args: GetMetaTxnReceiptArgs, headers?: object): Promise<GetMetaTxnReceiptReturn> => {\n    return this.fetch(\n      this.url('GetMetaTxnReceipt'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          receipt: <MetaTxnReceipt>(_data.receipt)\n        }\n      })\n    })\n  }\n  \n  simulate = (args: SimulateArgs, headers?: object): Promise<SimulateReturn> => {\n    return this.fetch(\n      this.url('Simulate'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          results: <Array<SimulateResult>>(_data.results)\n        }\n      })\n    })\n  }\n  \n  updateMetaTxnGasLimits = (args: UpdateMetaTxnGasLimitsArgs, headers?: object): Promise<UpdateMetaTxnGasLimitsReturn> => {\n    return this.fetch(\n      this.url('UpdateMetaTxnGasLimits'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          payload: <string>(_data.payload)\n        }\n      })\n    })\n  }\n  \n  feeTokens = (headers?: object): Promise<FeeTokensReturn> => {\n    return this.fetch(\n      this.url('FeeTokens'),\n      createHTTPRequest({}, headers)\n      ).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          isFeeRequired: <boolean>(_data.isFeeRequired), \n          tokens: <Array<FeeToken>>(_data.tokens)\n        }\n      })\n    })\n  }\n  \n  feeOptions = (args: FeeOptionsArgs, headers?: object): Promise<FeeOptionsReturn> => {\n    return this.fetch(\n      this.url('FeeOptions'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          options: <Array<FeeOption>>(_data.options), \n          quote: <string>(_data.quote)\n        }\n      })\n    })\n  }\n  \n  getMetaTxnNetworkFeeOptions = (args: GetMetaTxnNetworkFeeOptionsArgs, headers?: object): Promise<GetMetaTxnNetworkFeeOptionsReturn> => {\n    return this.fetch(\n      this.url('GetMetaTxnNetworkFeeOptions'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          options: <Array<FeeOption>>(_data.options)\n        }\n      })\n    })\n  }\n  \n  sentTransactions = (args: SentTransactionsArgs, headers?: object): Promise<SentTransactionsReturn> => {\n    return this.fetch(\n      this.url('SentTransactions'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          transactions: <Array<Transaction>>(_data.transactions)\n        }\n      })\n    })\n  }\n  \n  pendingTransactions = (args: PendingTransactionsArgs, headers?: object): Promise<PendingTransactionsReturn> => {\n    return this.fetch(\n      this.url('PendingTransactions'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          transactions: <Array<Transaction>>(_data.transactions)\n        }\n      })\n    })\n  }\n  \n  listGasSponsors = (args: ListGasSponsorsArgs, headers?: object): Promise<ListGasSponsorsReturn> => {\n    return this.fetch(\n      this.url('ListGasSponsors'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          page: <Page>(_data.page), \n          gasSponsors: <Array<GasSponsor>>(_data.gasSponsors)\n        }\n      })\n    })\n  }\n  \n  addGasSponsor = (args: AddGasSponsorArgs, headers?: object): Promise<AddGasSponsorReturn> => {\n    return this.fetch(\n      this.url('AddGasSponsor'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status), \n          gasSponsor: <GasSponsor>(_data.gasSponsor)\n        }\n      })\n    })\n  }\n  \n  updateGasSponsor = (args: UpdateGasSponsorArgs, headers?: object): Promise<UpdateGasSponsorReturn> => {\n    return this.fetch(\n      this.url('UpdateGasSponsor'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          status: <boolean>(_data.status), \n          gasSponsor: <GasSponsor>(_data.gasSponsor)\n        }\n      })\n    })\n  }\n  \n  reportGasSponsorUsage = (args: ReportGasSponsorUsageArgs, headers?: object): Promise<ReportGasSponsorUsageReturn> => {\n    return this.fetch(\n      this.url('ReportGasSponsorUsage'),\n      createHTTPRequest(args, headers)).then((res) => {\n      return buildResponse(res).then(_data => {\n        return {\n          gasSponsorUsage: <Array<GasSponsorUsage>>(_data.gasSponsorUsage)\n        }\n      })\n    })\n  }\n  \n}\n\n  \nexport interface WebRPCError extends Error {\n  code: string\n  msg: string\n\tstatus: number\n}\n\nconst createHTTPRequest = (body: object = {}, headers: object = {}): object => {\n  return {\n    method: 'POST',\n    headers: { ...headers, 'Content-Type': 'application/json' },\n    body: JSON.stringify(body || {})\n  }\n}\n\nconst buildResponse = (res: Response): Promise<any> => {\n  return res.text().then(text => {\n    let data\n    try {\n      data = JSON.parse(text)\n    } catch(err) {\n      throw { code: 'unknown', msg: `expecting JSON, got: ${text}`, status: res.status } as WebRPCError\n    }\n    if (!res.ok) {\n      throw data // webrpc error response\n    }\n    return data\n  })\n}\n\nexport type Fetch = (input: RequestInfo, init?: RequestInit) => Promise<Response>\n","import { ethers } from 'ethers'\nimport { walletContracts } from '@0xsequence/abi'\nimport {\n  Transaction,\n  readSequenceNonce,\n  appendNonce,\n  MetaTransactionsType,\n  sequenceTxAbiEncode,\n  SignedTransactions,\n  computeMetaTxnHash,\n  decodeNonce,\n  TransactionResponse\n} from '@0xsequence/transactions'\nimport { BaseRelayer, BaseRelayerOptions } from '../base-relayer'\nimport { FeeOption, FeeQuote, Relayer, SimulateResult } from '..'\nimport { WalletContext } from '@0xsequence/network'\nimport { WalletConfig, addressOf, buildStubSignature } from '@0xsequence/config'\nimport { logger } from '@0xsequence/utils'\nimport * as proto from './relayer.gen'\n\nexport { proto }\n\nconst FINAL_STATUSES = [\n  proto.ETHTxnStatus.DROPPED,\n  proto.ETHTxnStatus.SUCCEEDED,\n  proto.ETHTxnStatus.PARTIALLY_FAILED,\n  proto.ETHTxnStatus.FAILED\n]\n\nconst FAILED_STATUSES = [proto.ETHTxnStatus.DROPPED, proto.ETHTxnStatus.PARTIALLY_FAILED, proto.ETHTxnStatus.FAILED]\n\nexport interface RpcRelayerOptions extends BaseRelayerOptions {\n  url: string\n}\n\nexport function isRpcRelayerOptions(obj: any): obj is RpcRelayerOptions {\n  return obj.url !== undefined && typeof obj.url === 'string'\n}\n\nconst fetch = typeof global === 'object' ? global.fetch : window.fetch\n\nexport class RpcRelayer extends BaseRelayer implements Relayer {\n  private readonly service: proto.Relayer\n\n  constructor(options: RpcRelayerOptions) {\n    super(options)\n    this.service = new proto.Relayer(options.url, fetch)\n  }\n\n  async waitReceipt(\n    metaTxnId: string | SignedTransactions,\n    delay: number = 1000,\n    maxFails: number = 5,\n    isCancelled?: () => boolean\n  ): Promise<proto.GetMetaTxnReceiptReturn> {\n    if (typeof metaTxnId !== 'string') {\n      logger.info('computing id', metaTxnId.config, metaTxnId.context, metaTxnId.chainId, ...metaTxnId.transactions)\n\n      metaTxnId = computeMetaTxnHash(addressOf(metaTxnId.config, metaTxnId.context), metaTxnId.chainId, ...metaTxnId.transactions)\n    }\n\n    logger.info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnId}`)\n\n    let fails = 0\n\n    while (isCancelled === undefined || !isCancelled()) {\n      try {\n        const { receipt } = await this.service.getMetaTxnReceipt({ metaTxID: metaTxnId })\n\n        if (\n          receipt &&\n          receipt.txnReceipt &&\n          receipt.txnReceipt !== 'null' &&\n          FINAL_STATUSES.includes(receipt.status as proto.ETHTxnStatus)\n        ) {\n          return { receipt }\n        }\n      } catch (e) {\n        fails++\n\n        if (fails === maxFails) {\n          throw e\n        }\n      }\n\n      if (isCancelled === undefined || !isCancelled()) {\n        await new Promise(resolve => setTimeout(resolve, delay))\n      }\n    }\n\n    throw new Error(`Cancelled waiting for transaction receipt ${metaTxnId}`)\n  }\n\n  async simulate(wallet: string, ...transactions: Transaction[]): Promise<SimulateResult[]> {\n    const coder = ethers.utils.defaultAbiCoder\n    const encoded = coder.encode([MetaTransactionsType], [sequenceTxAbiEncode(transactions)])\n    return (await this.service.simulate({ wallet, transactions: encoded })).results\n  }\n\n  async getFeeOptions(\n    config: WalletConfig,\n    context: WalletContext,\n    ...transactions: Transaction[]\n  ): Promise<{ options: FeeOption[]; quote?: FeeQuote }> {\n    // NOTE/TODO: for a given `service` the feeTokens will not change between execution, so we should memoize this value\n    // for a short-period of time, perhaps for 1 day or in memory. Perhaps one day we can make this happen automatically\n    // with http cache response for this endpoint and service-worker.. lots of approaches\n    const feeTokens = await this.service.feeTokens()\n\n    if (feeTokens.isFeeRequired) {\n      const symbols = feeTokens.tokens.map(token => token.symbol).join(', ')\n      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`)\n\n      const wallet = addressOf(config, context)\n\n      let nonce = readSequenceNonce(...transactions)\n      if (nonce === undefined) {\n        nonce = await this.getNonce(config, context)\n      }\n\n      if (!this.provider) {\n        logger.warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`)\n        throw new Error('provider is not set')\n      }\n\n      const { to, execute } = await this.prependWalletDeploy({\n        config,\n        context,\n        transactions,\n        nonce,\n        signature: buildStubSignature(this.provider, config)\n      })\n\n      const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi)\n      const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [\n        sequenceTxAbiEncode(execute.transactions),\n        execute.nonce,\n        execute.signature\n      ])\n\n      const { options, quote } = await this.service.feeOptions({ wallet, to, data })\n\n      logger.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options)}`)\n      return { options, quote: { _tag: 'FeeQuote', _quote: quote } }\n    } else {\n      logger.info(`[rpc-relayer/getFeeOptions] relayer fees are not required`)\n      return { options: [] }\n    }\n  }\n\n  async gasRefundOptions(config: WalletConfig, context: WalletContext, ...transactions: Transaction[]): Promise<FeeOption[]> {\n    const { options } = await this.getFeeOptions(config, context, ...transactions)\n    return options\n  }\n\n  async getNonce(config: WalletConfig, context: WalletContext, space?: ethers.BigNumberish): Promise<ethers.BigNumberish> {\n    const addr = addressOf(config, context)\n    logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${addr} space: ${space}`)\n    const encodedNonce = space !== undefined ? ethers.BigNumber.from(space).toHexString() : undefined\n    const resp = await this.service.getMetaTxnNonce({ walletContractAddress: addr, space: encodedNonce })\n    const nonce = ethers.BigNumber.from(resp.nonce)\n    const [decodedSpace, decodedNonce] = decodeNonce(nonce)\n    logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${addr} ${decodedNonce} space: ${decodedSpace}`)\n    return nonce\n  }\n\n  async relay(\n    signedTxs: SignedTransactions,\n    quote?: FeeQuote,\n    waitForReceipt: boolean = true\n  ): Promise<TransactionResponse<RelayerTxReceipt>> {\n    logger.info(\n      `[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs)} with quote ${JSON.stringify(quote)}`\n    )\n\n    let typecheckedQuote: string | undefined\n    if (quote !== undefined) {\n      if (typeof quote._quote === 'string') {\n        typecheckedQuote = quote._quote\n      } else {\n        logger.warn('[rpc-relayer/relay] ignoring invalid fee quote')\n      }\n    }\n\n    if (!this.provider) {\n      logger.warn(`[rpc-relayer/relay] provider not set, failed relay`)\n      throw new Error('provider is not set')\n    }\n\n    const { to: contract, execute } = await this.prependWalletDeploy(signedTxs)\n\n    const walletAddress = addressOf(signedTxs.config, signedTxs.context)\n    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi)\n    const input = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [\n      sequenceTxAbiEncode(execute.transactions),\n      execute.nonce,\n      execute.signature\n    ])\n\n    const metaTxn = await this.service.sendMetaTxn({ call: { walletAddress, contract, input }, quote: typecheckedQuote })\n\n    logger.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn)}`)\n\n    if (waitForReceipt) {\n      return this.wait(metaTxn.txnHash)\n    } else {\n      const response = {\n        hash: metaTxn.txnHash,\n        confirmations: 0,\n        from: walletAddress,\n        wait: (_confirmations?: number): Promise<ethers.providers.TransactionReceipt> => Promise.reject(new Error('impossible'))\n      }\n\n      const wait = async (confirmations?: number): Promise<ethers.providers.TransactionReceipt> => {\n        if (!this.provider) {\n          throw new Error('cannot wait for receipt, relayer has no provider set')\n        }\n\n        const waitResponse = await this.wait(metaTxn.txnHash)\n        const transactionHash = waitResponse.receipt?.transactionHash\n\n        if (!transactionHash) {\n          throw new Error('cannot wait for receipt, unknown native transaction hash')\n        }\n\n        Object.assign(response, waitResponse)\n\n        return this.provider.waitForTransaction(transactionHash, confirmations)\n      }\n\n      response.wait = wait\n\n      return response as TransactionResponse\n    }\n  }\n\n  async wait(\n    metaTxnId: string | SignedTransactions,\n    timeout?: number,\n    delay: number = 1000,\n    maxFails: number = 5\n  ): Promise<TransactionResponse<RelayerTxReceipt>> {\n    let timedOut = false\n\n    const { receipt } = await (timeout !== undefined\n      ? Promise.race([\n          this.waitReceipt(metaTxnId, delay, maxFails, () => timedOut),\n          new Promise<proto.GetMetaTxnReceiptReturn>((_, reject) =>\n            setTimeout(() => {\n              timedOut = true\n              reject(`Timeout waiting for transaction receipt ${metaTxnId}`)\n            }, timeout)\n          )\n        ])\n      : this.waitReceipt(metaTxnId, delay, maxFails))\n\n    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status as proto.ETHTxnStatus)) {\n      throw new MetaTransactionResponseException(receipt)\n    }\n\n    const txReceipt = JSON.parse(receipt.txnReceipt) as RelayerTxReceipt\n\n    return {\n      blockHash: txReceipt.blockHash,\n      blockNumber: ethers.BigNumber.from(txReceipt.blockNumber).toNumber(),\n      confirmations: 1,\n      from: typeof metaTxnId === 'string' ? undefined : addressOf(metaTxnId.config, metaTxnId.context),\n      hash: txReceipt.transactionHash,\n      raw: receipt.txnReceipt,\n      receipt: txReceipt, // extended type which is Sequence-specific. Contains the decoded metaTxReceipt\n      wait: async (confirmations?: number) => this.provider!.waitForTransaction(txReceipt.transactionHash, confirmations)\n    } as TransactionResponse\n  }\n}\n\nclass MetaTransactionResponseException {\n  constructor(public receipt: proto.MetaTxnReceipt) {}\n}\n\nexport type RelayerTxReceipt = {\n  blockHash: string\n  blockNumber: string\n  contractAddress: string\n  cumulativeGasUsed: string\n  gasUsed: string\n  logs: {\n    address: string\n    blockHash: string\n    blockNumber: string\n    data: string\n    logIndex: string\n    removed: boolean\n    topics: string[]\n    transactionHash: string\n    transactionIndex: string\n  }[]\n  logsBloom: string\n  root: string\n  status: string\n  transactionHash: string\n  transactionIndex: string\n}\n","import { ethers, providers } from 'ethers'\nimport { SignedTransactions, Transaction, TransactionResponse } from '@0xsequence/transactions'\nimport { WalletContext } from '@0xsequence/network'\nimport { WalletConfig } from '@0xsequence/config'\nimport { proto } from './rpc-relayer'\n\nexport interface Relayer {\n  // simulate returns the execution results for a list of transactions.\n  simulate(wallet: string, ...transactions: Transaction[]): Promise<SimulateResult[]>\n\n  // getFeeOptions returns the fee options that the relayer will accept as payment.\n  // If a quote is returned, it may be passed back to the relayer for dispatch.\n  getFeeOptions(\n    config: WalletConfig,\n    context: WalletContext,\n    ...transactions: Transaction[]\n  ): Promise<{ options: FeeOption[], quote?: FeeQuote }>\n\n  // gasRefundOptions returns the transactions which can be included to refund a\n  // relayer for submitting your transaction to a network.\n  gasRefundOptions(\n    config: WalletConfig,\n    context: WalletContext,\n    ...transactions: Transaction[]\n  ): Promise<FeeOption[]>\n\n  // getNonce returns the transaction count/nonce for a wallet, encoded with nonce space.\n  // If space is undefined, the relayer can choose a nonce space to encode the result with.\n  // Otherwise, the relayer must return a nonce encoded for the given nonce space.\n  getNonce(config: WalletConfig, context: WalletContext, space?: ethers.BigNumberish, blockTag?: providers.BlockTag): Promise<ethers.BigNumberish>\n\n  // relayer will submit the transaction(s) to the network and return the transaction response.\n  // The quote should be the one returned from getFeeOptions, if any.\n  // waitForReceipt must default to true.\n  relay(signedTxs: SignedTransactions, quote?: FeeQuote, waitForReceipt?: boolean): Promise<TransactionResponse>\n\n  // wait for transaction confirmation\n  // timeout is the maximum time to wait for the transaction response\n  // delay is the polling interval, i.e. the time to wait between requests\n  // maxFails is the maximum number of hard failures to tolerate before giving up\n  wait(metaTxnId: string | SignedTransactions, timeout?: number, delay?: number, maxFails?: number): Promise<TransactionResponse>\n}\n\nexport * from './local-relayer'\nexport * from './base-relayer'\nexport * from './provider-relayer'\nexport * from './rpc-relayer'\nexport { proto as RpcRelayerProto } from './rpc-relayer'\nexport type SimulateResult = proto.SimulateResult\nexport type FeeOption = proto.FeeOption\n\n// A fee quote is simply an opaque value that can be obtained via Relayer.getFeeOptions(), and\n// returned back to the same relayer via Relayer.relay(). Fee quotes should be treated as an\n// implementation detail of the relayer that produces them.\n//\n// This interface exists for type-safety purposes to protect against passing non-FeeQuotes to\n// Relayer.relay(), or any other functions that call it indirectly (e.g. Account.sendTransaction).\nexport interface FeeQuote {\n  _tag: 'FeeQuote'\n  _quote: unknown\n}\n\nexport function isRelayer(cand: any): cand is Relayer {\n  return (\n    typeof cand === 'object' &&\n    typeof cand.simulate === 'function' &&\n    typeof cand.getFeeOptions === 'function' &&\n    typeof cand.gasRefundOptions === 'function' &&\n    typeof cand.getNonce === 'function' &&\n    typeof cand.relay === 'function' &&\n    typeof cand.wait === 'function'\n  )\n}\n","import { Signer as AbstractSigner, BytesLike, providers, utils, TypedDataDomain, TypedDataField } from 'ethers'\nimport { Signer, NotEnoughSigners, SignedTransactionsCallback } from './signer'\nimport {\n  SignedTransactions,\n  Transactionish,\n  Transaction,\n  computeMetaTxnHash,\n  fromTransactionish,\n  TransactionResponse\n} from '@0xsequence/transactions'\nimport {\n  WalletConfig,\n  WalletState,\n  addressOf,\n  isConfigEqual,\n  sortConfig,\n  ConfigFinder,\n  SequenceUtilsFinder\n} from '@0xsequence/config'\nimport {\n  ChainIdLike,\n  NetworkConfig,\n  WalletContext,\n  sequenceContext,\n  mainnetNetworks,\n  ensureValidNetworks,\n  getChainId,\n  sortNetworks\n} from '@0xsequence/network'\nimport { Wallet } from './wallet'\nimport { resolveArrayProperties } from './utils'\nimport { isRelayer, FeeOption, FeeQuote, Relayer, RpcRelayer, isRpcRelayerOptions } from '@0xsequence/relayer'\nimport { encodeTypedDataDigest } from '@0xsequence/utils'\n\nexport interface AccountOptions {\n  initialConfig: WalletConfig\n  networks?: NetworkConfig[]\n  context?: WalletContext\n  configFinder?: ConfigFinder\n}\n\n// Account is an interface to a multi-network smart contract wallet.\nexport class Account extends Signer {\n  private readonly options: AccountOptions\n\n  private _wallets: {\n    wallet: Wallet\n    network: NetworkConfig\n  }[]\n\n  private _signers: (BytesLike | AbstractSigner)[]\n\n  // provider points at the main chain for compatability with the Signer.\n  // Use getProvider(chainId) to get the provider for the respective network.\n  provider: providers.JsonRpcProvider\n\n  // memoized value\n  private _chainId?: number\n\n  constructor(options: AccountOptions, ...signers: (BytesLike | AbstractSigner)[]) {\n    super()\n\n    this.options = options\n    this._signers = signers\n\n    // Use deployed wallet context by default if not provided\n    if (!options.context) this.options.context = { ...sequenceContext }\n\n    // Network config, defaults will be used if none are provided\n    if (this.options.networks) {\n      this.setNetworks(this.options.networks)\n    } else {\n      this.setNetworks([...mainnetNetworks])\n    }\n  }\n\n  useSigners(...signers: (BytesLike | AbstractSigner)[]): Account {\n    this._signers = signers\n    this._wallets.forEach(w => {\n      w.wallet = w.wallet.useSigners(...signers)\n    })\n    return this\n  }\n\n  async getWalletContext(): Promise<WalletContext> {\n    return this.options.context!\n  }\n\n  getConfigFinder(): ConfigFinder {\n    if (this.options.configFinder) return this.options.configFinder\n    return new SequenceUtilsFinder(this.authWallet().wallet.provider)\n  }\n\n  // getWalletConfig builds a list of WalletConfigs across all networks.\n  // This is useful to shows all keys/devices connected to a wallet across networks.\n  async getWalletConfig(chainId?: ChainIdLike): Promise<WalletConfig[]> {\n    let wallets: { wallet: Wallet; network: NetworkConfig }[] = []\n    if (chainId) {\n      const v = this.getWalletByNetwork(chainId)\n      if (v) {\n        wallets.push(v)\n      }\n    } else {\n      wallets = this._wallets\n    }\n    return (await Promise.all(wallets.map(w => w.wallet.getWalletConfig()))).flat()\n  }\n\n  async getWalletState(chainId?: ChainIdLike): Promise<WalletState[]> {\n    let wallets: { wallet: Wallet; network: NetworkConfig }[] = []\n    if (chainId) {\n      const v = this.getWalletByNetwork(chainId)\n      if (v) {\n        wallets.push(v)\n      }\n    } else {\n      wallets = this._wallets\n    }\n\n    const configsPromise = Promise.all(\n      wallets.map(w =>\n        this.getConfigFinder().findCurrentConfig({\n          address: w.wallet.address,\n          provider: w.wallet.provider,\n          context: w.wallet.context,\n          knownConfigs: [w.wallet.config]\n        })\n      )\n    )\n\n    const states = (await Promise.all(wallets.map(w => w.wallet.getWalletState()))).flat()\n\n    // fetch the current config for the AuthChain, as it will be available\n    const idx = states.findIndex(s => s.chainId === this.getAuthChainId())\n    if (idx >= 0) {\n      states[idx].config = await this.currentConfig(wallets[idx].wallet)\n    }\n\n    const configs = await configsPromise\n\n    return states.map((s, i) => ({\n      ...s,\n      config: configs[i]?.config\n    }))\n  }\n\n  // address getter\n  get address(): string {\n    return this._wallets[0].wallet.address\n  }\n\n  // getAddress returns the address of the wallet -- note the account address is the same\n  // across all wallets on all different networks\n  getAddress(): Promise<string> {\n    return this._wallets[0].wallet.getAddress()\n  }\n\n  // getSigners returns the multi-sig signers with permission to control the wallet\n  async getSigners(): Promise<string[]> {\n    return this._wallets[0].wallet.getSigners()\n  }\n\n  async getProvider(chainId?: number): Promise<providers.JsonRpcProvider | undefined> {\n    if (!chainId) return this.mainWallet()?.wallet.getProvider()\n    return this._wallets.find(w => w.network.chainId === chainId)?.wallet.getProvider()\n  }\n\n  async getRelayer(chainId?: number): Promise<Relayer | undefined> {\n    if (!chainId) return this.mainWallet()?.wallet.getRelayer()\n    return this._wallets.find(w => w.network.chainId === chainId)?.wallet.getRelayer()\n  }\n\n  async getNetworks(): Promise<NetworkConfig[]> {\n    return this.options.networks!\n  }\n\n  // NOTE: this is copied over on top of ethers, and is memoized\n  async getChainId(): Promise<number> {\n    if (this._chainId) return this._chainId\n    const network = await this.provider.getNetwork()\n    this._chainId = network.chainId\n    return this._chainId\n  }\n\n  getAuthChainId(): number {\n    try {\n      return this.options.networks!.find(network => network.isAuthChain)!.chainId\n    } catch {\n      throw new Error('no auth network')\n    }\n  }\n\n  async signMessage(\n    message: BytesLike,\n    target?: Wallet | ChainIdLike,\n    allSigners: boolean = true,\n    isDigest: boolean = false\n  ): Promise<string> {\n    let { wallet } = await (async () => {\n      // eslint-disable-line\n      if (!target) {\n        return this.mainWallet()\n      }\n      if ((<Wallet>target).address) {\n        const chainId = await (<Wallet>target).getChainId()\n        return this.getWalletByNetwork(chainId)\n      }\n      return this.getWalletByNetwork(target as ChainIdLike)\n    })()\n\n    // Fetch the latest config of the wallet.\n    //\n    // We skip this step if wallet is authWallet. The assumption is that authWallet\n    // will already have the latest config, but lets confirm that.\n    // TODO: instead, memoize the currentConfig, as below will break\n    // if we skip\n    // if (!network.isAuthChain) {\n    let thisConfig = await this.currentConfig(wallet)\n    thisConfig = thisConfig ? thisConfig : this._wallets[0].wallet.config\n    wallet = wallet.useConfig(thisConfig)\n    // }\n\n    // See if wallet and available signers set has enough signer power,\n    // but if allSigners is false, we allow partial signing\n    const weight = await wallet.signWeight()\n    if (weight.lt(wallet.config.threshold) && allSigners !== false) {\n      throw new NotEnoughSigners(\n        `Sign message - wallet combined weight ${weight.toString()} below required ${wallet.config.threshold.toString()}`\n      )\n    }\n\n    return wallet.signMessage(message, undefined, allSigners, isDigest)\n  }\n\n  // TODO: should allSigners default to false here..?\n  async signAuthMessage(message: BytesLike, allSigners: boolean = true, isDigest: boolean = false): Promise<string> {\n    return this.signMessage(message, this.authWallet()?.wallet, allSigners, isDigest)\n  }\n\n  async signTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    message: Record<string, any>,\n    chainId?: ChainIdLike,\n    allSigners: boolean = true\n  ): Promise<string> {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet\n    const digest = encodeTypedDataDigest({ domain, types, message })\n    return this.signMessage(digest, wallet, allSigners, true)\n  }\n\n  async _signTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    message: Record<string, any>,\n    chainId?: ChainIdLike,\n    allSigners: boolean = true\n  ): Promise<string> {\n    return this.signTypedData(domain, types, message, chainId, allSigners)\n  }\n\n  async hasEnoughSigners(chainId?: ChainIdLike): Promise<boolean> {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet\n    const thisConfig = await this.currentConfig(wallet)\n    return wallet.useConfig(thisConfig!).hasEnoughSigners()\n  }\n\n  async getFeeOptions(\n    transaction: utils.Deferrable<Transactionish>,\n    chainId?: ChainIdLike,\n    allSigners: boolean = true\n  ): Promise<{ options: FeeOption[]; quote?: FeeQuote }> {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet\n\n    const context = this.options.context\n    if (!context) {\n      throw new Error(`missing wallet context`)\n    }\n\n    // TODO: can we avoid calling `this.currentConfig(wallet)` everytime here.. this is an expensive\n    // operations and we shouldn't be doing it so liberally. What is the minimum information we require here..?\n    // and what is the config used for, and how can we optimize..?\n\n    // TODO: prependConfigUpdate also looks like its calling currentConfig() again, so we're doubling this.\n\n    // A few thoughts.. first off, we must add some kind of memoization for this, but with great care, because\n    // the config might change. This make me think we need some king of \"ConfigSource\" class, or \"ConfigXXX\" (name?),\n    // which we can ask to give us a wallet config. This config would also be used when we update/change a config,\n    // such that it can memoize, but also since its the sole interface, it will also properly expire or update the config\n    // in cache as necessary. Further to this, I think we need to only get config details for what is required, and try\n    // to optimize by using imageHashes of the config everywhere, as this is a much more inexpensive value to fetch.\n\n    const [config, updatedTransaction] = await Promise.all([\n      this.currentConfig(wallet),\n      this.prependConfigUpdate(transaction, chainId, allSigners, true)\n    ])\n    if (!config) {\n      throw new Error(`missing current config for chain ${chainId}`)\n    }\n\n    const finalTransactions = await fromTransactionish(context, this.address, updatedTransaction)\n    return wallet.relayer.getFeeOptions(config, context, ...finalTransactions)\n  }\n\n  async sendTransaction(\n    dtransactionish: utils.Deferrable<Transactionish>,\n    chainId?: ChainIdLike,\n    allSigners: boolean = true,\n    quote?: FeeQuote,\n    callback?: SignedTransactionsCallback\n  ): Promise<TransactionResponse> {\n    const signedTxs = await this.signTransactions(dtransactionish, chainId, allSigners)\n\n    if (callback) {\n      const address = addressOf(signedTxs.config, signedTxs.context)\n      const metaTxnHash = computeMetaTxnHash(address, signedTxs.chainId, ...signedTxs.transactions)\n      callback(signedTxs, metaTxnHash)\n    }\n\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet\n    return wallet.sendSignedTransactions(signedTxs, chainId, quote)\n  }\n\n  async sendTransactionBatch(\n    transactions: utils.Deferrable<providers.TransactionRequest[] | Transaction[]>,\n    chainId?: ChainIdLike,\n    allSigners: boolean = true,\n    quote?: FeeQuote,\n    callback?: SignedTransactionsCallback\n  ): Promise<TransactionResponse> {\n    return this.sendTransaction(transactions, chainId, allSigners, quote, callback)\n  }\n\n  async signTransactions(\n    dtransactionish: utils.Deferrable<Transactionish>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<SignedTransactions> {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet\n    let currentConfig = await this.currentConfig(wallet)\n\n    if (!currentConfig) {\n      currentConfig = await this.currentConfig()\n      if (!currentConfig) {\n        throw new Error('missing auth chain config')\n      }\n    }\n\n    const transactions = await this.prependConfigUpdate(dtransactionish, chainId, allSigners)\n    return wallet.useConfig(currentConfig).signTransactions(transactions)\n  }\n\n  async prependConfigUpdate(\n    dtransactionish: utils.Deferrable<Transactionish>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean,\n    skipThresholdCheck?: boolean\n  ): Promise<Transactionish> {\n    const transaction = await resolveArrayProperties<Transactionish>(dtransactionish)\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet\n\n    // TODO: Skip this step if wallet is authWallet\n    const [thisConfig, lastConfig] = await Promise.all([this.currentConfig(wallet), this.currentConfig()])\n\n    // We have to skip the threshold check during fee estimation because we\n    // might not have the necessary signers until the wallet actually signs the\n    // transactions.\n    //\n    // By design, the Torus login key only exists in memory in Sequence wallet\n    // and cannot generally be assumed to be available. However the Torus login\n    // key might be required in order to transact on other non-auth chains,\n    // because the wallet config might not recognize the current session's\n    // signing key. In these cases, the Torus key is retrieved when the user\n    // confirms the transaction, which happens after fee estimation. So the\n    // wallet might not meet the threshold during fee estimation despite\n    // meeting it at confirmation time.\n    if (!skipThresholdCheck) {\n      // See if wallet has enough signer power\n      const weight = await wallet.useConfig(thisConfig!).signWeight()\n      if (weight.lt(thisConfig!.threshold) && allSigners) {\n        throw new NotEnoughSigners(\n          `wallet combined weight ${weight.toString()} below required threshold ${thisConfig!.threshold.toString()}`\n        )\n      }\n    }\n\n    // If the wallet is updated, just sign as-is\n    if ((await wallet.isDeployed()) && isConfigEqual(lastConfig!, thisConfig!)) {\n      return transaction\n    }\n\n    // Bundle with configuration update\n    const transactionParts = (() => {\n      if (Array.isArray(transaction)) {\n        return transaction\n      } else {\n        return [transaction]\n      }\n    })()\n\n    return [...(await wallet.buildUpdateConfigTransaction(lastConfig!, false)), ...transactionParts]\n  }\n\n  async sendSignedTransactions(\n    signedTxs: SignedTransactions,\n    chainId?: ChainIdLike,\n    quote?: FeeQuote\n  ): Promise<TransactionResponse> {\n    const wallet = chainId ? this.getWalletByNetwork(chainId).wallet : this.mainWallet().wallet\n    return wallet.sendSignedTransactions(signedTxs, undefined, quote)\n  }\n\n  // updateConfig will build an updated config transaction, update the imageHash on-chain and also publish\n  // the wallet config to the authChain. Other chains are lazy-updated on-demand as batched transactions.\n  async updateConfig(\n    newConfig?: WalletConfig,\n    index?: boolean,\n    quote?: FeeQuote,\n    callback?: SignedTransactionsCallback\n  ): Promise<[WalletConfig, TransactionResponse | undefined]> {\n    const authWallet = this.authWallet().wallet\n\n    if (!newConfig) {\n      newConfig = authWallet.config\n    } else {\n      // ensure its normalized\n      newConfig = sortConfig(newConfig)\n    }\n\n    // The config is the default config, see if the wallet has been deployed\n    if (isConfigEqual(authWallet.config, newConfig)) {\n      if (!(await this.isDeployed())) {\n        // Deploy the wallet and publish initial configuration\n        return await authWallet.updateConfig(newConfig, undefined, true, index, quote, callback)\n      }\n    }\n\n    // Get latest config, update only if neccesary\n    const lastConfig = await this.currentConfig()\n    if (isConfigEqual(lastConfig!, newConfig)) {\n      return [\n        {\n          ...lastConfig!,\n          address: this.address\n        },\n        undefined\n      ]\n    }\n\n    // Update to new configuration on the authWallet. Other networks will be lazily updated\n    // once used. The wallet config is also auto-published to the authChain.\n    const [_, tx] = await authWallet.useConfig(lastConfig!).updateConfig(newConfig, undefined, true, index, quote, callback)\n\n    return [\n      {\n        ...newConfig,\n        address: this.address\n      },\n      tx\n    ]\n  }\n\n  // publishConfig will publish the wallet config to the network via the relayer. Publishing\n  // the config will also store the entire object of signers.\n  publishConfig(\n    indexed?: boolean,\n    requireFreshSigners: string[] = [],\n    quote?: FeeQuote,\n    callback?: SignedTransactionsCallback\n  ): Promise<TransactionResponse> {\n    return this.authWallet().wallet.publishConfig(indexed, undefined, requireFreshSigners, quote, callback)\n  }\n\n  async isDeployed(target?: Wallet | ChainIdLike): Promise<boolean> {\n    const wallet = (() => {\n      if (!target) return this.authWallet().wallet\n      if ((<Wallet>target).address) {\n        return target as Wallet\n      }\n      return this.getWalletByNetwork(target as NetworkConfig).wallet\n    })()\n    return wallet.isDeployed()\n  }\n\n  // TODO: Split this to it's own class \"configProvider\" or something\n  // this process can be done in different ways (caching, api, utils, etc)\n  async currentConfig(target?: Wallet | NetworkConfig): Promise<WalletConfig | undefined> {\n    const wallet = (() => {\n      if (!target) return this.authWallet().wallet\n      if ((<Wallet>target).address) {\n        return target as Wallet\n      }\n      return this.getWalletByNetwork(target as NetworkConfig).wallet\n    })()\n\n    return (\n      await this.getConfigFinder().findCurrentConfig({\n        address: this.address,\n        provider: wallet.provider,\n        context: wallet.context,\n        knownConfigs: [wallet.config]\n      })\n    ).config\n  }\n\n  getWallets(): { wallet: Wallet; network: NetworkConfig }[] {\n    return this._wallets\n  }\n\n  getWalletByNetwork(chainId: ChainIdLike) {\n    const networkId = getChainId(chainId)\n    const network = this._wallets.find(w => w.network.chainId === networkId)\n    if (!network) {\n      throw new Error(`network ${chainId} not found in wallets list`)\n    }\n    return network\n  }\n\n  // mainWallet is the DefaultChain wallet\n  mainWallet(): { wallet: Wallet; network: NetworkConfig } {\n    const found = this._wallets.find(w => w.network.isDefaultChain)\n    if (!found) {\n      throw new Error('mainWallet not found')\n    }\n    return found\n  }\n\n  // authWallet is the AuthChain wallet\n  authWallet(): { wallet: Wallet; network: NetworkConfig } {\n    const found = this._wallets.find(w => w.network.isAuthChain)\n    if (!found) {\n      throw new Error('authChain wallet not found')\n    }\n    return found\n  }\n\n  setNetworks(mainnetNetworks: NetworkConfig[], testnetNetworks: NetworkConfig[] = [], defaultChainId?: string | number): number {\n    let networks: NetworkConfig[] = []\n    this._chainId = undefined // clear memoized value\n\n    // find chain between mainnet and testnet network groups, and set that network group.\n    // otherwise use mainnetNetworks without changes\n    if (defaultChainId) {\n      // force-convert to a number in case someone sends a number in a string like \"1\"\n      const defaultChainIdNum = parseInt(defaultChainId as any)\n\n      const foundMainnetNetwork = mainnetNetworks.find(n => n.name === defaultChainId || n.chainId === defaultChainIdNum)\n      const foundTestnetNetwork = testnetNetworks.find(n => n.name === defaultChainId || n.chainId === defaultChainIdNum)\n\n      if (foundMainnetNetwork || foundTestnetNetwork) {\n        if (foundMainnetNetwork) {\n          mainnetNetworks.forEach(n => (n.isDefaultChain = false))\n          foundMainnetNetwork.isDefaultChain = true\n          networks = mainnetNetworks\n        } else if (foundTestnetNetwork) {\n          testnetNetworks.forEach(n => (n.isDefaultChain = false))\n          foundTestnetNetwork.isDefaultChain = true\n          networks = testnetNetworks\n        }\n      } else {\n        throw new Error(`unable to set default network as chain '${defaultChainId}' does not exist`)\n      }\n    } else {\n      networks = mainnetNetworks\n    }\n\n    // assign while validating network list\n    // TODO - we should remove sortNetworks in the future but this is a breaking change\n    this.options.networks = ensureValidNetworks(sortNetworks(networks))\n\n    // Account/wallet instances using the initial configuration and network list\n    //\n    // TODO: we can make an optimization where if mainnetNetworks and testnetNetworks lists\n    // haven't changed between calls, and only the defaultChainId, as well, the group between\n    // mainnet vs testnet has not changed either -- aka just defaultChainId within a group,\n    // then we can avoid rebuilding all of these objects and instead just sort them\n    this._wallets = this.options.networks.map(network => {\n      const wallet = new Wallet(\n        {\n          config: this.options.initialConfig,\n          context: this.options.context\n        },\n        ...this._signers\n      )\n\n      if (network.provider) {\n        wallet.setProvider(network.provider, network.chainId)\n      } else if (network.rpcUrl && network.rpcUrl !== '') {\n        wallet.setProvider(network.rpcUrl, network.chainId)\n      } else {\n        throw new Error(`network config is missing provider settings for chainId ${network.chainId}`)\n      }\n\n      if (isRelayer(network.relayer)) {\n        wallet.setRelayer(network.relayer)\n      } else if (isRpcRelayerOptions(network.relayer)) {\n        wallet.setRelayer(new RpcRelayer({ provider: wallet.provider, ...network.relayer }))\n      } else {\n        throw new Error(`network config is missing relayer settings for chainId ${network.chainId}`)\n      }\n\n      if (network.isDefaultChain) {\n        this._chainId = network.chainId\n        this.provider = wallet.provider\n      }\n      return {\n        network: network,\n        wallet: wallet\n      }\n    })\n\n    // return the default chain id as number\n    return this.options.networks.find(network => network.isDefaultChain)!.chainId\n  }\n\n  connect(_: providers.Provider): AbstractSigner {\n    throw new Error('connect method is not supported in MultiWallet')\n  }\n\n  signTransaction(_: utils.Deferrable<providers.TransactionRequest>): Promise<string> {\n    throw new Error('signTransaction method is not supported in MultiWallet, please use signTransactions(...)')\n  }\n}\n","import { ethers, providers } from 'ethers'\nimport { WalletContext } from '@0xsequence/network'\nimport { walletContracts } from '@0xsequence/abi'\nimport { packMessageData } from '@0xsequence/utils'\nimport { isDecodedEOASigner, isDecodedFullSigner, decodeSignature, compareAddr, addressOf } from '@0xsequence/config'\nimport { recoverConfigFromDigest } from './config'\n\nexport async function isValidSignature(\n  address: string,\n  digest: Uint8Array,\n  sig: string,\n  provider?: providers.Provider,\n  walletContext?: WalletContext,\n  chainId?: number\n): Promise<boolean> {\n  // Check if valid EOA signature\n  //\n  // TODO: the EOA check here assume its being passed a digest, but its not a correct assumption\n  // as often the message signing is of a string of text and not a digest.\n  if (\n    isValidEIP712Signature(address, digest, sig) ||\n    isValidEthSignSignature(address, digest, sig)\n  ) return true\n\n  // Check if valid deployed smart wallet (via erc1271 check)\n  const erc1271Check = await isValidContractWalletSignature(address, digest, sig, provider)\n\n  if (erc1271Check === undefined) {\n    // If validity of wallet signature can't be determined\n    // it could be a signature of a non-deployed sequence wallet\n    return !!(await isValidSequenceUndeployedWalletSignature(address, digest, sig, walletContext, provider, chainId))\n  }\n\n  return erc1271Check  \n}\n\nexport function isValidEIP712Signature(\n  address: string,\n  digest: Uint8Array,\n  sig: string\n): boolean {\n  try {\n    return compareAddr(\n      ethers.utils.recoverAddress(\n        digest,\n        ethers.utils.splitSignature(sig)\n      ),\n      address\n    ) === 0\n  } catch {\n    return false\n  }\n}\n\nexport function isValidEthSignSignature(\n  address: string,\n  digest: Uint8Array,\n  sig: string\n): boolean {\n  try {\n    const subDigest = ethers.utils.keccak256(\n      ethers.utils.solidityPack(\n        ['string', 'bytes32'],\n        ['\\x19Ethereum Signed Message:\\n32', digest]\n      )\n    )\n    return compareAddr(\n      ethers.utils.recoverAddress(\n        subDigest,\n        ethers.utils.splitSignature(sig)\n      ),\n      address\n    ) === 0\n  } catch {\n    return false\n  }\n}\n\n// Check if valid Smart Contract Wallet signature, via ERC1271\nexport async function isValidContractWalletSignature(\n  address: string,\n  digest: Uint8Array,\n  sig: string,\n  provider?: providers.Provider\n) {\n  if (!provider) return undefined\n  try {\n    if ((await provider.getCode(address)) === '0x') {\n      // Signature validity can't be determined\n      return undefined\n    }\n\n    const wallet = new ethers.Contract(address, walletContracts.erc1271.abi, provider)\n    const response = await wallet.isValidSignature(digest, sig)\n    return walletContracts.erc1271.returns.isValidSignatureBytes32 === response\n  } catch {\n    return false\n  }\n}\n\nexport async function isValidSequenceUndeployedWalletSignature(\n  address: string,\n  digest: Uint8Array,\n  sig: string,\n  walletContext?: WalletContext,\n  provider?: providers.Provider,\n  chainId?: number\n) {\n  if (!provider && !chainId) return undefined // Signature validity can't be determined\n  if (!walletContext) return undefined // Signature validity can't be determined\n\n  try {\n    const cid = chainId ? chainId : (await provider!.getNetwork()).chainId\n    const signature = decodeSignature(sig)\n    const subDigest = ethers.utils.arrayify(ethers.utils.keccak256(packMessageData(address, cid, digest)))\n    const config = await recoverConfigFromDigest(subDigest, signature, provider, walletContext, chainId, true)\n    const weight = signature.signers.reduce((v, s) => isDecodedEOASigner(s) || isDecodedFullSigner(s) ? v + s.weight : v, 0)\n    return compareAddr(addressOf(config, walletContext), address) === 0 && weight >= signature.threshold\n  } catch {\n    return false\n  }\n}\n","import { WalletConfig, DecodedSignature, isDecodedEOASigner, isDecodedFullSigner, isDecodedAddress, decodeSignature, recoverEOASigner } from '@0xsequence/config'\nimport { BytesLike, ethers, Contract } from 'ethers'\nimport { Signer } from './signer'\nimport { walletContracts } from '@0xsequence/abi'\nimport { isValidSignature } from './validate'\nimport { WalletContext } from '@0xsequence/network'\n\nexport interface DecodedOwner {\n  weight: number\n  address: string\n}\n\nexport interface DecodedSigner {\n  r: string\n  s: string\n  v: number\n  t: number\n  weight: number\n}\n\nexport const fetchImageHash = async (signer: Signer): Promise<string> => {\n  const address = await signer.getAddress()\n  const walletContract = new Contract(address, walletContracts.mainModuleUpgradable.abi, await signer.getProvider())\n  const currentImageHash = await (walletContract.functions.imageHash.call([]).catch(() => []))  as string[]\n  return currentImageHash && currentImageHash.length > 0 ? currentImageHash[0] : ''\n}\n\n// recoverConfig decodes a WalletConfig from the subDigest and signature combo. Note: the subDigest argument\n// is an encoding format of the original message, encoded by:\n//\n// subDigest = packMessageData(wallet.address, chainId, ethers.utils.keccak256(message))\nexport const recoverConfig = async (\n  subDigest:\n  BytesLike,\n  signature: string | DecodedSignature,\n  provider?: ethers.providers.Provider,\n  context?: WalletContext,\n  chainId?: number,\n  walletSignersValidation?: boolean\n): Promise<WalletConfig> => {\n  const digest = ethers.utils.arrayify(ethers.utils.keccak256(subDigest))\n  return recoverConfigFromDigest(digest, signature, provider, context, chainId, walletSignersValidation)\n}\n\n// recoverConfigFromDigest decodes a WalletConfig from a digest and signature combo. Note: the digest\n// is the keccak256 of the subDigest, see `recoverConfig` method.\nexport const recoverConfigFromDigest = async (\n  digest: BytesLike,\n  signature: string | DecodedSignature,\n  provider?: ethers.providers.Provider,\n  context?: WalletContext,\n  chainId?: number,\n  walletSignersValidation?: boolean\n): Promise<WalletConfig> => {\n  const decoded = (<DecodedSignature>signature).threshold !== undefined ? <DecodedSignature>signature : decodeSignature(signature as string)\n\n  const signers = await Promise.all(decoded.signers.map(async (s) => {\n    if (isDecodedEOASigner(s)) {\n      return {\n        weight: s.weight,\n        address: recoverEOASigner(digest, s)\n      }\n    } else if (isDecodedAddress(s)) {\n      return {\n        weight: s.weight,\n        address: ethers.utils.getAddress((<DecodedOwner>s).address)\n      }\n    } else if (isDecodedFullSigner(s)) {\n      if (walletSignersValidation) {\n        if (!(await isValidSignature(\n          s.address,\n          ethers.utils.arrayify(digest),\n          ethers.utils.hexlify(s.signature),\n          provider,\n          context,\n          chainId\n        ))) throw Error('Invalid signature')\n      }\n\n      return {\n        weight: s.weight,\n        address: s.address\n      }\n    } else {\n      throw Error('Uknown signature type')\n    }\n  }))\n\n  return {\n    threshold: decoded.threshold,\n    signers: signers\n  }\n}\n","import { SequenceAPIClient } from '@0xsequence/api'\nimport {\n  ConfigFinder,\n  SequenceUtilsFinder,\n  WalletConfig,\n  decodeSignature,\n  editConfig,\n  genConfig,\n  isDecodedSigner\n} from '@0xsequence/config'\nimport { ETHAuth, Proof } from '@0xsequence/ethauth'\nimport { Indexer, SequenceIndexerClient } from '@0xsequence/indexer'\nimport { SequenceMetadataClient } from '@0xsequence/metadata'\nimport { ChainIdLike, NetworkConfig, WalletContext, findNetworkConfig, getAuthNetwork, JsonRpcProvider } from '@0xsequence/network'\nimport { jwtDecodeClaims } from '@0xsequence/utils'\nimport { Account } from '@0xsequence/wallet'\nimport { ethers, Signer as AbstractSigner } from 'ethers'\n\nexport type SessionMeta = {\n  // name of the app requesting the session, used with ETHAuth\n  name: string\n\n  // expiration in seconds for a session before it expires, used with ETHAuth\n  expiration?: number\n}\n\nexport type SessionJWT = {\n  token: string\n  expiration: number\n}\n\ntype SessionJWTPromise = {\n  token: Promise<string>\n  expiration: number\n}\n\ntype ProofStringPromise = {\n  proofString: Promise<string>\n  expiration: number\n}\n\nexport interface SessionDump {\n  config: WalletConfig\n  context: WalletContext\n  jwt?: SessionJWT\n  metadata: SessionMeta\n}\n\n// Default session expiration of ETHAuth token (1 week)\nexport const DEFAULT_SESSION_EXPIRATION = 60 * 60 * 24 * 7\n\n// Long session expiration of ETHAuth token (~1 year)\nexport const LONG_SESSION_EXPIRATION = 3e7\n\nconst EXPIRATION_JWT_MARGIN = 60 // seconds\n\nexport class Session {\n  _initialAuthRequest: Promise<SequenceAPIClient>\n\n  _jwt: SessionJWTPromise | undefined\n\n  // proof strings are indexed by account address and app name, see getProofStringKey()\n  private readonly proofStrings: Map<string, ProofStringPromise> = new Map()\n\n  private onAuthCallbacks: ((result: PromiseSettledResult<void>) => void)[] = []\n\n  private apiClient: SequenceAPIClient | undefined\n  private metadataClient: SequenceMetadataClient | undefined\n  private indexerClients: Map<number, Indexer> = new Map()\n\n  constructor(\n    public sequenceApiUrl: string,\n    public sequenceMetadataUrl: string,\n    private networks: NetworkConfig[],\n    public config: WalletConfig,\n    public context: WalletContext,\n    public account: Account,\n    public metadata: SessionMeta,\n    private readonly authProvider: ethers.providers.JsonRpcProvider,\n    jwt?: SessionJWT\n  ) {\n    if (jwt) {\n      this._jwt = {\n        token: Promise.resolve(jwt.token),\n        expiration: jwt.expiration ?? getJWTExpiration(jwt.token)\n      }\n    }\n  }\n\n  get name(): string {\n    return this.metadata.name\n  }\n\n  get expiration(): number {\n    return this.metadata.expiration ? Math.max(this.metadata.expiration, 120) : DEFAULT_SESSION_EXPIRATION\n  }\n\n  onAuth(cb: (result: PromiseSettledResult<void>) => void) {\n    this.onAuthCallbacks.push(cb)\n  }\n\n  setAccount(account: Account) {\n    this.account = account\n  }\n\n  setConfig(config: WalletConfig) {\n    this.config = config\n  }\n\n  async auth(maxTries: number = 5): Promise<SequenceAPIClient> {\n    const url = this.sequenceApiUrl\n    if (!url) throw Error('No sequence api url')\n\n    let jwtAuth: string | undefined\n    for (let i = 0; ; i++) {\n      try {\n        jwtAuth = (await this.getJWT(true)).token\n        break\n      } catch (error) {\n        if (i === maxTries - 1) {\n          console.error(`couldn't authenticate after ${maxTries} attempts`, error)\n          throw error\n        }\n      }\n    }\n\n    return new SequenceAPIClient(url, jwtAuth)\n  }\n\n  get isTestnetMode(): boolean | undefined {\n    if (!this.networks || this.networks.length === 0) return\n    return !!this.networks[0].testnet\n  }\n\n  async getAPIClient(tryAuth: boolean = true): Promise<SequenceAPIClient> {\n    if (!this.apiClient) {\n      const url = this.sequenceApiUrl\n      if (!url) throw Error('No chaind url')\n\n      const jwtAuth = (await this.getJWT(tryAuth)).token\n      this.apiClient = new SequenceAPIClient(url, jwtAuth)\n    }\n\n    return this.apiClient\n  }\n\n  getMetadataClient(): SequenceMetadataClient {\n    if (!this.metadataClient) {\n      this.metadataClient = new SequenceMetadataClient(this.sequenceMetadataUrl)\n    }\n\n    return this.metadataClient\n  }\n\n  async getIndexerClient(chainId: ChainIdLike): Promise<Indexer> {\n    const network = findNetworkConfig(this.networks, chainId)\n    if (!network) {\n      throw Error(`No network for chain ${chainId}`)\n    }\n\n    const jwtAuth = (await this.getJWT(true)).token\n\n    if (!this.indexerClients.has(network.chainId)) {\n      if (network.indexer) {\n        this.indexerClients.set(network.chainId, network.indexer)\n      } else if (network.indexerUrl) {\n        this.indexerClients.set(network.chainId, new SequenceIndexerClient(network.indexerUrl, jwtAuth))\n      } else {\n        throw Error(`No indexer url for chain ${chainId}`)\n      }\n    }\n\n    return this.indexerClients.get(network.chainId)!\n  }\n\n  private async getJWT(tryAuth: boolean): Promise<SessionJWT> {\n    const url = this.sequenceApiUrl\n    if (!url) throw Error('No chaind url')\n\n    // check if we already have or are waiting for a token\n    if (this._jwt) {\n      const jwt = this._jwt\n      const token = await jwt.token\n\n      if (this.now() < jwt.expiration) {\n        return { token, expiration: jwt.expiration }\n      }\n\n      // token expired, delete it and get a new one\n      this._jwt = undefined\n    }\n\n    if (!tryAuth) {\n      throw new Error('no auth token in memory')\n    }\n\n    const proofStringKey = this.getProofStringKey()\n    const { proofString, expiration } = this.getProofString(proofStringKey)\n\n    const jwt = {\n      token: proofString\n        .then(async proofString => {\n          const api = new SequenceAPIClient(url)\n\n          const authResp = await api.getAuthToken({ ewtString: proofString, testnetMode: this.isTestnetMode })\n\n          if (authResp?.status === true && authResp.jwtToken.length !== 0) {\n            return authResp.jwtToken\n          } else {\n            if (!(await this.isProofStringValid(proofString))) {\n              this.proofStrings.delete(proofStringKey)\n            }\n            throw new Error('no auth token from server')\n          }\n        })\n        .catch(reason => {\n          this._jwt = undefined\n          throw reason\n        }),\n      expiration\n    }\n    this._jwt = jwt\n\n    jwt.token\n      .then(() => {\n        this.onAuthCallbacks.forEach(cb => {\n          try {\n            cb({ status: 'fulfilled', value: undefined })\n          } catch {}\n        })\n      })\n      .catch((reason: any) => {\n        this.onAuthCallbacks.forEach(cb => {\n          try {\n            cb({ status: 'rejected', reason })\n          } catch {}\n        })\n      })\n\n    const token = await jwt.token\n    return { token, expiration }\n  }\n\n  private getProofString(key: string): ProofStringPromise {\n    // check if we already have or are waiting for a proof string\n    if (this.proofStrings.has(key)) {\n      const proofString = this.proofStrings.get(key)!\n\n      if (this.now() < proofString.expiration) {\n        return proofString\n      }\n\n      // proof string expired, delete it and make a new one\n      this.proofStrings.delete(key)\n    }\n\n    const proof = new Proof({\n      address: this.account.address\n    })\n    proof.claims.app = this.name\n    if (typeof window === 'object') {\n      proof.claims.ogn = window.location.origin\n    }\n    proof.setExpiryIn(this.expiration)\n\n    const ethAuth = new ETHAuth()\n    const configFinder = new SequenceUtilsFinder(this.authProvider)\n    const authWallet = this.account.authWallet()\n    const expiration = this.now() + this.expiration - EXPIRATION_JWT_MARGIN\n\n    const proofString = {\n      // Fetch latest config\n      // TODO: Should only search for latest config if necessary to be more efficient.\n      //       Perhaps compare local config hash with on-chain hash before doing\n      //       the search through the logs. Should do this accross sequence.js\n      proofString: configFinder\n        .findCurrentConfig({\n          address: authWallet.wallet.address,\n          provider: this.authProvider,\n          context: authWallet.wallet.context,\n          knownConfigs: [authWallet.wallet.config]\n        })\n        .then(val => {\n          if (!val.config) throw Error(\"Can't find latest config\")\n          return authWallet.wallet\n            .useConfig(val.config!)\n            .sign(proof.messageDigest())\n            .then(signature => {\n              const decodedSignature = decodeSignature(signature)\n              const totalWeight = decodedSignature.signers.filter(isDecodedSigner).reduce((totalWeight, signer) => totalWeight + signer.weight, 0)\n              if (totalWeight < decodedSignature.threshold) {\n                throw Error(`insufficient signing power, need ${decodedSignature.threshold}, have ${totalWeight}`)\n              }\n\n              proof.signature = signature\n              return ethAuth.encodeProof(proof, true)\n            })\n        })\n        .catch(reason => {\n          this.proofStrings.delete(key)\n          throw reason\n        }),\n      expiration\n    }\n    this.proofStrings.set(key, proofString)\n    return proofString\n  }\n\n  private getProofStringKey(): string {\n    return `${this.account.address} - ${this.name}`\n  }\n\n  private async isProofStringValid(proofString: string): Promise<boolean> {\n    try {\n      const ethAuth = new ETHAuth()\n      ethAuth.provider = this.authProvider\n\n      await ethAuth.decodeProof(proofString)\n\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  async dump(): Promise<SessionDump> {\n    let jwt: SessionJWT | undefined\n    if (this._jwt) {\n      try {\n        const expiration = this._jwt.expiration\n        jwt = { token: await this._jwt.token, expiration }\n      } catch {}\n    }\n\n    return {\n      config: this.config,\n      context: this.context,\n      metadata: this.metadata,\n      jwt\n    }\n  }\n\n  private now(): number {\n    return Math.floor(new Date().getTime() / 1000)\n  }\n\n  static async open(args: {\n    sequenceApiUrl: string\n    sequenceMetadataUrl: string\n    context: WalletContext\n    networks: NetworkConfig[]\n    referenceSigner: string\n    signers: { signer: AbstractSigner | string; weight: ethers.BigNumberish }[]\n    threshold: ethers.BigNumberish\n    metadata: SessionMeta\n    deepSearch?: boolean\n    knownConfigs?: WalletConfig[]\n    noIndex?: boolean\n    configFinder?: ConfigFinder\n  }): Promise<Session> {\n    const {\n      sequenceApiUrl,\n      sequenceMetadataUrl,\n      context,\n      networks,\n      referenceSigner,\n      signers,\n      threshold,\n      deepSearch,\n      knownConfigs,\n      noIndex,\n      metadata\n    } = args\n\n    const authProvider = getAuthProvider(networks)\n    const configFinder = args.configFinder ? args.configFinder : new SequenceUtilsFinder(authProvider)\n\n    const solvedSigners = Promise.all(\n      signers.map(async s => ({ ...s, address: typeof s.signer === 'string' ? s.signer : await s.signer.getAddress() }))\n    )\n\n    const fullSigners = signers.filter(s => typeof s.signer !== 'string').map(s => s.signer)\n\n    const existingWallet = (\n      await configFinder.findLastWalletOfInitialSigner({\n        signer: referenceSigner,\n        context: context,\n        provider: authProvider,\n        requireIndex: deepSearch ? false : true\n      })\n    ).wallet\n\n    if (existingWallet) {\n      // existing account\n\n      // Find prev configuration\n      const config = (\n        await configFinder.findCurrentConfig({\n          address: existingWallet,\n          provider: authProvider,\n          context: context,\n          knownConfigs\n        })\n      ).config\n\n      if (!config) throw Error('Wallet config not found')\n\n      // Load prev account\n      const account = new Account(\n        {\n          initialConfig: config,\n          networks: networks,\n          context: context\n        },\n        ...fullSigners\n      )\n\n      const session = new Session(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider)\n\n      // Update wallet config on-chain on the authChain\n      const [newConfig] = await account.updateConfig(\n        editConfig(config, { threshold, set: await solvedSigners }),\n        noIndex ? false : true\n      )\n\n      // Session is ready, lets update\n      session.setConfig(newConfig)\n      session.setAccount(\n        new Account(\n          {\n            initialConfig: newConfig,\n            networks: networks,\n            context: context\n          },\n          ...fullSigners\n        )\n      )\n\n      if (sequenceApiUrl) {\n        // Fire JWT requests after updating config\n        session._initialAuthRequest = session.auth()\n      } else {\n        session._initialAuthRequest = Promise.reject('no sequence api url')\n      }\n\n      return session\n    } else {\n      // fresh account\n      const config = genConfig(threshold, await solvedSigners)\n\n      const account = new Account(\n        {\n          initialConfig: config,\n          networks: networks,\n          context: context\n        },\n        ...fullSigners\n      )\n\n      // send referenceSigner as \"requireFreshSigners\"\n      // this ensures the user doesn't end up with multiple accounts if there is a race condition during login\n\n      await account.publishConfig(noIndex ? false : true, [referenceSigner])\n\n      const session = new Session(sequenceApiUrl, sequenceMetadataUrl, networks, config, context, account, metadata, authProvider)\n\n      if (sequenceApiUrl) {\n        // Fire JWT requests when opening session\n        session._initialAuthRequest = session.auth()\n      } else {\n        session._initialAuthRequest = Promise.reject('no sequence api url')\n      }\n\n      return session\n    }\n  }\n\n  static load(args: {\n    sequenceApiUrl: string\n    sequenceMetadataUrl: string\n    dump: SessionDump\n    signers: AbstractSigner[]\n    networks: NetworkConfig[]\n  }): Session {\n    const { sequenceApiUrl, sequenceMetadataUrl, dump, signers, networks } = args\n\n    return new Session(\n      sequenceApiUrl,\n      sequenceMetadataUrl,\n      networks,\n      dump.config,\n      dump.context,\n      new Account(\n        {\n          initialConfig: dump.config,\n          context: dump.context,\n          networks: networks\n        },\n        ...signers\n      ),\n      dump.metadata,\n      getAuthProvider(networks),\n      dump.jwt\n    )\n  }\n}\n\nfunction getAuthProvider(networks: NetworkConfig[]): ethers.providers.JsonRpcProvider {\n  const authChain = getAuthNetwork(networks)\n  if (!authChain) throw Error('Auth chain not found')\n  return authChain.provider ?? new JsonRpcProvider(authChain.rpcUrl!, { chainId: authChain.chainId, blockCache: true })\n}\n\nfunction getJWTExpiration(jwt: string): number {\n  return jwtDecodeClaims<{ exp: number }>(jwt).exp\n}\n","import { ethers } from 'ethers'\nimport { ETHAuth, Proof } from '@0xsequence/ethauth'\nimport { ETHAuthProof } from '@0xsequence/provider'\nimport { DEFAULT_SESSION_EXPIRATION } from './session'\nimport { Signer } from '@0xsequence/wallet'\n\nexport interface AuthorizationOptions {\n  // app name string, ie 'Skyweaver'\n  app?: string\n\n  // origin hostname of encoded in the message, ie. 'play.skyweaver.net'\n  origin?: string\n\n  // expiry in seconds encoded in the message\n  expiry?: number\n}\n\n// signAuthorization will perform an EIP712 typed-data message signing of ETHAuth domain via the provided\n// Signer and authorization options.\nexport const signAuthorization = async (signer: Signer, options: AuthorizationOptions): Promise<ETHAuthProof> => {\n  const chainId = await signer.getChainId()\n\n  const address = ethers.utils.getAddress(await signer.getAddress())\n  if (!address || address === '' || address === '0x') {\n    throw ErrAccountIsRequired\n  }\n\n  const proof = new Proof()\n  proof.address = address\n\n  if (!options || !options.app || options.app === '') {\n    throw new AuthError('authorization options requires app to be set')\n  }\n  proof.claims.app = options.app\n  proof.claims.ogn = options.origin\n\n  proof.setExpiryIn(options.expiry ? Math.max(options.expiry, 200) : DEFAULT_SESSION_EXPIRATION)\n\n  const typedData = proof.messageTypedData()\n  proof.signature = await signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainId)\n\n  const ethAuth = new ETHAuth()\n  const proofString = await ethAuth.encodeProof(proof, true)\n\n  return {\n    typedData,\n    proofString\n  }\n}\n\n// TODO: review......\nexport class AuthError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = 'AuthError'\n  }\n}\n\nexport const ErrAccountIsRequired = new AuthError('auth error: account address is empty')\n","import { ethers } from 'ethers'\nimport { Proof, ValidatorFunc, IsValidSignatureBytes32MagicValue } from '@0xsequence/ethauth'\nimport { sequenceContext, WalletContext } from '@0xsequence/network'\nimport { isValidSequenceUndeployedWalletSignature } from '@0xsequence/wallet'\n\nexport const ValidateSequenceDeployedWalletProof: ValidatorFunc = async (provider: ethers.providers.JsonRpcProvider, chainId: number, proof: Proof): Promise<{ isValid: boolean, address?: string }> => {\n  if (!provider || provider === undefined || chainId === undefined) {\n    return { isValid: false }\n  }\n\n  // Compute eip712 message digest from the proof claims\n  const digest = proof.messageDigest()\n\n  // Early check to ensure the contract wallet has been deployed\n  const walletCode = await provider.getCode(proof.address)\n  if (walletCode === '0x' || walletCode.length <= 2) {\n    throw new Error('ValidateSequenceDeployedWalletProof failed. unable to fetch wallet contract code')\n  }\n\n  // Call EIP-1271 IsValidSignature(bytes32, bytes) method on the deployed wallet. Note: for undeployed\n  // wallets, you will need to implement your own ValidatorFunc with the additional context.\n  const abi = [ 'function isValidSignature(bytes32, bytes) public view returns (bytes4)' ]\n  const contract = new ethers.Contract(proof.address, abi, provider)\n\n  // hash the message digest as required by isValidSignature\n  const isValidSignature = await contract.isValidSignature(digest, ethers.utils.arrayify(proof.signature))\n\n  if (isValidSignature === IsValidSignatureBytes32MagicValue) {\n    return { isValid: true }\n  } else {\n    return { isValid: false }\n  }\n}\n\nexport const ValidateSequenceUndeployedWalletProof = (context?: WalletContext): ValidatorFunc => {\n  return async (\n    provider: ethers.providers.JsonRpcProvider,\n    chainId: number,\n    proof: Proof\n  ): Promise<{ isValid: boolean, address?: string }> => {\n    if (!provider || provider === undefined || chainId === undefined) {\n      return { isValid: false }\n    }\n\n    // The contract must not be deployed\n    const walletCode = ethers.utils.arrayify(await provider.getCode(proof.address))\n    if (walletCode.length !== 0) return { isValid: false }\n\n    // Compute eip712 message digest from the proof claims\n    const message = proof.messageDigest()\n\n    // hash the message digest as required by isValidSignature\n    const digest = ethers.utils.arrayify(ethers.utils.keccak256(message))\n\n    const isValid = await isValidSequenceUndeployedWalletSignature(\n      proof.address,\n      digest,\n      proof.signature,\n      context ? context : sequenceContext,\n      provider,\n      chainId\n    )\n\n    return { isValid: !!isValid }\n  }\n}\n","import { WalletContext } from '@0xsequence/network'\nimport { ethers } from 'ethers'\nimport { WalletConfig } from '..'\n\nexport abstract class ConfigFinder {\n  findCurrentConfig: (args: {\n    address: string\n    provider: ethers.providers.Provider\n    context: WalletContext\n    knownConfigs?: WalletConfig[]\n  }) => Promise<{ config: WalletConfig | undefined }>\n  findLastWalletOfInitialSigner: (args: {\n    signer: string\n    provider: ethers.providers.Provider\n    context: WalletContext\n  }) => Promise<{ wallet?: string | undefined }>\n}\n","import { providers } from 'ethers'\nimport { JsonRpcHandlerFunc, JsonRpcRequest, JsonRpcResponseCallback, JsonRpcMiddlewareHandler } from '../types'\nimport { SignerJsonRpcMethods } from './signing-provider'\nimport { logger } from '@0xsequence/utils'\n\nexport class PublicProvider implements JsonRpcMiddlewareHandler {\n\n  private privateJsonRpcMethods = [\n    'net_version', 'eth_chainId', 'eth_accounts', ...SignerJsonRpcMethods\n  ]\n\n  private provider?: providers.JsonRpcProvider\n  private rpcUrl?: string\n \n  constructor(rpcUrl?: string) {\n    if (rpcUrl) {\n      this.setRpcUrl(rpcUrl)\n    }\n  }\n\n  sendAsyncMiddleware = (next: JsonRpcHandlerFunc) => {\n    return (request: JsonRpcRequest, callback: JsonRpcResponseCallback) => {\n      // When provider is configured, send non-private methods to our local public provider\n      if (this.provider && !this.privateJsonRpcMethods.includes(request.method)) {\n        this.provider.send(request.method, request.params!).then(r => {\n          callback(undefined, {\n            jsonrpc: '2.0',\n            id: request.id!,\n            result: r\n          })\n        }).catch(e => callback(e))\n        return\n      }\n\n      // Continue to next handler\n      logger.debug('[public-provider] sending request to signer window', request.method)\n      next(request, callback)\n    }\n  }\n\n  getRpcUrl() {\n    return this.rpcUrl\n  }\n\n  setRpcUrl(rpcUrl: string) {\n    if (!rpcUrl || rpcUrl === '') {\n      this.rpcUrl = undefined\n      this.provider = undefined\n    } else {\n      this.rpcUrl = rpcUrl\n      // TODO: maybe use @0xsequence/network JsonRpcProvider here instead,\n      // which supports better caching.\n      this.provider = new providers.JsonRpcProvider(rpcUrl)\n    }\n  }\n\n}\n","/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n  var hasOwnProperty= Object.hasOwnProperty;\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  var nextTickSupported= typeof process=='object' && typeof process.nextTick=='function';\n  var symbolsSupported= typeof Symbol==='function';\n  var reflectSupported= typeof Reflect === 'object';\n  var setImmediateSupported= typeof setImmediate === 'function';\n  var _setImmediate= setImmediateSupported ? setImmediate : setTimeout;\n  var ownKeys= symbolsSupported? (reflectSupported && typeof Reflect.ownKeys==='function'? Reflect.ownKeys : function(obj){\n    var arr= Object.getOwnPropertyNames(obj);\n    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));\n    return arr;\n  }) : Object.keys;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n\n      if(conf.maxListeners!==undefined){\n          this._maxListeners= conf.maxListeners;\n      }\n\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this._newListener = conf.newListener);\n      conf.removeListener && (this._removeListener = conf.removeListener);\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function logPossibleMemoryLeak(count, eventName) {\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\n        'leak detected. ' + count + ' listeners added. ' +\n        'Use emitter.setMaxListeners() to increase limit.';\n\n    if(this.verboseMemoryLeak){\n      errorMsg += ' Event name: ' + eventName + '.';\n    }\n\n    if(typeof process !== 'undefined' && process.emitWarning){\n      var e = new Error(errorMsg);\n      e.name = 'MaxListenersExceededWarning';\n      e.emitter = this;\n      e.count = count;\n      process.emitWarning(e);\n    } else {\n      console.error(errorMsg);\n\n      if (console.trace){\n        console.trace();\n      }\n    }\n  }\n\n  var toArray = function (a, b, c) {\n    var n = arguments.length;\n    switch (n) {\n      case 0:\n        return [];\n      case 1:\n        return [a];\n      case 2:\n        return [a, b];\n      case 3:\n        return [a, b, c];\n      default:\n        var arr = new Array(n);\n        while (n--) {\n          arr[n] = arguments[n];\n        }\n        return arr;\n    }\n  };\n\n  function toObject(keys, values) {\n    var obj = {};\n    var key;\n    var len = keys.length;\n    var valuesCount = values ? values.length : 0;\n    for (var i = 0; i < len; i++) {\n      key = keys[i];\n      obj[key] = i < valuesCount ? values[i] : undefined;\n    }\n    return obj;\n  }\n\n  function TargetObserver(emitter, target, options) {\n    this._emitter = emitter;\n    this._target = target;\n    this._listeners = {};\n    this._listenersCount = 0;\n\n    var on, off;\n\n    if (options.on || options.off) {\n      on = options.on;\n      off = options.off;\n    }\n\n    if (target.addEventListener) {\n      on = target.addEventListener;\n      off = target.removeEventListener;\n    } else if (target.addListener) {\n      on = target.addListener;\n      off = target.removeListener;\n    } else if (target.on) {\n      on = target.on;\n      off = target.off;\n    }\n\n    if (!on && !off) {\n      throw Error('target does not implement any known event API');\n    }\n\n    if (typeof on !== 'function') {\n      throw TypeError('on method must be a function');\n    }\n\n    if (typeof off !== 'function') {\n      throw TypeError('off method must be a function');\n    }\n\n    this._on = on;\n    this._off = off;\n\n    var _observers= emitter._observers;\n    if(_observers){\n      _observers.push(this);\n    }else{\n      emitter._observers= [this];\n    }\n  }\n\n  Object.assign(TargetObserver.prototype, {\n    subscribe: function(event, localEvent, reducer){\n      var observer= this;\n      var target= this._target;\n      var emitter= this._emitter;\n      var listeners= this._listeners;\n      var handler= function(){\n        var args= toArray.apply(null, arguments);\n        var eventObj= {\n          data: args,\n          name: localEvent,\n          original: event\n        };\n        if(reducer){\n          var result= reducer.call(target, eventObj);\n          if(result!==false){\n            emitter.emit.apply(emitter, [eventObj.name].concat(args))\n          }\n          return;\n        }\n        emitter.emit.apply(emitter, [localEvent].concat(args));\n      };\n\n\n      if(listeners[event]){\n        throw Error('Event \\'' + event + '\\' is already listening');\n      }\n\n      this._listenersCount++;\n\n      if(emitter._newListener && emitter._removeListener && !observer._onNewListener){\n\n        this._onNewListener = function (_event) {\n          if (_event === localEvent && listeners[event] === null) {\n            listeners[event] = handler;\n            observer._on.call(target, event, handler);\n          }\n        };\n\n        emitter.on('newListener', this._onNewListener);\n\n        this._onRemoveListener= function(_event){\n          if(_event === localEvent && !emitter.hasListeners(_event) && listeners[event]){\n            listeners[event]= null;\n            observer._off.call(target, event, handler);\n          }\n        };\n\n        listeners[event]= null;\n\n        emitter.on('removeListener', this._onRemoveListener);\n      }else{\n        listeners[event]= handler;\n        observer._on.call(target, event, handler);\n      }\n    },\n\n    unsubscribe: function(event){\n      var observer= this;\n      var listeners= this._listeners;\n      var emitter= this._emitter;\n      var handler;\n      var events;\n      var off= this._off;\n      var target= this._target;\n      var i;\n\n      if(event && typeof event!=='string'){\n        throw TypeError('event must be a string');\n      }\n\n      function clearRefs(){\n        if(observer._onNewListener){\n          emitter.off('newListener', observer._onNewListener);\n          emitter.off('removeListener', observer._onRemoveListener);\n          observer._onNewListener= null;\n          observer._onRemoveListener= null;\n        }\n        var index= findTargetIndex.call(emitter, observer);\n        emitter._observers.splice(index, 1);\n      }\n\n      if(event){\n        handler= listeners[event];\n        if(!handler) return;\n        off.call(target, event, handler);\n        delete listeners[event];\n        if(!--this._listenersCount){\n          clearRefs();\n        }\n      }else{\n        events= ownKeys(listeners);\n        i= events.length;\n        while(i-->0){\n          event= events[i];\n          off.call(target, event, listeners[event]);\n        }\n        this._listeners= {};\n        this._listenersCount= 0;\n        clearRefs();\n      }\n    }\n  });\n\n  function resolveOptions(options, schema, reducers, allowUnknown) {\n    var computedOptions = Object.assign({}, schema);\n\n    if (!options) return computedOptions;\n\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object')\n    }\n\n    var keys = Object.keys(options);\n    var length = keys.length;\n    var option, value;\n    var reducer;\n\n    function reject(reason) {\n      throw Error('Invalid \"' + option + '\" option value' + (reason ? '. Reason: ' + reason : ''))\n    }\n\n    for (var i = 0; i < length; i++) {\n      option = keys[i];\n      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n        throw Error('Unknown \"' + option + '\" option');\n      }\n      value = options[option];\n      if (value !== undefined) {\n        reducer = reducers[option];\n        computedOptions[option] = reducer ? reducer(value, reject) : value;\n      }\n    }\n    return computedOptions;\n  }\n\n  function constructorReducer(value, reject) {\n    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {\n      reject('value must be a constructor');\n    }\n    return value;\n  }\n\n  function makeTypeReducer(types) {\n    var message= 'value must be type of ' + types.join('|');\n    var len= types.length;\n    var firstType= types[0];\n    var secondType= types[1];\n\n    if (len === 1) {\n      return function (v, reject) {\n        if (typeof v === firstType) {\n          return v;\n        }\n        reject(message);\n      }\n    }\n\n    if (len === 2) {\n      return function (v, reject) {\n        var kind= typeof v;\n        if (kind === firstType || kind === secondType) return v;\n        reject(message);\n      }\n    }\n\n    return function (v, reject) {\n      var kind = typeof v;\n      var i = len;\n      while (i-- > 0) {\n        if (kind === types[i]) return v;\n      }\n      reject(message);\n    }\n  }\n\n  var functionReducer= makeTypeReducer(['function']);\n\n  var objectFunctionReducer= makeTypeReducer(['object', 'function']);\n\n  function makeCancelablePromise(Promise, executor, options) {\n    var isCancelable;\n    var callbacks;\n    var timer= 0;\n    var subscriptionClosed;\n\n    var promise = new Promise(function (resolve, reject, onCancel) {\n      options= resolveOptions(options, {\n        timeout: 0,\n        overload: false\n      }, {\n        timeout: function(value, reject){\n          value*= 1;\n          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {\n            reject('timeout must be a positive number');\n          }\n          return value;\n        }\n      });\n\n      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';\n\n      function cleanup() {\n        if (callbacks) {\n          callbacks = null;\n        }\n        if (timer) {\n          clearTimeout(timer);\n          timer = 0;\n        }\n      }\n\n      var _resolve= function(value){\n        cleanup();\n        resolve(value);\n      };\n\n      var _reject= function(err){\n        cleanup();\n        reject(err);\n      };\n\n      if (isCancelable) {\n        executor(_resolve, _reject, onCancel);\n      } else {\n        callbacks = [function(reason){\n          _reject(reason || Error('canceled'));\n        }];\n        executor(_resolve, _reject, function (cb) {\n          if (subscriptionClosed) {\n            throw Error('Unable to subscribe on cancel event asynchronously')\n          }\n          if (typeof cb !== 'function') {\n            throw TypeError('onCancel callback must be a function');\n          }\n          callbacks.push(cb);\n        });\n        subscriptionClosed= true;\n      }\n\n      if (options.timeout > 0) {\n        timer= setTimeout(function(){\n          var reason= Error('timeout');\n          reason.code = 'ETIMEDOUT'\n          timer= 0;\n          promise.cancel(reason);\n          reject(reason);\n        }, options.timeout);\n      }\n    });\n\n    if (!isCancelable) {\n      promise.cancel = function (reason) {\n        if (!callbacks) {\n          return;\n        }\n        var length = callbacks.length;\n        for (var i = 1; i < length; i++) {\n          callbacks[i](reason);\n        }\n        // internal callback to reject the promise\n        callbacks[0](reason);\n        callbacks = null;\n      };\n    }\n\n    return promise;\n  }\n\n  function findTargetIndex(observer) {\n    var observers = this._observers;\n    if(!observers){\n      return -1;\n    }\n    var len = observers.length;\n    for (var i = 0; i < len; i++) {\n      if (observers[i]._target === observer) return i;\n    }\n    return -1;\n  }\n\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i, typeLength) {\n    if (!tree) {\n      return null;\n    }\n\n    if (i === 0) {\n      var kind = typeof type;\n      if (kind === 'string') {\n        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;\n        if ((n = type.indexOf(delimiter)) !== -1) {\n          ns = new Array(5);\n          do {\n            ns[l++] = type.slice(j, n);\n            j = n + dl;\n          } while ((n = type.indexOf(delimiter, j)) !== -1);\n\n          ns[l++] = type.slice(j);\n          type = ns;\n          typeLength = l;\n        } else {\n          type = [type];\n          typeLength = 1;\n        }\n      } else if (kind === 'object') {\n        typeLength = type.length;\n      } else {\n        type = [type];\n        typeLength = 1;\n      }\n    }\n\n    var listeners= null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i],\n        nextType = type[i + 1], branches, _listeners;\n\n    if (i === typeLength) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n\n      if(tree._listeners) {\n        if (typeof tree._listeners === 'function') {\n          handlers && handlers.push(tree._listeners);\n          listeners = [tree];\n        } else {\n          handlers && handlers.push.apply(handlers, tree._listeners);\n          listeners = [tree];\n        }\n      }\n    } else {\n\n      if (currentType === '*') {\n        //\n        // If the event emitted is '*' at this part\n        // or there is a concrete match at this patch\n        //\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = (i + 1 === typeLength || (i + 2 === typeLength && nextType === '*'));\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);\n        }\n\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);\n                if (_listeners) {\n                  if (listeners) {\n                    listeners.push.apply(listeners, _listeners);\n                  } else {\n                    listeners = _listeners;\n                  }\n                }\n              }\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            } else if (branch === nextType) {\n              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            }\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (tree[currentType]) {\n        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);\n      }\n    }\n\n      xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1, typeLength);\n    }\n\n    xxTree = tree['**'];\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        branches= ownKeys(xxTree);\n        n= branches.length;\n        while(n-->0){\n          branch= branches[n];\n          if (branch !== '_listeners') {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {'**': isolatedBranch}, i + 1, typeLength);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener, prepend) {\n    var len = 0, j = 0, i, delimiter = this.delimiter, dl= delimiter.length, ns;\n\n    if(typeof type==='string') {\n      if ((i = type.indexOf(delimiter)) !== -1) {\n        ns = new Array(5);\n        do {\n          ns[len++] = type.slice(j, i);\n          j = i + dl;\n        } while ((i = type.indexOf(delimiter, j)) !== -1);\n\n        ns[len++] = type.slice(j);\n      }else{\n        ns= [type];\n        len= 1;\n      }\n    }else{\n      ns= type;\n      len= type.length;\n    }\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    if (len > 1) {\n      for (i = 0; i + 1 < len; i++) {\n        if (ns[i] === '**' && ns[i + 1] === '**') {\n          return;\n        }\n      }\n    }\n\n\n\n    var tree = this.listenerTree, name;\n\n    for (i = 0; i < len; i++) {\n      name = ns[i];\n\n      tree = tree[name] || (tree[name] = {});\n\n      if (i === len - 1) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else {\n          if (typeof tree._listeners === 'function') {\n            tree._listeners = [tree._listeners];\n          }\n\n          if (prepend) {\n            tree._listeners.unshift(listener);\n          } else {\n            tree._listeners.push(listener);\n          }\n\n          if (\n              !tree._listeners.warned &&\n              this._maxListeners > 0 &&\n              tree._listeners.length > this._maxListeners\n          ) {\n            tree._listeners.warned = true;\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n          }\n        }\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function collectTreeEvents(tree, events, root, asArray){\n     var branches= ownKeys(tree);\n     var i= branches.length;\n     var branch, branchName, path;\n     var hasListeners= tree['_listeners'];\n     var isArrayPath;\n\n     while(i-->0){\n         branchName= branches[i];\n\n         branch= tree[branchName];\n\n         if(branchName==='_listeners'){\n             path= root;\n         }else {\n             path = root ? root.concat(branchName) : [branchName];\n         }\n\n         isArrayPath= asArray || typeof branchName==='symbol';\n\n         hasListeners && events.push(isArrayPath? path : path.join(this.delimiter));\n\n         if(typeof branch==='object'){\n             collectTreeEvents.call(this, branch, events, path, isArrayPath);\n         }\n     }\n\n     return events;\n  }\n\n  function recursivelyGarbageCollect(root) {\n    var keys = ownKeys(root);\n    var i= keys.length;\n    var obj, key, flag;\n    while(i-->0){\n      key = keys[i];\n      obj = root[key];\n\n      if(obj){\n          flag= true;\n          if(key !== '_listeners' && !recursivelyGarbageCollect(obj)){\n             delete root[key];\n          }\n      }\n    }\n\n    return flag;\n  }\n\n  function Listener(emitter, event, listener){\n    this.emitter= emitter;\n    this.event= event;\n    this.listener= listener;\n  }\n\n  Listener.prototype.off= function(){\n    this.emitter.off(this.event, this.listener);\n    return this;\n  };\n\n  function setupListener(event, listener, options){\n      if (options === true) {\n        promisify = true;\n      } else if (options === false) {\n        async = true;\n      } else {\n        if (!options || typeof options !== 'object') {\n          throw TypeError('options should be an object or true');\n        }\n        var async = options.async;\n        var promisify = options.promisify;\n        var nextTick = options.nextTick;\n        var objectify = options.objectify;\n      }\n\n      if (async || nextTick || promisify) {\n        var _listener = listener;\n        var _origin = listener._origin || listener;\n\n        if (nextTick && !nextTickSupported) {\n          throw Error('process.nextTick is not supported');\n        }\n\n        if (promisify === undefined) {\n          promisify = listener.constructor.name === 'AsyncFunction';\n        }\n\n        listener = function () {\n          var args = arguments;\n          var context = this;\n          var event = this.event;\n\n          return promisify ? (nextTick ? Promise.resolve() : new Promise(function (resolve) {\n            _setImmediate(resolve);\n          }).then(function () {\n            context.event = event;\n            return _listener.apply(context, args)\n          })) : (nextTick ? process.nextTick : _setImmediate)(function () {\n            context.event = event;\n            _listener.apply(context, args)\n          });\n        };\n\n        listener._async = true;\n        listener._origin = _origin;\n      }\n\n    return [listener, objectify? new Listener(this, event, listener): this];\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this._newListener = false;\n    this._removeListener = false;\n    this.verboseMemoryLeak = false;\n    configure.call(this, conf);\n  }\n\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  EventEmitter.prototype.listenTo= function(target, events, options){\n    if(typeof target!=='object'){\n      throw TypeError('target musts be an object');\n    }\n\n    var emitter= this;\n\n    options = resolveOptions(options, {\n      on: undefined,\n      off: undefined,\n      reducers: undefined\n    }, {\n      on: functionReducer,\n      off: functionReducer,\n      reducers: objectFunctionReducer\n    });\n\n    function listen(events){\n      if(typeof events!=='object'){\n        throw TypeError('events must be an object');\n      }\n\n      var reducers= options.reducers;\n      var index= findTargetIndex.call(emitter, target);\n      var observer;\n\n      if(index===-1){\n        observer= new TargetObserver(emitter, target, options);\n      }else{\n        observer= emitter._observers[index];\n      }\n\n      var keys= ownKeys(events);\n      var len= keys.length;\n      var event;\n      var isSingleReducer= typeof reducers==='function';\n\n      for(var i=0; i<len; i++){\n        event= keys[i];\n        observer.subscribe(\n            event,\n            events[event] || event,\n            isSingleReducer ? reducers : reducers && reducers[event]\n        );\n      }\n    }\n\n    isArray(events)?\n        listen(toObject(events)) :\n        (typeof events==='string'? listen(toObject(events.split(/\\s+/))): listen(events));\n\n    return this;\n  };\n\n  EventEmitter.prototype.stopListeningTo = function (target, event) {\n    var observers = this._observers;\n\n    if(!observers){\n      return false;\n    }\n\n    var i = observers.length;\n    var observer;\n    var matched= false;\n\n    if(target && typeof target!=='object'){\n      throw TypeError('target should be an object');\n    }\n\n    while (i-- > 0) {\n      observer = observers[i];\n      if (!target || observer._target === target) {\n        observer.unsubscribe(event);\n        matched= true;\n      }\n    }\n\n    return matched;\n  };\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    if (n !== undefined) {\n      this._maxListeners = n;\n      if (!this._conf) this._conf = {};\n      this._conf.maxListeners = n;\n    }\n  };\n\n  EventEmitter.prototype.getMaxListeners = function() {\n    return this._maxListeners;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn, options) {\n    return this._once(event, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependOnceListener = function(event, fn, options) {\n    return this._once(event, fn, true, options);\n  };\n\n  EventEmitter.prototype._once = function(event, fn, prepend, options) {\n    return this._many(event, 1, fn, prepend, options);\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, true, options);\n  };\n\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      return fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    return this._on(event, listener, prepend, options);\n  };\n\n  EventEmitter.prototype.emit = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], ns, wildcard= this.wildcard;\n    var args,l,i,j, containsSymbol;\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this, type);\n          break;\n        case 2:\n          handler[i].call(this, type, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, type, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, arguments);\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);\n    } else {\n      handler = this._events[type];\n      if (typeof handler === 'function') {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler.call(this);\n          break;\n        case 2:\n          handler.call(this, arguments[1]);\n          break;\n        case 3:\n          handler.call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          args = new Array(al - 1);\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n          handler.apply(this, args);\n        }\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this);\n          break;\n        case 2:\n          handler[i].call(this, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, args);\n        }\n      }\n      return true;\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return !!this._all;\n  };\n\n  EventEmitter.prototype.emitAsync = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], wildcard= this.wildcard, ns, containsSymbol;\n    var args,l,i,j;\n\n    if (type === 'newListener' && !this._newListener) {\n        if (!this._events.newListener) { return Promise.resolve([false]); }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var promises= [];\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all) {\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(this._all[i].call(this, type));\n          break;\n        case 2:\n          promises.push(this._all[i].call(this, type, arguments[1]));\n          break;\n        case 3:\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(this._all[i].apply(this, arguments));\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      switch (al) {\n      case 1:\n        promises.push(handler.call(this));\n        break;\n      case 2:\n        promises.push(handler.call(this, arguments[1]));\n        break;\n      case 3:\n        promises.push(handler.call(this, arguments[1], arguments[2]));\n        break;\n      default:\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n        promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      handler = handler.slice();\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(handler[i].call(this));\n          break;\n        case 2:\n          promises.push(handler[i].call(this, arguments[1]));\n          break;\n        case 3:\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return Promise.all(promises);\n  };\n\n  EventEmitter.prototype.on = function(type, listener, options) {\n    return this._on(type, listener, false, options);\n  };\n\n  EventEmitter.prototype.prependListener = function(type, listener, options) {\n    return this._on(type, listener, true, options);\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n    return this._onAny(fn, false);\n  };\n\n  EventEmitter.prototype.prependAny = function(fn) {\n    return this._onAny(fn, true);\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype._onAny = function(fn, prepend){\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if (!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    if(prepend){\n      this._all.unshift(fn);\n    }else{\n      this._all.push(fn);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype._on = function(type, listener, prepend, options) {\n    if (typeof type === 'function') {\n      this._onAny(type, listener);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    var returnValue= this, temp;\n\n    if (options !== undefined) {\n      temp = setupListener.call(this, type, listener, options);\n      listener = temp[0];\n      returnValue = temp[1];\n    }\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    if (this._newListener) {\n      this.emit('newListener', type, listener);\n    }\n\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener, prepend);\n      return returnValue;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else {\n      if (typeof this._events[type] === 'function') {\n        // Change to array.\n        this._events[type] = [this._events[type]];\n      }\n\n      // If we've already got an array, just add\n      if(prepend){\n        this._events[type].unshift(listener);\n      }else{\n        this._events[type].push(listener);\n      }\n\n      // Check for listener leak\n      if (\n        !this._events[type].warned &&\n        this._maxListeners > 0 &&\n        this._events[type].length > this._maxListeners\n      ) {\n        this._events[type].warned = true;\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\n      }\n    }\n\n    return returnValue;\n  };\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      if(!leafs) return this;\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n      }\n    }\n\n    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          if (this._removeListener)\n            this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n      if (this._removeListener) {\n        for(i = 0, l = fns.length; i < l; i++)\n          this.emit(\"removeListenerAny\", fns[i]);\n      }\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (type === undefined) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if (this.wildcard) {\n      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;\n      if (!leafs) return this;\n      for (i = 0; i < leafs.length; i++) {\n        leaf = leafs[i];\n        leaf._listeners = null;\n      }\n      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    } else if (this._events) {\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function (type) {\n    var _events = this._events;\n    var keys, listeners, allListeners;\n    var i;\n    var listenerTree;\n\n    if (type === undefined) {\n      if (this.wildcard) {\n        throw Error('event name required for wildcard emitter');\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      keys = ownKeys(_events);\n      i = keys.length;\n      allListeners = [];\n      while (i-- > 0) {\n        listeners = _events[keys[i]];\n        if (typeof listeners === 'function') {\n          allListeners.push(listeners);\n        } else {\n          allListeners.push.apply(allListeners, listeners);\n        }\n      }\n      return allListeners;\n    } else {\n      if (this.wildcard) {\n        listenerTree= this.listenerTree;\n        if(!listenerTree) return [];\n        var handlers = [];\n        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n        searchListenerTree.call(this, handlers, ns, listenerTree, 0);\n        return handlers;\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      listeners = _events[type];\n\n      if (!listeners) {\n        return [];\n      }\n      return typeof listeners === 'function' ? [listeners] : listeners;\n    }\n  };\n\n  EventEmitter.prototype.eventNames = function(nsAsArray){\n    var _events= this._events;\n    return this.wildcard? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : (_events? ownKeys(_events) : []);\n  };\n\n  EventEmitter.prototype.listenerCount = function(type) {\n    return this.listeners(type).length;\n  };\n\n  EventEmitter.prototype.hasListeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers.length > 0;\n    }\n\n    var _events = this._events;\n    var _all = this._all;\n\n    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  EventEmitter.prototype.waitFor = function (event, options) {\n    var self = this;\n    var type = typeof options;\n    if (type === 'number') {\n      options = {timeout: options};\n    } else if (type === 'function') {\n      options = {filter: options};\n    }\n\n    options= resolveOptions(options, {\n      timeout: 0,\n      filter: undefined,\n      handleError: false,\n      Promise: Promise,\n      overload: false\n    }, {\n      filter: functionReducer,\n      Promise: constructorReducer\n    });\n\n    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {\n      function listener() {\n        var filter= options.filter;\n        if (filter && !filter.apply(self, arguments)) {\n          return;\n        }\n        self.off(event, listener);\n        if (options.handleError) {\n          var err = arguments[0];\n          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n        } else {\n          resolve(toArray.apply(null, arguments));\n        }\n      }\n\n      onCancel(function(){\n        self.off(event, listener);\n      });\n\n      self._on(event, listener, false);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    })\n  };\n\n  function once(emitter, name, options) {\n    options= resolveOptions(options, {\n      Promise: Promise,\n      timeout: 0,\n      overload: false\n    }, {\n      Promise: constructorReducer\n    });\n\n    var _Promise= options.Promise;\n\n    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){\n      var handler;\n      if (typeof emitter.addEventListener === 'function') {\n        handler=  function () {\n          resolve(toArray.apply(null, arguments));\n        };\n\n        onCancel(function(){\n          emitter.removeEventListener(name, handler);\n        });\n\n        emitter.addEventListener(\n            name,\n            handler,\n            {once: true}\n        );\n        return;\n      }\n\n      var eventListener = function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        resolve(toArray.apply(null, arguments));\n      };\n\n      var errorListener;\n\n      if (name !== 'error') {\n        errorListener = function (err){\n          emitter.removeListener(name, eventListener);\n          reject(err);\n        };\n\n        emitter.once('error', errorListener);\n      }\n\n      onCancel(function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        emitter.removeListener(name, eventListener);\n      });\n\n      emitter.once(name, eventListener);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  }\n\n  var prototype= EventEmitter.prototype;\n\n  Object.defineProperties(EventEmitter, {\n    defaultMaxListeners: {\n      get: function () {\n        return prototype._maxListeners;\n      },\n      set: function (n) {\n        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n          throw TypeError('n must be a non-negative number')\n        }\n        prototype._maxListeners = n;\n      },\n      enumerable: true\n    },\n    once: {\n      value: once,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  Object.defineProperties(prototype, {\n      _maxListeners: {\n          value: defaultMaxListeners,\n          writable: true,\n          configurable: true\n      },\n      _observers: {value: null, writable: true, configurable: true}\n  });\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = EventEmitter;\n  }\n  else {\n    // global for any kind of environment.\n    var _global= new Function('','return this')();\n    _global.EventEmitter2 = EventEmitter;\n  }\n}();\n","import { NetworkConfig, WalletContext, JsonRpcRequest, JsonRpcResponse, JsonRpcHandler } from '@0xsequence/network'\nimport { TypedData } from '@0xsequence/utils'\n\nexport interface ProviderTransport extends JsonRpcHandler, ProviderMessageTransport, ProviderMessageRequestHandler {\n  register(): void\n  unregister(): void\n\n  openWallet(path?: string, intent?: OpenWalletIntent, networkId?: string | number): void\n  closeWallet(): void\n\n  isOpened(): boolean\n  isConnected(): boolean\n\n  on<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]): void\n  once<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]): void\n  emit<K extends keyof ProviderEventTypes>(event: K, ...args: Parameters<ProviderEventTypes[K]>): boolean\n\n  waitUntilOpened(): Promise<WalletSession | undefined>\n  waitUntilConnected(): Promise<ConnectDetails>\n}\n\nexport interface WalletTransport extends JsonRpcHandler, ProviderMessageTransport, ProviderMessageRequestHandler {\n  register(): void\n  unregister(): void\n\n  notifyOpen(openInfo: { chainId?: string; sessionId?: string; session?: WalletSession; error?: string }): void\n  notifyClose(error?: ProviderRpcError): void\n\n  notifyConnect(connectDetails: ConnectDetails): void\n  notifyAccountsChanged(accounts: string[]): void\n  notifyChainChanged(chainIdHex: string): void\n  notifyNetworks(networks: NetworkConfig[]): void\n}\n\nexport interface ProviderMessage<T> {\n  idx: number // message id number\n  type: string // message type\n  data: T // the ethereum json-rpc payload\n  chainId?: number // chain id which the message is intended\n  origin?: string // origin of the message\n}\n\nexport type ProviderMessageRequest = ProviderMessage<JsonRpcRequest>\n\nexport type ProviderMessageResponse = ProviderMessage<JsonRpcResponse>\n\n// ProviderMessageCallback is used to respond to ProviderMessage requests. The error\n// argument is for exceptions during the execution, and response is the response payload\n// which may contain the result or an error payload from the wallet.\nexport type ProviderMessageResponseCallback = (error?: ProviderRpcError, response?: ProviderMessageResponse) => void\n\nexport interface ProviderRpcError extends Error {\n  message: string\n  code?: number\n  data?: { [key: string]: any }\n}\n\nexport interface ProviderMessageRequestHandler {\n  // sendMessageRequest sends a ProviderMessageRequest over the wire to the wallet.\n  // This method is similar to `sendMessage`, but it expects a response to this message.\n  sendMessageRequest(message: ProviderMessageRequest): Promise<ProviderMessageResponse>\n}\n\nexport interface ProviderMessageTransport {\n  // handleMessage will handle a message received from the remote wallet\n  handleMessage(message: ProviderMessage<any>): void\n\n  // sendMessage will send the provider message over the wire\n  sendMessage(message: ProviderMessage<any>): void\n}\n\nexport type WindowSessionParam = 'sid' | 'net' | 'intent'\n\nexport interface WindowSessionParams extends URLSearchParams {\n  get(name: WindowSessionParam): string | null\n  set(name: WindowSessionParam, value: string): void\n}\n\nexport class WindowSessionParams extends URLSearchParams {\n  static new(init?: Record<WindowSessionParam, string> | string) {\n    return new URLSearchParams(init) as WindowSessionParams\n  }\n}\n\nexport interface TransportSession {\n  sessionId?: string | null\n  networkId?: string | number | null\n  intent?: OpenWalletIntent\n}\n\nexport enum EventType {\n  OPEN = 'open',\n  CLOSE = 'close',\n\n  MESSAGE = 'message',\n  CONNECT = 'connect',\n  DISCONNECT = 'disconnect',\n  ACCOUNTS_CHANGED = 'accountsChanged',\n  CHAIN_CHANGED = 'chainChanged',\n\n  NETWORKS = 'networks',\n  WALLET_CONTEXT = 'walletContext',\n\n  INIT = 'init',\n  DEBUG = '_debug'\n}\n\nexport interface WalletEventTypes {\n  open: (openInfo: { chainId?: string; sessionId?: string; session?: WalletSession; error?: string }) => void\n  close: (error?: ProviderRpcError) => void\n\n  connect: (connectDetails: ConnectDetails) => void\n  disconnect: (error?: ProviderRpcError) => void\n\n  accountsChanged: (accounts: string[], origin?: string) => void\n  chainChanged: (chainIdHex: string) => void\n\n  networks: (networks: NetworkConfig[]) => void\n  walletContext: (walletContext: WalletContext) => void\n}\n\nexport interface ProviderEventTypes extends WalletEventTypes {\n  message: (message: ProviderMessageResponse) => void\n}\n\nexport enum OpenState {\n  CLOSED = 0,\n  OPENING = 1,\n  OPENED = 2\n}\n\nexport enum InitState {\n  NIL = 0,\n  SENT_NONCE = 1,\n  OK = 2\n}\n\nexport interface ConnectOptions {\n  /** Specifies the default network a dapp would like to connect to. This field\n   * is optional as it can be provided a number of different ways. */\n  networkId?: string | number\n\n  /** app name of the dapp which will be announced to user on connect screen */\n  app?: string\n\n  /** custom protocol for auth redirect (unity/unreal) */\n  appProtocol?: string\n\n  /** origin hint of the dapp's host opening the wallet. This value will automatically\n   * be determined and verified for integrity, and can be omitted. */\n  origin?: string\n\n  /** expiry number (in seconds) to expire connect session. default is 1 week of seconds. */\n  expiry?: number\n\n  /** authorize will perform an ETHAuth eip712 signing and return the proof to the dapp. */\n  authorize?: boolean\n\n  /** askForEmail will prompt to give permission to the dapp to access email address */\n  askForEmail?: boolean\n\n  /** refresh flag will force a full re-connect (ie. disconnect then connect again) */\n  refresh?: boolean\n\n  /** keepWalletOpened will keep the wallet window opened after connecting. The default\n   * is to automatically close the wallet after connecting. */\n  keepWalletOpened?: boolean\n\n  /** Options to further customize the wallet experience. */\n  settings?: Settings\n}\n\n/** Options to further customize the wallet experience. */\nexport interface Settings {\n  /** Specify a wallet theme. `light` and `dark` are the main themes, to use other available\n   * themes, you can use the camel case version of the theme names in the wallet settings.\n   * For example: \"Blue Dark\" on wallet UI can be passed as \"blueDark\".\n   * Note that this setting will not be persisted, use wallet.open with 'openWithOptions' intent\n   * to set when you open the wallet for user. */\n  theme?: ThemeOption\n\n  /** Specify a banner image. This image, if provided, will be displayed on the wallet during\n   * the connect/authorize process */\n  bannerUrl?: string\n\n  /** Specify payment providers to use. If not specified,\n   * all available payment providers will be enabled.\n   * Note that this setting will not be persisted, use wallet.open with 'openWithOptions' intent\n   * to set when you open the wallet for user. */\n  includedPaymentProviders?: PaymentProviderOption[]\n\n  /** Specify a default currency to use with payment providers.\n   * If not specified, the default is USDC.\n   * Note that this setting will not be persisted, use wallet.open with 'openWithOptions' intent\n   * to set when you open the wallet for user. */\n  defaultFundingCurrency?: CurrencyOption\n\n  /** Specify default purchase amount as an integer, for prefilling the funding amount.\n   * If not specified, the default is 100.\n   * Note that this setting will not be persisted, use wallet.open with 'openWithOptions' intent\n   * to set when you open the wallet for user. */\n  defaultPurchaseAmount?: number\n\n  /** If true, lockFundingCurrencyToDefault disables picking any currency provided by payment\n   * providers other than the defaultFundingCurrency.\n   * If false, it allows picking any currency provided by payment providers.\n   * The default is true.\n   * Note that this setting will not be persisted, use wallet.open with 'openWithOptions' intent\n   * to set when you open the wallet for user. */\n  lockFundingCurrencyToDefault?: boolean\n\n  /** Specify an email address to allow user automatically sign in with the email option.\n   * Will be ignored if user is already signed in.\n   */\n  signInWithEmail?: string\n\n  /** Specify which sign in options are allowed.\n   * Will be ignored if user is already signed in.\n   */\n  signInOptions?: SignInOption[]\n\n  /** Specify auxiliary data\n   */\n  aux?: any\n}\n\n/** light and dark are the main themes, to use other themes in wallet settings,\n * you can use the camel case version of the name in the wallet settings.\n * For example: \"Blue Dark\" on wallet UI can be passed as \"blueDark\" */\nexport type ThemeOption = 'light' | 'dark' | string\nexport type PaymentProviderOption = 'moonpay' | 'wyre' | 'ramp'\nexport type CurrencyOption = 'usdc' | 'eth' | 'matic'\nexport type SignInOption = 'email' | 'google' | 'apple' | 'facebook' | 'discord' | 'twitch'\n\nexport interface ConnectDetails {\n  // chainId (in hex) and error are defined by EIP-1193 expected fields\n  chainId?: string\n  error?: string\n\n  // connected flag denotes user-accepted the connect request\n  connected: boolean\n\n  // session include account and network information needed by the dapp wallet provider.\n  session?: WalletSession\n\n  // proof is a signed typedData (EIP-712) payload using ETHAuth domain.\n  // NOTE: the proof is signed to the `authChainId`, as the canonical auth chain.\n  proof?: ETHAuthProof\n\n  // email address provided from wallet to the dapp, as request + accepted\n  // by a user during a connect request\n  email?: string\n}\n\nexport type PromptConnectDetails = Pick<ConnectDetails, 'chainId' | 'error' | 'connected' | 'proof' | 'email'>\n\nexport type OpenWalletIntent =\n  | { type: 'connect'; options?: ConnectOptions }\n  | { type: 'openWithOptions'; options?: ConnectOptions }\n  | { type: 'jsonRpcRequest'; method: string }\n\nexport interface MessageToSign {\n  message?: Uint8Array\n  typedData?: TypedData\n  chainId?: number\n}\n\nexport interface ETHAuthProof {\n  // eip712 typed-data payload for ETHAuth domain as input\n  typedData: TypedData\n\n  // signature encoded in an ETHAuth proof string\n  proofString: string\n}\n\nexport interface WalletSession {\n  // Wallet context\n  walletContext?: WalletContext\n\n  // Account address of the wallet\n  accountAddress?: string\n\n  // Networks in use for the session. The default/dapp network will show\n  // up as the first one in the list as the \"main chain\"\n  networks?: NetworkConfig[]\n\n  // Caching provider responses for things such as account and chainId\n  providerCache?: { [key: string]: any }\n}\n\nexport class ProviderError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = 'ProviderError'\n  }\n}\n\nexport const ErrSignedInRequired = new ProviderError('Wallet is not signed in. Connect a wallet and try again.')\n\n// TODO: lets build some nice error handling tools, prob in /utils ...\n\nexport interface TypedEventEmitter<Events> {\n  addListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  on<E extends keyof Events>(event: E, listener: Events[E]): this\n  once<E extends keyof Events>(event: E, listener: Events[E]): this\n  prependListener<E extends keyof Events>(event: E, listener: Events[E]): this\n  prependOnceListener<E extends keyof Events>(event: E, listener: Events[E]): this\n\n  off<E extends keyof Events>(event: E, listener: Events[E]): this\n  removeAllListeners<E extends keyof Events>(event?: E): this\n  removeListener<E extends keyof Events>(event: E, listener: Events[E]): this\n\n  emit<E extends keyof Events>(event: E, ...args: Arguments<Events[E]>): boolean\n  eventNames(): (keyof Events | string | symbol)[]\n  listeners<E extends keyof Events>(event: E): Function[]\n  listenerCount<E extends keyof Events>(event: E): number\n}\n\ntype Arguments<T> = [T] extends [(...args: infer U) => any] ? U : [T] extends [void] ? [] : [T]\n","import { EventEmitter2 as EventEmitter } from 'eventemitter2'\n\nimport {\n  ProviderTransport,\n  ProviderMessage,\n  ProviderMessageRequest,\n  EventType,\n  ProviderEventTypes,\n  ProviderMessageResponse,\n  ProviderMessageResponseCallback,\n  OpenState,\n  OpenWalletIntent,\n  ConnectDetails,\n  WalletSession,\n  ProviderRpcError,\n  InitState,\n  TypedEventEmitter\n} from '../types'\n\nimport { NetworkConfig, WalletContext, JsonRpcRequest, JsonRpcResponseCallback, JsonRpcResponse } from '@0xsequence/network'\nimport { logger } from '@0xsequence/utils'\nimport { ethers } from 'ethers'\n\nexport const PROVIDER_OPEN_TIMEOUT = 30000 // in ms\n\nlet _messageIdx = 0\n\nexport const nextMessageIdx = () => ++_messageIdx\n\nexport abstract class BaseProviderTransport implements ProviderTransport {\n  protected pendingMessageRequests: ProviderMessageRequest[] = []\n  protected responseCallbacks = new Map<number, ProviderMessageResponseCallback>()\n\n  protected state: OpenState\n  protected confirmationOnly: boolean = false\n  protected events: TypedEventEmitter<ProviderEventTypes> = new EventEmitter() as TypedEventEmitter<ProviderEventTypes>\n\n  protected openPayload: { sessionId?: string; session?: WalletSession } | undefined\n  protected connectPayload: ConnectDetails | undefined\n  protected accountsChangedPayload: { accounts: string[]; origin?: string } | undefined\n  protected networksPayload: NetworkConfig[] | undefined\n  protected walletContextPayload: WalletContext | undefined\n\n  protected _sessionId?: string\n  protected _init: InitState\n  protected _registered: boolean\n\n  constructor() {\n    this.state = OpenState.CLOSED\n    this._registered = false\n    this._init = InitState.NIL\n  }\n\n  get registered(): boolean {\n    return this._registered\n  }\n\n  register() {\n    throw new Error('abstract method')\n  }\n\n  unregister() {\n    throw new Error('abstract method')\n  }\n\n  openWallet(path?: string, intent?: OpenWalletIntent, networkId?: string | number) {\n    throw new Error('abstract method')\n  }\n\n  closeWallet() {\n    throw new Error('abstract method')\n  }\n\n  isOpened(): boolean {\n    return this.registered && this.state === OpenState.OPENED\n  }\n\n  isConnected(): boolean {\n    // if we're registered, and we have the account details, then we are connected\n    const session = this.openPayload?.session\n    return (\n      this.registered &&\n      session !== undefined &&\n      !!session.accountAddress &&\n      session.accountAddress.length === 42 &&\n      !!session.networks &&\n      session.networks.length > 0\n    )\n  }\n\n  sendAsync = async (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n    // here, we receive the message from the dapp provider call\n\n    if (this.state === OpenState.CLOSED) {\n      // flag the wallet to auto-close once user submits input. ie.\n      // prompting to sign a message or transaction\n      this.confirmationOnly = true\n    }\n\n    // open/focus the wallet.\n    // automatically open the wallet when a provider request makes it here.\n    //\n    // NOTE: if we're not signed in, then the provider will fail, users must first connect+sign in.\n    //\n    // TODO: how does this behave with a session has expired?\n    this.openWallet(undefined, { type: 'jsonRpcRequest', method: request.method }, chainId)\n\n    // send message request, await, and then execute callback after receiving the response\n    try {\n      if (!this.isOpened()) {\n        await this.waitUntilOpened() // will throw on timeout\n      }\n\n      const response = await this.sendMessageRequest({\n        idx: nextMessageIdx(),\n        type: EventType.MESSAGE,\n        data: request,\n        chainId: chainId\n      })\n      callback(undefined, response.data)\n    } catch (err) {\n      callback(err)\n    }\n  }\n\n  // handleMessage will handle message received from the remote wallet\n  handleMessage(message: ProviderMessage<any>) {\n    // init incoming for initial handshake with transport.\n    // always respond to INIT messages, e.g. on popup window reload\n    if (message.type === EventType.INIT) {\n      logger.debug('MessageProvider, received INIT message', message)\n      const { nonce } = message.data as { nonce: string }\n      if (!nonce || nonce.length == 0) {\n        logger.error('invalid init nonce')\n        return\n      }\n      this._init = InitState.OK\n      this.sendMessage({\n        idx: -1,\n        type: EventType.INIT,\n        data: {\n          sessionId: this._sessionId,\n          nonce: nonce\n        }\n      })\n    }\n\n    if (this._init !== InitState.OK) {\n      // if provider is not init'd, then we drop any received messages. the only\n      // message we will process is of event type 'init', as our acknowledgement\n      return\n    }\n\n    // message is either a notification, or its a ProviderMessageResponse\n    logger.debug('RECEIVED MESSAGE FROM WALLET', message.idx, message)\n\n    const requestIdx = message.idx\n    const responseCallback = this.responseCallbacks.get(requestIdx)\n    if (requestIdx) {\n      this.responseCallbacks.delete(requestIdx)\n    }\n\n    // OPEN response\n    //\n    // Flip opened flag, and flush the pending queue\n    if (message.type === EventType.OPEN && !this.isOpened()) {\n      if (this._sessionId && this._sessionId !== message.data?.sessionId) {\n        logger.debug('open event received from wallet, but does not match sessionId', this._sessionId)\n        return\n      }\n\n      // check if open error occured due to invalid defaultNetworkId\n      if (message.data?.error) {\n        const err = new Error(`opening wallet failed: received ${message.data?.error}`)\n        logger.error(err)\n        this.close()\n        throw err\n      }\n\n      // success!\n      this.state = OpenState.OPENED\n      this.openPayload = message.data\n      this.events.emit('open', this.openPayload!)\n\n      // flush pending requests when connected\n      if (this.pendingMessageRequests.length !== 0) {\n        const pendingMessageRequests = this.pendingMessageRequests.splice(0, this.pendingMessageRequests.length)\n\n        pendingMessageRequests.forEach(async pendingMessageRequest => {\n          this.sendMessage(pendingMessageRequest)\n        })\n      }\n\n      return\n    }\n\n    // MESSAGE resposne\n    if (message.type === EventType.MESSAGE) {\n      // Require user confirmation, bring up wallet to prompt for input then close\n      // TODO: perhaps apply technique like in multicall to queue messages within\n      // a period of time, then close the window if responseCallbacks is empty, this is better.\n      if (this.confirmationOnly) {\n        setTimeout(() => {\n          if (this.responseCallbacks.size === 0) {\n            this.closeWallet()\n          }\n        }, 500) // TODO: be smarter about timer as we're processing the response callbacks..\n      }\n\n      if (!responseCallback) {\n        // NOTE: this would occur if 'idx' isn't set, which should never happen\n        // or when we register two handler, or duplicate messages with the same idx are sent,\n        // all of which should be prevented prior to getting to this point\n        throw new Error('impossible state')\n      }\n\n      // Callback to original caller\n      if (responseCallback) {\n        this.events.emit('message', message)\n        responseCallback((message as ProviderMessageResponse).data.error, message)\n        return\n      }\n    }\n\n    // ACCOUNTS_CHANGED -- when a user logs in or out\n    if (message.type === EventType.ACCOUNTS_CHANGED) {\n      this.accountsChangedPayload = { accounts: [] }\n      if (message.data && message.data.length > 0) {\n        this.accountsChangedPayload = {\n          accounts: [ethers.utils.getAddress(message.data[0])],\n          origin: message.origin\n        }\n        this.events.emit('accountsChanged', this.accountsChangedPayload.accounts, this.accountsChangedPayload.origin)\n      } else {\n        this.events.emit('accountsChanged', [], message.origin)\n      }\n      return\n    }\n\n    // CHAIN_CHANGED -- when a user changes their default chain\n    if (message.type === EventType.CHAIN_CHANGED) {\n      this.events.emit('chainChanged', message.data)\n      return\n    }\n\n    // NOTIFY NETWORKS -- when a user connects or logs in\n    if (message.type === EventType.NETWORKS) {\n      this.networksPayload = message.data\n      this.events.emit('networks', this.networksPayload!)\n      return\n    }\n\n    // NOTIFY WALLET_CONTEXT -- when a user connects or logs in\n    if (message.type === EventType.WALLET_CONTEXT) {\n      this.walletContextPayload = message.data\n      this.events.emit('walletContext', this.walletContextPayload!)\n      return\n    }\n\n    // NOTIFY CLOSE -- when wallet instructs to close\n    if (message.type === EventType.CLOSE) {\n      if (this.state !== OpenState.CLOSED) {\n        this.close(message.data)\n      }\n    }\n\n    // NOTIFY CONNECT -- when wallet instructs we've connected\n    if (message.type === EventType.CONNECT) {\n      this.connectPayload = message.data\n      this.events.emit('connect', this.connectPayload!)\n    }\n\n    // NOTIFY DISCONNECT -- when wallet instructs to disconnect\n    if (message.type === EventType.DISCONNECT) {\n      if (this.isConnected()) {\n        this.events.emit('disconnect', message.data)\n        this.close()\n      }\n    }\n  }\n\n  // sendMessageRequest sends a ProviderMessageRequest over the wire to the wallet\n  sendMessageRequest = async (message: ProviderMessageRequest): Promise<ProviderMessageResponse> => {\n    return new Promise((resolve, reject) => {\n      if ((!message.idx || message.idx <= 0) && message.type !== 'init') {\n        reject(new Error('message idx not set'))\n      }\n\n      const responseCallback: ProviderMessageResponseCallback = (error: ProviderRpcError, response?: ProviderMessageResponse) => {\n        if (error) {\n          reject(error)\n        } else if (response) {\n          resolve(response)\n        } else {\n          throw new Error('no valid response to return')\n        }\n      }\n\n      const idx = message.idx\n      if (!this.responseCallbacks.get(idx)) {\n        this.responseCallbacks.set(idx, responseCallback)\n      } else {\n        reject(new Error('duplicate message idx, should never happen'))\n      }\n\n      if (!this.isOpened()) {\n        logger.debug('pushing to pending requests', message)\n        this.pendingMessageRequests.push(message)\n      } else {\n        this.sendMessage(message)\n      }\n    })\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    throw new Error('abstract method')\n  }\n\n  on<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    this.events.on(event, fn as any)\n  }\n\n  once<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    this.events.once(event, fn as any)\n  }\n\n  emit<K extends keyof ProviderEventTypes>(event: K, ...args: Parameters<ProviderEventTypes[K]>): boolean {\n    return this.events.emit(event, ...(args as any))\n  }\n\n  waitUntilOpened = async (openTimeout = PROVIDER_OPEN_TIMEOUT): Promise<WalletSession | undefined> => {\n    let opened = false\n    return Promise.race([\n      new Promise<WalletSession | undefined>((_, reject) => {\n        const timeout = setTimeout(() => {\n          clearTimeout(timeout)\n          // only emit close if the timeout wins the race\n          if (!opened) {\n            this.state = OpenState.CLOSED\n            this.events.emit('close', { code: 1005, message: 'opening wallet timed out' } as ProviderRpcError)\n          }\n          reject(new Error('opening wallet timed out'))\n        }, openTimeout)\n      }),\n      new Promise<WalletSession | undefined>(resolve => {\n        if (this.isOpened()) {\n          opened = true\n          resolve(this.openPayload?.session)\n          return\n        }\n        this.events.once('open', (openInfo: { session?: WalletSession }) => {\n          this.openPayload = openInfo\n          opened = true\n          resolve(openInfo.session)\n        })\n      })\n    ])\n  }\n\n  waitUntilConnected = async (): Promise<ConnectDetails> => {\n    await this.waitUntilOpened()\n\n    const connect = new Promise<ConnectDetails>(resolve => {\n      if (this.connectPayload) {\n        resolve(this.connectPayload)\n        return\n      }\n\n      this.events.once('connect', connectDetails => {\n        this.connectPayload = connectDetails\n        resolve(connectDetails)\n      })\n    })\n\n    const closeWallet = new Promise<ConnectDetails>((_, reject) => {\n      this.events.once('close', error => {\n        if (error) {\n          reject(new Error(`wallet closed due to ${JSON.stringify(error)}`))\n        } else {\n          reject(new Error(`user closed the wallet`))\n        }\n      })\n    })\n\n    return Promise.race<ConnectDetails>([connect, closeWallet])\n  }\n\n  protected close(error?: ProviderRpcError) {\n    if (this.state === OpenState.CLOSED) return\n\n    this.state = OpenState.CLOSED\n    this.confirmationOnly = false\n    this._sessionId = undefined\n    logger.info('closing wallet and flushing!')\n\n    // flush pending requests and return error to all callbacks\n    this.pendingMessageRequests.length = 0\n    this.responseCallbacks.forEach(responseCallback => {\n      responseCallback({\n        ...new Error('wallet closed'),\n        code: 4001\n      })\n    })\n    this.responseCallbacks.clear()\n\n    this.connectPayload = undefined\n    this.openPayload = undefined\n    this.accountsChangedPayload = undefined\n    this.networksPayload = undefined\n    this.walletContextPayload = undefined\n\n    this.events.emit('close', error)\n  }\n}\n","import { EventEmitter2 as EventEmitter } from 'eventemitter2'\n\nimport {\n  ProviderMessageRequest,\n  ProviderMessageResponse,\n  ProviderMessageRequestHandler,\n  MessageToSign,\n  ProviderRpcError,\n  ConnectOptions,\n  ConnectDetails,\n  PromptConnectDetails,\n  WalletSession,\n  OpenWalletIntent,\n  ErrSignedInRequired,\n  ProviderEventTypes,\n  TypedEventEmitter\n} from '../types'\n\nimport { BigNumber, ethers, providers } from 'ethers'\n\nimport { NetworkConfig, JsonRpcHandler, JsonRpcRequest, JsonRpcResponseCallback, JsonRpcResponse } from '@0xsequence/network'\nimport { Signer } from '@0xsequence/wallet'\nimport { isSignedTransactions, TransactionRequest } from '@0xsequence/transactions'\nimport { signAuthorization, AuthorizationOptions } from '@0xsequence/auth'\nimport { logger, TypedData } from '@0xsequence/utils'\n\nimport { isWalletUpToDate, prefixEIP191Message } from '../utils'\n\ntype ExternalProvider = providers.ExternalProvider\n\nconst SIGNER_READY_TIMEOUT = 10000\n\nexport interface WalletSignInOptions {\n  connect?: boolean\n  mainnetNetworks?: NetworkConfig[]\n  testnetNetworks?: NetworkConfig[]\n  defaultNetworkId?: string | number\n}\n\nexport class WalletRequestHandler implements ExternalProvider, JsonRpcHandler, ProviderMessageRequestHandler {\n  // signer interface of the wallet. A null value means there is no signer (ie. user not signed in). An undefined\n  // value means the signer state is unknown, usually meaning the wallet app is booting up and initializing. Of course\n  // a Signer value is the actually interface to a signed-in account\n  private signer: Signer | null | undefined\n  private signerReadyCallbacks: Array<() => void> = []\n\n  private prompter: WalletUserPrompter | null\n  private mainnetNetworks: NetworkConfig[]\n  private testnetNetworks: NetworkConfig[]\n\n  private _openIntent?: OpenWalletIntent\n  private _connectOptions?: ConnectOptions\n  private _defaultNetworkId?: string | number\n  private _chainId?: number\n\n  private events: TypedEventEmitter<ProviderEventTypes> = new EventEmitter() as TypedEventEmitter<ProviderEventTypes>\n\n  onConnectOptionsChange: ((connectOptions: ConnectOptions | undefined) => void) | undefined = undefined\n\n  constructor(\n    signer: Signer | null | undefined,\n    prompter: WalletUserPrompter | null,\n    mainnetNetworks: NetworkConfig[],\n    testnetNetworks: NetworkConfig[] = []\n  ) {\n    this.signer = signer\n    this.prompter = prompter\n    this.mainnetNetworks = mainnetNetworks\n    this.testnetNetworks = testnetNetworks\n  }\n\n  async signIn(signer: Signer | null, options: WalletSignInOptions = {}) {\n    this.setSigner(signer)\n\n    const { connect, mainnetNetworks, testnetNetworks, defaultNetworkId } = options\n\n    if (mainnetNetworks && mainnetNetworks.length > 0) {\n      this.mainnetNetworks = mainnetNetworks\n    }\n    if (testnetNetworks && testnetNetworks.length > 0) {\n      this.testnetNetworks = testnetNetworks\n    }\n    if (\n      (!this.mainnetNetworks || this.mainnetNetworks.length === 0) &&\n      (!this.testnetNetworks || this.testnetNetworks.length === 0)\n    ) {\n      throw new Error('signIn failed as network configuration is empty')\n    }\n\n    const networkId = defaultNetworkId || this._defaultNetworkId\n    if (networkId) {\n      if (!(await this.setDefaultNetwork(networkId, false))) {\n        throw new Error(`WalletRequestHandler setup unable to set defaultNetworkId ${networkId}`)\n      }\n    }\n\n    // Optionally, connect the dapp and wallet. In case connectOptions are provided, we will perform\n    // necessary auth request, and then notify the dapp of the 'connect' details.\n    //\n    // NOTE: if a user is signing into a dapp from a fresh state, and and auth request is made\n    // we don't trigger the promptConnect flow, as we consider the user just authenticated\n    // for this dapp, so its safe to authorize in the promptSignInConnect() which will directly\n    // connect after signing in.\n    //\n    // NOTE: signIn can optionally connect and notify dapp at this time for new signIn flows\n    if (connect) {\n      const connectOptions = this._connectOptions\n\n      let connectDetails: ConnectDetails | PromptConnectDetails\n\n      if (this.prompter !== null) {\n        connectDetails = await this.prompter?.promptSignInConnect(connectOptions)\n      } else {\n        connectDetails = await this.connect(connectOptions)\n      }\n\n      this.notifyConnect(connectDetails)\n\n      if (!connectOptions || connectOptions.keepWalletOpened !== true) {\n        this.notifyClose()\n      }\n    }\n  }\n\n  signOut() {\n    // signed out state\n    this.setSigner(null)\n  }\n\n  signerReset() {\n    // resetting signer puts the wallet in an uninitialized state, which requires the app to\n    // re-initiatize and set the signer either as \"null\" (ie. no signer) or \"Signer\" (ie. signed in).\n    this.signer = undefined\n  }\n\n  signerReady(timeout: number = SIGNER_READY_TIMEOUT): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (this.signer !== undefined) {\n        resolve()\n      } else {\n        setTimeout(() => {\n          if (this.signer === undefined) {\n            this.signerReadyCallbacks = []\n            reject(`signerReady timed out`)\n          }\n        }, timeout)\n        this.signerReadyCallbacks.push(resolve)\n      }\n    })\n  }\n\n  async connect(options?: ConnectOptions): Promise<ConnectDetails> {\n    if (!this.signer) {\n      return {\n        connected: false,\n        chainId: '0x0',\n        error: 'unable to connect without signed in account'\n      }\n    }\n\n    const connectDetails: ConnectDetails = {\n      connected: true,\n      chainId: ethers.utils.hexlify(await this.getChainId())\n    }\n\n    if (options && options.authorize) {\n      // Perform ethauth eip712 request and construct the ConnectDetails response\n      // including the auth proof\n      const authOptions: AuthorizationOptions = {\n        app: options.app,\n        origin: options.origin,\n        expiry: options.expiry\n      }\n      // if (typeof(options.authorize) === 'object') {\n      //   authOptions = { ...authOptions, ...options.authorize }\n      // }\n\n      try {\n        connectDetails.proof = await signAuthorization(this.signer, authOptions)\n      } catch (err) {\n        logger.warn(`connect, signAuthorization failed for options: ${JSON.stringify(options)}, due to: ${err.message}`)\n        return {\n          connected: false,\n          chainId: '0x0',\n          error: `signAuthorization failed: ${err.message}`\n        }\n      }\n    }\n\n    // Build session response for connect details\n    connectDetails.session = await this.walletSession()\n\n    return connectDetails\n  }\n\n  promptConnect = async (options?: ConnectOptions): Promise<ConnectDetails> => {\n    if (!options && !this._connectOptions) {\n      // this is an unexpected state and should not happen\n      throw new Error('prompter connect options are empty')\n    }\n\n    if (!this.prompter) {\n      // if prompter is null, we'll auto connect\n      return this.connect(options)\n    }\n\n    const promptConnectDetails = await this.prompter.promptConnect(options || this._connectOptions).catch(_ => {\n      return { connected: false } as ConnectDetails\n    })\n\n    const connectDetails: ConnectDetails = promptConnectDetails\n    if (connectDetails.connected && !connectDetails.session) {\n      connectDetails.session = await this.walletSession()\n    }\n\n    return promptConnectDetails\n  }\n\n  // sendMessageRequest will unwrap the ProviderMessageRequest and send it to the JsonRpcHandler\n  // (aka, the signer in this instance) and then responds with a wrapped response of\n  // ProviderMessageResponse to be sent over the transport\n  sendMessageRequest(message: ProviderMessageRequest): Promise<ProviderMessageResponse> {\n    return new Promise(resolve => {\n      this.sendAsync(\n        message.data,\n        (error: any, response?: JsonRpcResponse) => {\n          // TODO: if response includes data.error, why do we need a separate error argument here?\n\n          const responseMessage: ProviderMessageResponse = {\n            ...message,\n            data: response!\n          }\n\n          // NOTE: we always resolve here, are the sendAsync call will wrap any exceptions\n          // in the error field of the response to ensure we send back to the user\n          resolve(responseMessage)\n        },\n        message.chainId\n      )\n    })\n  }\n\n  // sendAsync implements the JsonRpcHandler interface for sending JsonRpcRequests to the wallet\n  sendAsync = async (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n    const response: JsonRpcResponse = {\n      jsonrpc: '2.0',\n      id: request.id!,\n      result: null\n    }\n\n    await this.getSigner()\n\n    try {\n      // only allow public json rpc method to the provider when user is not logged in, aka signer is not set\n      if ((!this.signer || this.signer === null) && !permittedJsonRpcMethods.includes(request.method)) {\n        // throw new Error(`not logged in. ${request.method} is unavailable`)\n        throw ErrSignedInRequired\n      }\n\n      // wallet signer\n      const signer = this.signer\n      if (!signer) throw new Error('WalletRequestHandler: wallet signer is not configured')\n\n      // fetch the provider for the specific chain, or undefined will select defaultChain\n      const provider = await signer.getProvider(chainId)\n      if (!provider) throw new Error(`WalletRequestHandler: wallet provider is not configured for chainId ${chainId}`)\n\n      switch (request.method) {\n        case 'net_version': {\n          const result = await provider.send('net_version', [])\n          response.result = result\n          break\n        }\n\n        case 'eth_chainId': {\n          const result = await provider.send('eth_chainId', [])\n          response.result = result\n          break\n        }\n\n        case 'eth_accounts': {\n          const walletAddress = await signer.getAddress()\n          response.result = [walletAddress]\n          break\n        }\n\n        case 'eth_getBalance': {\n          const [accountAddress, blockTag] = request.params!\n          const walletBalance = await provider.getBalance(accountAddress, blockTag)\n          response.result = walletBalance.toHexString()\n          break\n        }\n\n        case 'personal_sign':\n        case 'eth_sign': {\n          // note: message from json-rpc input is in hex format\n          let message: any\n\n          // there is a difference in the order of the params:\n          // personal_sign: [data, address]\n          // eth_sign: [address, data]\n          if (request.method === 'personal_sign') {\n            const [data, address] = request.params!\n            message = data\n          } else {\n            const [address, data] = request.params!\n            message = data\n          }\n\n          let sig = ''\n\n          // Message must be prefixed with \"\\x19Ethereum Signed Message:\\n\"\n          // as defined by EIP-191\n          const prefixedMessage = prefixEIP191Message(message)\n\n          // TODO:\n          // if (process.env.TEST_MODE === 'true' && this.prompter === null) {\n          if (this.prompter === null) {\n            // prompter is null, so we'll sign from here\n            sig = await signer.signMessage(prefixedMessage, chainId)\n          } else {\n            const promptResultForDeployment = await this.handleConfirmWalletDeployPrompt(this.prompter, signer, chainId)\n            if (promptResultForDeployment) {\n              sig = await this.prompter.promptSignMessage({ chainId: chainId, message: prefixedMessage }, this.connectOptions)\n            }\n          }\n\n          if (sig && sig.length > 0) {\n            response.result = sig\n          } else {\n            // The user has declined the request when value is null\n            throw new Error('declined by user')\n          }\n          break\n        }\n\n        case 'eth_signTypedData':\n        case 'eth_signTypedData_v4': {\n          // note: signingAddress from json-rpc input is in hex format, and typedDataObject\n          // should be an object, but in some instances may be double string encoded\n          const [signingAddress, typedDataObject] = request.params!\n\n          let typedData: TypedData | undefined = undefined\n          if (typeof typedDataObject === 'string') {\n            try {\n              typedData = JSON.parse(typedDataObject)\n            } catch (e) {}\n          } else {\n            typedData = typedDataObject\n          }\n\n          if (!typedData || !typedData.domain || !typedData.types || !typedData.message) {\n            throw new Error('invalid typedData object')\n          }\n\n          let sig = ''\n\n          if (this.prompter === null) {\n            // prompter is null, so we'll sign from here\n            sig = await signer.signTypedData(typedData.domain, typedData.types, typedData.message, chainId)\n          } else {\n            const promptResultForDeployment = await this.handleConfirmWalletDeployPrompt(this.prompter, signer, chainId)\n            if (promptResultForDeployment) {\n              sig = await this.prompter.promptSignMessage({ chainId: chainId, typedData: typedData }, this.connectOptions)\n            }\n          }\n\n          if (sig && sig.length > 0) {\n            response.result = sig\n          } else {\n            // The user has declined the request when value is null\n            throw new Error('declined by user')\n          }\n          break\n        }\n\n        case 'eth_sendTransaction': {\n          // https://eth.wiki/json-rpc/API#eth_sendtransaction\n          const [transactionParams] = request.params!\n\n          // eth_sendTransaction uses 'gas'\n          // ethers and sequence use 'gasLimit'\n          if ('gas' in transactionParams && transactionParams.gasLimit === undefined) {\n            transactionParams.gasLimit = transactionParams.gas\n            delete transactionParams.gas\n          }\n\n          let txnHash = ''\n          if (this.prompter === null) {\n            // prompter is null, so we'll send from here\n            const txnResponse = await signer.sendTransaction(transactionParams, chainId)\n            txnHash = txnResponse.hash\n          } else {\n            // prompt user to provide the response\n            txnHash = await this.prompter.promptSendTransaction(transactionParams, chainId, this.connectOptions)\n          }\n\n          if (txnHash) {\n            response.result = txnHash\n          } else {\n            // The user has declined the request when value is null\n            throw new Error('declined by user')\n          }\n          break\n        }\n\n        case 'eth_signTransaction': {\n          // https://eth.wiki/json-rpc/API#eth_signTransaction\n          const [transaction] = request.params!\n          const sender = ethers.utils.getAddress(transaction.from)\n\n          if (sender !== (await signer.getAddress())) {\n            throw new Error('sender address does not match wallet')\n          }\n\n          if (this.prompter === null) {\n            // The eth_signTransaction method expects a `string` return value we instead return a `SignedTransactions` object,\n            // this can only be broadcasted using an RPC provider with support for signed Sequence transactions, like this one.\n            //\n            // TODO: verify serializing / transporting the SignedTransaction object works as expected, most likely however\n            // we will want to resolveProperties the bignumber values to hex strings\n            response.result = await signer.signTransactions(transaction, chainId)\n          } else {\n            response.result = await this.prompter.promptSignTransaction(transaction, chainId, this.connectOptions)\n          }\n\n          break\n        }\n\n        case 'eth_sendRawTransaction': {\n          // NOTE: we're not using a prompter here as the transaction is already signed\n          // and would have prompted the user upon signing.\n\n          // https://eth.wiki/json-rpc/API#eth_sendRawTransaction\n          if (isSignedTransactions(request.params![0])) {\n            const txChainId = BigNumber.from(request.params![0].chainId).toNumber()\n            const tx = await (await signer.getRelayer(txChainId))!.relay(request.params![0])\n            response.result = (await tx).hash\n          } else {\n            const tx = await provider.sendTransaction(request.params![0])\n            response.result = tx.hash\n          }\n          break\n        }\n\n        case 'eth_getTransactionCount': {\n          const address = ethers.utils.getAddress(request.params![0] as string)\n          const tag = request.params![1]\n\n          const walletAddress = ethers.utils.getAddress(await signer.getAddress())\n\n          if (address === walletAddress) {\n            const count = await signer.getTransactionCount(tag)\n            response.result = ethers.BigNumber.from(count).toHexString()\n          } else {\n            const count = await provider.getTransactionCount(address, tag)\n            response.result = ethers.BigNumber.from(count).toHexString()\n          }\n          break\n        }\n\n        case 'eth_blockNumber': {\n          response.result = await provider.getBlockNumber()\n          break\n        }\n\n        case 'eth_getBlockByNumber': {\n          response.result = await provider.getBlock(request.params![0] /* , jsonRpcRequest.params[1] */)\n          break\n        }\n\n        case 'eth_getBlockByHash': {\n          response.result = await provider.getBlock(request.params![0] /* , jsonRpcRequest.params[1] */)\n          break\n        }\n\n        case 'eth_getTransactionByHash': {\n          response.result = await provider.getTransaction(request.params![0])\n          break\n        }\n\n        case 'eth_call': {\n          const [transactionObject, blockTag] = request.params!\n          response.result = await provider.call(transactionObject, blockTag)\n          break\n        }\n\n        case 'eth_getCode': {\n          const [contractAddress, blockTag] = request.params!\n          response.result = await provider.getCode(contractAddress, blockTag)\n          break\n        }\n\n        case 'eth_estimateGas': {\n          const [transactionObject] = request.params!\n          response.result = await provider.estimateGas(transactionObject)\n          break\n        }\n\n        case 'eth_gasPrice': {\n          const gasPrice = await provider.getGasPrice()\n          response.result = gasPrice.toHexString()\n          break\n        }\n\n        case 'wallet_switchEthereumChain': {\n          const [switchParams] = request.params!\n          if (!switchParams.chainId || switchParams.chainId.length === 0) {\n            throw new Error('invalid chainId')\n          }\n\n          const chainId = ethers.BigNumber.from(switchParams.chainId)\n\n          const ok = await this.setDefaultNetwork(chainId.toString(), true)\n          if (!ok) {\n            throw new Error(`unable to set chainId ${chainId}`)\n          }\n\n          response.result = null // success\n          break\n        }\n\n        // smart wallet method\n        case 'sequence_getWalletContext': {\n          response.result = await signer.getWalletContext()\n          break\n        }\n\n        // smart wallet method\n        case 'sequence_getWalletConfig': {\n          const [chainId] = request.params!\n          response.result = await signer.getWalletConfig(chainId)\n          break\n        }\n\n        // smart wallet method\n        case 'sequence_getWalletState': {\n          const [chainId] = request.params!\n          response.result = await signer.getWalletState(chainId)\n          break\n        }\n\n        // smart wallet method\n        case 'sequence_getNetworks': {\n          // NOTE: must ensure that the response result below returns clean serialized data, which is to omit\n          // the provider and relayer objects and only return the urls so can be reinstantiated on dapp side.\n          // This is handled by this.getNetworks() but noted here for future readers.\n          response.result = await this.getNetworks(true)\n          break\n        }\n\n        case 'sequence_isSequence': {\n          response.result = true\n          break\n        }\n\n        // smart wallet method\n        case 'sequence_updateConfig': {\n          throw new Error('sequence_updateConfig method is not allowed from a dapp')\n          // NOTE: method is disabled as we don't need a dapp to request to update a config.\n          // However, if we ever want this, we can enable it but must also use the prompter\n          // for confirmation.\n          //\n          // const [newConfig] = request.params\n          // response.result = await signer.updateConfig(newConfig)\n          break\n        }\n\n        // smart wallet method\n        case 'sequence_publishConfig': {\n          throw new Error('sequence_publishConfig method is not allowed from a dapp')\n          break\n        }\n\n        // relayer method\n        case 'sequence_gasRefundOptions': {\n          // TODO\n          break\n        }\n\n        // relayer method\n        case 'sequence_getNonce': {\n          // TODO\n          break\n        }\n\n        // relayer method\n        case 'sequence_relay': {\n          // TODO\n          break\n        }\n\n        // set default network of wallet\n        case 'sequence_setDefaultNetwork': {\n          const [defaultNetworkId] = request.params!\n\n          if (!defaultNetworkId) {\n            throw new Error('invalid request, method argument defaultNetworkId cannot be empty')\n          }\n          const ok = await this.setDefaultNetwork(defaultNetworkId)\n          if (!ok) {\n            throw new Error(`unable to set default network ${defaultNetworkId}`)\n          }\n\n          response.result = await this.getNetworks(true)\n          break\n        }\n\n        default: {\n          // NOTE: provider here will be chain-bound if chainId is provided\n          const providerResponse = await provider.send(request.method, request.params!)\n          response.result = providerResponse\n        }\n      }\n    } catch (err) {\n      logger.error(err)\n\n      // See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md#rpc-errors\n      response.result = null\n      response.error = {\n        ...new Error(err),\n        code: 4001\n      }\n    }\n\n    callback(undefined, response)\n  }\n\n  on<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    this.events.on(event, fn as any)\n  }\n\n  once<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    this.events.once(event, fn as any)\n  }\n\n  async getAddress(): Promise<string> {\n    if (!this.signer) {\n      return ''\n    } else {\n      return this.signer.getAddress()\n    }\n  }\n\n  async getChainId(): Promise<number> {\n    if (!this.signer) {\n      return 0\n    } else {\n      if (this._chainId) return this._chainId // memoized\n      this._chainId = await this.signer.getChainId()\n      return this._chainId\n    }\n  }\n\n  get openIntent(): OpenWalletIntent | undefined {\n    return this._openIntent\n  }\n\n  setOpenIntent(intent: OpenWalletIntent | undefined) {\n    this._openIntent = intent\n  }\n\n  get connectOptions(): ConnectOptions | undefined {\n    return this._connectOptions\n  }\n\n  setConnectOptions(options: ConnectOptions | undefined) {\n    this._connectOptions = options\n\n    this.onConnectOptionsChange?.(options)\n  }\n\n  get defaultNetworkId(): string | number | undefined {\n    return this._defaultNetworkId\n  }\n\n  async setDefaultNetwork(chainId: string | number, notifyNetworks: boolean = true): Promise<number | undefined> {\n    if (!chainId) return undefined\n    this._defaultNetworkId = chainId\n    this._chainId = undefined\n\n    if (this.signer && (<any>this.signer).setNetworks) {\n      const defaultChainId: number = (<any>this.signer).setNetworks(this.mainnetNetworks, this.testnetNetworks, chainId)\n      if (defaultChainId && notifyNetworks) {\n        await this.notifyNetworks()\n      }\n      return defaultChainId\n    } else {\n      return undefined\n    }\n  }\n\n  async getNetworks(jsonRpcResponse?: boolean): Promise<NetworkConfig[]> {\n    if (!this.signer) {\n      logger.warn('signer not set: getNetworks is returning an empty list')\n      return []\n    }\n\n    const networks = await this.signer.getNetworks()\n\n    if (jsonRpcResponse) {\n      // omit provider and relayer objects as they are not serializable\n      return networks.map(n => {\n        const network: NetworkConfig = { ...n }\n        network.provider = undefined\n        network.relayer = undefined\n        return network\n      })\n    } else {\n      return networks\n    }\n  }\n\n  async walletSession(): Promise<WalletSession | undefined> {\n    return !this.signer\n      ? undefined\n      : {\n          walletContext: await this.signer.getWalletContext(),\n          accountAddress: await this.signer.getAddress(),\n          networks: await this.getNetworks(true)\n        }\n  }\n\n  notifyConnect(connectDetails: ConnectDetails, origin?: string) {\n    this.events.emit('connect', connectDetails)\n    if (connectDetails.session?.accountAddress) {\n      this.events.emit('accountsChanged', [connectDetails.session?.accountAddress], origin)\n    }\n  }\n\n  notifyDisconnect(origin?: string) {\n    this.events.emit('accountsChanged', [], origin)\n    this.events.emit('disconnect')\n  }\n\n  async notifyNetworks(networks?: NetworkConfig[]) {\n    const n = networks || (await this.getNetworks(true))\n    this.events.emit('networks', n)\n    if (n.length > 0) {\n      const defaultNetwork = n.find(network => network.isDefaultChain)\n      if (defaultNetwork) {\n        this.events.emit('chainChanged', ethers.utils.hexlify(defaultNetwork.chainId))\n      }\n    } else {\n      this.events.emit('chainChanged', '0x0')\n    }\n  }\n\n  async notifyWalletContext() {\n    if (!this.signer) {\n      logger.warn('signer not set: skipping to notify wallet context')\n      return\n    }\n    const walletContext = await this.signer.getWalletContext()\n    this.events.emit('walletContext', walletContext)\n  }\n\n  notifyClose(error?: ProviderRpcError) {\n    this.events.emit('close', error)\n  }\n\n  isSignedIn = async (): Promise<boolean> => {\n    await this.signerReady()\n    return !!this.signer\n  }\n\n  getSigner = async (): Promise<Signer | null> => {\n    await this.signerReady()\n    if (this.signer === undefined) {\n      throw new Error('signerReady failed resolve')\n    }\n    return this.signer\n  }\n\n  setSigner(signer: Signer | null | undefined) {\n    this.signer = signer\n\n    if (signer !== undefined) {\n      for (let i = 0; i < this.signerReadyCallbacks.length; i++) {\n        this.signerReadyCallbacks[i]()\n      }\n      this.signerReadyCallbacks = []\n    }\n  }\n\n  private async handleConfirmWalletDeployPrompt(\n    prompter: WalletUserPrompter,\n    signer: Signer,\n    chainId?: number\n  ): Promise<boolean> {\n    // check if wallet is deployed and up to date, if not, prompt user to deploy\n    // if no chainId is provided, we'll assume the wallet is auth chain wallet and is up to date\n    if (!chainId) {\n      return true\n    }\n    const isUpToDate = await isWalletUpToDate(signer, chainId)\n    if (isUpToDate) {\n      return true\n    }\n    const promptResult = await prompter.promptConfirmWalletDeploy(chainId, this.connectOptions)\n    // if client returned true, check again to make sure wallet is deployed and up to date\n    if (promptResult) {\n      const isPromptResultCorrect = await isWalletUpToDate(signer, chainId)\n      if (!isPromptResultCorrect) {\n        logger.error('WalletRequestHandler: result for promptConfirmWalletDeploy is not correct')\n        return false\n      } else {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nexport interface WalletUserPrompter {\n  promptConnect(options?: ConnectOptions): Promise<PromptConnectDetails>\n  promptSignInConnect(options?: ConnectOptions): Promise<PromptConnectDetails>\n\n  promptSignMessage(message: MessageToSign, options?: ConnectOptions): Promise<string>\n  promptSignTransaction(txn: TransactionRequest, chaindId?: number, options?: ConnectOptions): Promise<string>\n  promptSendTransaction(txn: TransactionRequest, chaindId?: number, options?: ConnectOptions): Promise<string>\n  promptConfirmWalletDeploy(chainId: number, options?: ConnectOptions): Promise<boolean>\n}\n\nconst permittedJsonRpcMethods = [\n  'net_version',\n  'eth_chainId',\n  'eth_getBalance',\n  'eth_getTransactionCount',\n  'eth_blockNumber',\n  'eth_getBlockByNumber',\n  'eth_getBlockByHash',\n  'eth_getTransactionByHash',\n  'eth_getCode',\n  'eth_estimateGas',\n  'eth_gasPrice',\n\n  'sequence_getWalletContext',\n  'sequence_getNetworks',\n  'sequence_setDefaultNetwork'\n]\n","import { ethers, BytesLike, Bytes, providers, TypedDataDomain, TypedDataField, BigNumber } from 'ethers'\nimport {\n  NetworkConfig,\n  WalletContext,\n  ChainIdLike,\n  JsonRpcHandler,\n  JsonRpcFetchFunc,\n  JsonRpcRequest,\n  JsonRpcResponseCallback,\n  maybeChainId,\n  JsonRpcSender\n} from '@0xsequence/network'\nimport { resolveArrayProperties, Signer } from '@0xsequence/wallet'\nimport { WalletConfig, WalletState } from '@0xsequence/config'\nimport { Relayer } from '@0xsequence/relayer'\nimport { Deferrable, shallowCopy, resolveProperties, Forbid } from '@0xsequence/utils'\nimport { TransactionRequest, TransactionResponse, SignedTransactions } from '@0xsequence/transactions'\nimport { WalletRequestHandler } from './transports/wallet-request-handler'\n\nexport class Web3Provider extends providers.Web3Provider implements JsonRpcHandler {\n  static isSequenceProvider(cand: any): cand is Web3Provider {\n    return isSequenceProvider(cand)\n  }\n\n  readonly _sender: JsonRpcSender\n\n  readonly _isSequenceProvider: boolean\n\n  // defaultChainId is the default chainId to use with requests, but may be\n  // overridden by passing chainId argument to a specific request\n  readonly _defaultChainId?: number\n\n  constructor(provider: providers.JsonRpcProvider | JsonRpcHandler | JsonRpcFetchFunc, defaultChainId?: ChainIdLike) {\n    const sender = new JsonRpcSender(provider, maybeChainId(defaultChainId))\n    provider = sender\n\n    super(provider, 'any')\n\n    this._sender = sender\n    this._isSequenceProvider = true\n    this._defaultChainId = maybeChainId(defaultChainId)\n  }\n\n  sendAsync(\n    request: JsonRpcRequest,\n    callback: JsonRpcResponseCallback | ((error: any, response: any) => void),\n    chainId?: number\n  ) {\n    this._sender.sendAsync(request, callback, chainId)\n  }\n\n  send(method: string, params: Array<any>, chainId?: number): Promise<any> {\n    return this._sender.send(method, params, chainId)\n  }\n\n  request(request: { method: string; params?: Array<any>; chainId?: number }): Promise<any> {\n    return this.send(request.method, request.params || [], request.chainId)\n  }\n\n  getSigner(): Web3Signer {\n    return new Web3Signer(this, this._defaultChainId)\n  }\n\n  async getChainId(): Promise<number> {\n    // TODO: is it safe to memoize this?\n    const result = await this.send('eth_chainId', [])\n    const chainId = ethers.BigNumber.from(result).toNumber()\n\n    if (this._defaultChainId && this._defaultChainId !== chainId) {\n      throw new Error(`provider chainId (${chainId}) does not match provider-bound chainId ${this._defaultChainId}`)\n    }\n\n    return chainId\n  }\n}\n\nexport function isSequenceProvider(provider: any): provider is Web3Provider {\n  const cand = provider as Web3Provider\n  return cand && cand.send !== undefined && cand._isSequenceProvider === true\n}\n\nexport class LocalWeb3Provider extends Web3Provider {\n  constructor(signer: Signer, networks?: NetworkConfig[]) {\n    const walletRequestHandler = new WalletRequestHandler(signer, null, networks || [])\n    super(walletRequestHandler)\n  }\n}\n\n// TODO: in the future with ethers v6 we can remove/change this type name\ninterface TypedDataSigner {\n  _signTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    value: Record<string, any>\n  ): Promise<string>\n}\n\nexport class Web3Signer extends Signer implements TypedDataSigner {\n  readonly provider: Web3Provider\n  readonly defaultChainId?: number\n\n  constructor(provider: Web3Provider, defaultChainId?: number) {\n    super()\n    this.provider = provider\n    this.defaultChainId = defaultChainId\n  }\n\n  // memoized\n  _address: string\n  _index: number\n  _context: WalletContext\n  _networks: NetworkConfig[]\n  private _providers: { [key: number]: Web3Provider } = {}\n\n  //\n  // ethers AbstractSigner methods\n  //\n\n  async getAddress(): Promise<string> {\n    if (this._address) return this._address\n    const accounts = await this.provider.send('eth_accounts', [])\n    this._address = accounts[0]\n    this._index = 0\n    return ethers.utils.getAddress(this._address)\n  }\n\n  signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string> {\n    // TODO .. since ethers isn't using this method, perhaps we will?\n    throw new Error('signTransaction is unsupported, use signTransactions instead')\n  }\n\n  connect(provider: ethers.providers.Provider): ethers.providers.JsonRpcSigner {\n    throw new Error('unsupported: cannot alter JSON-RPC Signer connection')\n  }\n\n  //\n  // Sequence Signer methods\n  //\n\n  // getProvider returns a Web3Provider instance for the current chain. Note that this method\n  // and signer is bound to a particular chain to prevent misuse. If you'd like a provider\n  // for a specific chain, try getSender(chainId), or wallet.getProvider(chainId).\n  async getProvider(chainId?: number): Promise<Web3Provider | undefined> {\n    if (chainId) {\n      const currentChainId = await this.getChainId()\n      if (currentChainId !== chainId) {\n        throw new Error(`signer is attempting to access chain ${chainId}, but is already bound to chain ${currentChainId}`)\n      }\n    }\n    return this.provider\n  }\n\n  // getSender returns a Web3Provider instance via the signer transport. Note: for our case\n  // the of sequence wallet, this will bring up the wallet window whenever using it, as the json-rpc\n  // requests are sent to the window transport. Therefore, for anything non-signing related\n  // you can write a higher-order JsonRpcRouter sender to route to the public provider endpoints\n  // as we do in the WalletProvider.\n  //\n  // This method is primarily utilized internally when routing requests to a particular chainId.\n  async getSender(chainId?: number): Promise<Web3Provider | undefined> {\n    if (!chainId || (chainId && chainId === this.defaultChainId)) {\n      return this.provider\n    }\n    if (!this._providers[chainId]) {\n      this._providers[chainId] = new Web3Provider(new JsonRpcSender(this.provider, chainId), chainId)\n    }\n    return this._providers[chainId]\n  }\n\n  getRelayer(chainId?: number): Promise<Relayer | undefined> {\n    // TODO: JsonRpcRelayer ......? or, Web3Relayer.. or SequenceRelayer?\n    // sequence_gasRefundOptions\n    // sequence_getNonce\n    // sequence_relay\n    throw new Error('TODO')\n  }\n\n  async getWalletContext(): Promise<WalletContext> {\n    if (!this._context) {\n      this._context = await this.provider.send('sequence_getWalletContext', [])\n    }\n    return this._context\n  }\n\n  async getWalletConfig(chainId?: ChainIdLike): Promise<WalletConfig[]> {\n    return await this.provider.send(\n      'sequence_getWalletConfig',\n      [maybeChainId(chainId)],\n      maybeChainId(chainId) || this.defaultChainId\n    )\n  }\n\n  async getWalletState(chainId?: ChainIdLike): Promise<WalletState[]> {\n    return await this.provider.send(\n      'sequence_getWalletState',\n      [maybeChainId(chainId)],\n      maybeChainId(chainId) || this.defaultChainId\n    )\n  }\n\n  async getNetworks(): Promise<NetworkConfig[]> {\n    if (!this._networks) {\n      this._networks = await this.provider.send('sequence_getNetworks', [])\n    }\n    return this._networks\n  }\n\n  async getSigners(): Promise<string[]> {\n    const networks = await this.getNetworks()\n\n    const authChainId = networks.find(n => n.isAuthChain)\n    if (!authChainId) {\n      throw new Error('authChainId could not be determined from network list')\n    }\n\n    const walletConfig = await this.getWalletConfig(authChainId)\n    if (!walletConfig || walletConfig.length === 0) {\n      throw new Error(`walletConfig returned zero results for authChainId {authChainId}`)\n    }\n\n    return walletConfig[0].signers.map(s => s.address)\n  }\n\n  // signMessage matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n  async signMessage(message: BytesLike, chainId?: ChainIdLike, allSigners?: boolean): Promise<string> {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId)\n\n    const data = typeof message === 'string' ? ethers.utils.toUtf8Bytes(message) : message\n    const address = await this.getAddress()\n\n    // NOTE: as of ethers v5.5, it switched to using personal_sign, see\n    // https://github.com/ethers-io/ethers.js/pull/1542 and see\n    // https://github.com/WalletConnect/walletconnect-docs/issues/32 for additional info.\n    return await provider!.send('personal_sign', [ethers.utils.hexlify(data), address])\n  }\n\n  // signTypedData matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n  async signTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    message: Record<string, any>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<string> {\n    // Populate any ENS names (in-place)\n    // const populated = await ethers.utils._TypedDataEncoder.resolveNames(domain, types, message, (name: string) => {\n    //   return this.provider.resolveName(name)\n    // })\n\n    return await this.provider.send(\n      'eth_signTypedData_v4',\n      [await this.getAddress(), ethers.utils._TypedDataEncoder.getPayload(domain, types, message)],\n      maybeChainId(chainId) || this.defaultChainId\n    )\n  }\n\n  // sendTransaction matches implementation from ethers JsonRpcSigner for compatibility, but with\n  // multi-chain support.\n  async sendTransaction(\n    transaction: Deferrable<TransactionRequest>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<TransactionResponse> {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId)\n\n    const tx = this.sendUncheckedTransaction(transaction, chainId).then(hash => {\n      return ethers.utils\n        .poll(\n          () => {\n            return provider!.getTransaction(hash).then((tx: TransactionResponse) => {\n              if (tx === null) {\n                return undefined\n              }\n              return provider!._wrapTransaction(tx, hash)\n            })\n          },\n          { onceBlock: this.provider! }\n        )\n        .catch((error: Error) => {\n          ;(<any>error).transactionHash = hash\n          throw error\n        })\n    })\n\n    // @ts-ignore\n    return tx\n  }\n\n  // sendTransactionBatch is a convenience method to call sendTransaction in a batch format, allowing you to\n  // send multiple transaction as a single payload and just one on-chain transaction.\n  async sendTransactionBatch(\n    transactions: Deferrable<Forbid<TransactionRequest, 'wait'>[]>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<TransactionResponse> {\n    const batch = await resolveArrayProperties<Forbid<TransactionRequest, 'wait'>[]>(transactions)\n    if (!batch || batch.length === 0) {\n      throw new Error('cannot send empty batch')\n    }\n\n    // sendTransactionBatch only accepts TransactionRequest, not TransactionResponses\n    if (batch.find(v => v.wait !== undefined && v.wait !== null)) {\n      throw new Error('transaction request expected for sendTransactionBatch, transaction response found')\n    }\n\n    const tx: TransactionRequest = { ...batch[0] }\n    if (batch.length > 1) {\n      tx.auxiliary = batch.splice(1)\n    }\n\n    return this.sendTransaction(tx, chainId, allSigners)\n  }\n\n  signTransactions(\n    transaction: Deferrable<TransactionRequest>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<SignedTransactions> {\n    transaction = shallowCopy(transaction)\n    // TODO: transaction argument..? make sure to resolve any properties and serialize property before sending over\n    // the wire.. see sendUncheckedTransaction and resolveProperties\n    return this.provider.send('eth_signTransaction', [transaction], maybeChainId(chainId) || this.defaultChainId)\n  }\n\n  sendSignedTransactions(signedTxs: SignedTransactions, chainId?: ChainIdLike): Promise<TransactionResponse> {\n    // sequence_relay\n    throw new Error('TODO')\n  }\n\n  // updateConfig..\n  // NOTE: this is not supported by the remote wallet by default.\n  async updateConfig(newConfig?: WalletConfig): Promise<[WalletConfig, TransactionResponse | undefined]> {\n    // sequence_updateConfig\n    const [config, tx] = await this.provider.send('sequence_updateConfig', [newConfig], this.defaultChainId)\n    if (tx === null) {\n      return [config, undefined]\n    }\n\n    const provider = await this.getSender(this.defaultChainId)\n    return [config, provider!._wrapTransaction(tx, tx.hash)]\n  }\n\n  // publishConfig..\n  // NOTE: this is not supported by the remote wallet by default.\n  async publishConfig(): Promise<TransactionResponse | undefined> {\n    const provider = await this.getSender(this.defaultChainId)\n\n    const tx = await provider!.send('sequence_publishConfig', [])\n    if (tx === null) {\n      return undefined\n    }\n    return provider!._wrapTransaction(tx, tx.hash)\n  }\n\n  async isDeployed(chainId?: ChainIdLike): Promise<boolean> {\n    const provider = await this.getSender(maybeChainId(chainId))\n    const walletCode = await provider!.getCode(await this.getAddress())\n    return !!walletCode && walletCode !== '0x'\n  }\n\n  //\n  // ethers JsonRpcSigner methods\n  //\n\n  async _legacySignMessage(message: Bytes | string, chainId?: ChainIdLike, allSigners?: boolean): Promise<string> {\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId)\n\n    const data = typeof message === 'string' ? ethers.utils.toUtf8Bytes(message) : message\n    const address = await this.getAddress()\n\n    // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n    // NOTE: ethers since 5.5 has switched to using personal_sign, we should review, etc.\n    return await provider!.send('eth_sign', [address, ethers.utils.hexlify(data)])\n  }\n\n  async _signTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    message: Record<string, any>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<string> {\n    return this.signTypedData(domain, types, message, chainId, allSigners)\n  }\n\n  async sendUncheckedTransaction(transaction: Deferrable<TransactionRequest>, chainId?: ChainIdLike): Promise<string> {\n    transaction = shallowCopy(transaction)\n\n    const fromAddress = this.getAddress()\n\n    // NOTE: we do not use provider estimation, and instead rely on our relayer to determine the gasLimit and gasPrice\n    //\n    // TODO: alternatively/one day, we could write a provider middleware to eth_estimateGas\n    // and send it to our relayer url instead for estimation..\n    //\n    // if (!transaction.gasLimit) {\n    //   const estimate = shallowCopy(transaction)\n    //   estimate.from = fromAddress\n    //   transaction.gasLimit = this.provider.estimateGas(estimate)\n    // }\n\n    const provider = await this.getSender(maybeChainId(chainId) || this.defaultChainId)\n\n    return resolveProperties({\n      tx: resolveProperties(transaction),\n      sender: await fromAddress\n    }).then(({ tx, sender }) => {\n      if (tx.from != null) {\n        if (ethers.utils.getAddress(tx.from) !== sender) {\n          // logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction)\n          throw new Error(`from address mismatch for transaction ${transaction}`)\n        }\n      } else {\n        tx.from = sender\n      }\n\n      const hexTx = hexlifyTransaction(tx)\n\n      return provider!.send('eth_sendTransaction', [hexTx]).then(\n        hash => {\n          return hash\n        },\n        error => {\n          // return checkError(\"sendTransaction\", error, hexTx)\n          throw error\n        }\n      )\n    })\n  }\n\n  connectUnchecked(): ethers.providers.JsonRpcSigner {\n    return new UncheckedJsonRpcSigner(this.provider, this.defaultChainId)\n  }\n\n  async unlock(password: string): Promise<boolean> {\n    const address = await this.getAddress()\n    return this.provider.send('personal_unlockAccount', [address, password, null])\n  }\n}\n\n// NOTE: method has been copied + modified from ethers.js JsonRpcProvider\n// Convert an ethers.js transaction into a JSON-RPC transaction\n\nconst allowedTransactionKeys: { [key: string]: boolean } = {\n  chainId: true,\n  data: true,\n  gasLimit: true,\n  gasPrice: true,\n  nonce: true,\n  to: true,\n  value: true,\n  from: true,\n  auxiliary: true,\n  expiration: true,\n  afterNonce: true,\n  delegateCall: true,\n  revertOnError: true\n}\n\nconst hexlifyTransaction = (\n  transaction: TransactionRequest,\n  allowExtra?: { [key: string]: boolean }\n): { [key: string]: string } => {\n  // Check only allowed properties are given\n  const allowed = shallowCopy(allowedTransactionKeys)\n  if (allowExtra) {\n    for (const key in allowExtra) {\n      if (allowExtra[key]) {\n        allowed[key] = true\n      }\n    }\n  }\n  ethers.utils.checkProperties(transaction, allowed)\n\n  const result: { [key: string]: any } = {}\n\n  // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n  ;['gasLimit', 'gasPrice', 'nonce', 'value'].forEach(key => {\n    const value = (transaction as any)[key]\n    if (value === null || value === undefined) {\n      return\n    }\n    const hexValue = ethers.utils.hexValue(value)\n    if (key === 'gasLimit') {\n      key = 'gas'\n    }\n    result[key] = hexValue\n  })\n  ;['from', 'to', 'data'].forEach(key => {\n    if (!(<any>transaction)[key]) {\n      return\n    }\n    result[key] = ethers.utils.hexlify((<any>transaction)[key])\n  })\n  ;['delegateCall', 'revertOnError'].forEach(key => {\n    const value = (transaction as any)[key]\n    if (value !== undefined && value !== null) {\n      result[key] = value\n    }\n  })\n\n  const auxiliary = <any>transaction['auxiliary']\n  if (auxiliary && auxiliary.length > 0) {\n    result['auxiliary'] = []\n    auxiliary.forEach((a: any) => {\n      result['auxiliary'].push(hexlifyTransaction(a))\n    })\n  }\n\n  return result\n}\n\nclass UncheckedJsonRpcSigner extends Web3Signer {\n  sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse> {\n    return this.sendUncheckedTransaction(transaction).then(hash => {\n      return <TransactionResponse>{\n        chainId: 0,\n        confirmations: 0,\n        data: '',\n        from: '',\n        gasLimit: ethers.constants.Zero,\n        gasPrice: ethers.constants.Zero,\n        hash,\n        nonce: 0,\n        value: ethers.constants.Zero,\n        wait: (confirmations?: number) => this.provider.waitForTransaction(hash, confirmations)\n      }\n    })\n  }\n}\n","import { ethers } from 'ethers'\n\nexport function messageIsExemptFromEIP191Prefix(message: Uint8Array): boolean {\n  return EIP_191_PREFIX_EXCEPTIONS.some(e => e.predicate(message))\n}\n\nconst EIP_191_PREFIX_EXCEPTIONS: Array<{\n  name: string\n  predicate: (message: Uint8Array) => boolean\n}> = [\n  // NOTE: Decentraland does not support 191 correctly.\n  {\n    name: 'Decentraland Exception',\n    predicate: isDecentralandLoginMessage\n  },\n\n  // NOTE: 0x v3 does not support 191 correctly.\n  // See https://gov.0x.org/t/zeip-proposal-fix-v3-eip-191-non-compliance-when-validating-eip-1271-signatures/3396 for more info.\n  { name: '0x v3 Exception', predicate: isZeroExV3Order }\n]\n\nconst DCL_REGEX =\n  /^Decentraland Login\\nEphemeral address: 0x[a-fA-F0-9]{40}\\nExpiration: (\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2}(?:\\.\\d*)?)((-(\\d{2}):(\\d{2})|Z)?)$/\nexport function isDecentralandLoginMessage(bytes: Uint8Array): boolean {\n  try {\n    const stringified = ethers.utils.toUtf8String(bytes)\n    return DCL_REGEX.test(stringified)\n  } catch {\n    return false\n  }\n}\n\n// try to interpret bytes as abi-encoded 0x v3 OrderWithHash -\n// see https://github.com/0xProject/0x-protocol-specification/blob/master/v3/v3-specification.md\nexport function isZeroExV3Order(bytes: Uint8Array): boolean {\n  const abi = new ethers.utils.Interface(ZeroXV3EIP1271OrderWithHashAbi)\n  try {\n    abi.decodeFunctionData('OrderWithHash', bytes)\n    return true\n  } catch (err) {\n    // failed to decode ABI, so it's not a v3 order.\n    return false\n  }\n}\n\nconst ZeroXV3EIP1271OrderWithHashAbi = [\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'address',\n            name: 'makerAddress',\n            type: 'address'\n          },\n          {\n            internalType: 'address',\n            name: 'takerAddress',\n            type: 'address'\n          },\n          {\n            internalType: 'address',\n            name: 'feeRecipientAddress',\n            type: 'address'\n          },\n          {\n            internalType: 'address',\n            name: 'senderAddress',\n            type: 'address'\n          },\n          {\n            internalType: 'uint256',\n            name: 'makerAssetAmount',\n            type: 'uint256'\n          },\n          {\n            internalType: 'uint256',\n            name: 'takerAssetAmount',\n            type: 'uint256'\n          },\n          {\n            internalType: 'uint256',\n            name: 'makerFee',\n            type: 'uint256'\n          },\n          {\n            internalType: 'uint256',\n            name: 'takerFee',\n            type: 'uint256'\n          },\n          {\n            internalType: 'uint256',\n            name: 'expirationTimeSeconds',\n            type: 'uint256'\n          },\n          {\n            internalType: 'uint256',\n            name: 'salt',\n            type: 'uint256'\n          },\n          {\n            internalType: 'bytes',\n            name: 'makerAssetData',\n            type: 'bytes'\n          },\n          {\n            internalType: 'bytes',\n            name: 'takerAssetData',\n            type: 'bytes'\n          },\n          {\n            internalType: 'bytes',\n            name: 'makerFeeAssetData',\n            type: 'bytes'\n          },\n          {\n            internalType: 'bytes',\n            name: 'takerFeeAssetData',\n            type: 'bytes'\n          }\n        ],\n        internalType: 'struct IEIP1271Data.Order',\n        name: 'order',\n        type: 'tuple'\n      },\n      {\n        internalType: 'bytes32',\n        name: 'orderHash',\n        type: 'bytes32'\n      }\n    ],\n    name: 'OrderWithHash',\n    outputs: [],\n    stateMutability: 'pure',\n    type: 'function'\n  }\n]\n","import { ethers, BigNumberish, BytesLike } from 'ethers'\nimport { WalletContext } from '@0xsequence/network'\nimport { WalletConfig, addressOf, DecodedSignature, isConfigEqual } from '@0xsequence/config'\nimport { packMessageData, encodeMessageDigest, TypedData, encodeTypedDataDigest } from '@0xsequence/utils'\nimport { Web3Provider } from './provider'\nimport { isValidSignature as _isValidSignature, recoverConfig, Signer } from '@0xsequence/wallet'\nimport { messageIsExemptFromEIP191Prefix } from './eip191exceptions'\n\nconst eip191prefix = ethers.utils.toUtf8Bytes('\\x19Ethereum Signed Message:\\n')\n\nexport const messageToBytes = (message: BytesLike): Uint8Array => {\n  if (ethers.utils.isBytes(message) || ethers.utils.isHexString(message)) {\n    return ethers.utils.arrayify(message)\n  }\n\n  return ethers.utils.toUtf8Bytes(message)\n}\n\nexport const prefixEIP191Message = (message: BytesLike): Uint8Array => {\n  const messageBytes = messageToBytes(message)\n  if (messageIsExemptFromEIP191Prefix(messageBytes)) {\n    return messageBytes\n  } else {\n    return ethers.utils.concat([eip191prefix, ethers.utils.toUtf8Bytes(String(messageBytes.length)), messageBytes])\n  }\n}\n\nexport const isValidSignature = async (\n  address: string,\n  digest: Uint8Array,\n  sig: string,\n  provider: Web3Provider | ethers.providers.Web3Provider | ethers.providers.Provider,\n  chainId?: number,\n  walletContext?: WalletContext\n): Promise<boolean> => {\n  if (!chainId) {\n    chainId = (await provider.getNetwork())?.chainId\n  }\n  if (!walletContext && Web3Provider.isSequenceProvider(provider)) {\n    walletContext = await provider.getSigner().getWalletContext()\n  }\n  return _isValidSignature(address, digest, sig, provider, walletContext, chainId)\n}\n\nexport const isValidMessageSignature = async (\n  address: string,\n  message: string | Uint8Array,\n  signature: string,\n  provider: Web3Provider | ethers.providers.Web3Provider  | ethers.providers.Provider,\n  chainId?: number,\n  walletContext?: WalletContext\n): Promise<boolean> => {\n  const prefixed = prefixEIP191Message(message)\n  const digest = encodeMessageDigest(prefixed)\n  return isValidSignature(address, digest, signature, provider, chainId, walletContext)\n}\n\nexport const isValidTypedDataSignature = (\n  address: string,\n  typedData: TypedData,\n  signature: string,\n  provider: Web3Provider | ethers.providers.Web3Provider  | ethers.providers.Provider,\n  chainId?: number,\n  walletContext?: WalletContext\n): Promise<boolean> => {\n  return isValidSignature(address, encodeTypedDataDigest(typedData), signature, provider, chainId, walletContext)\n}\n\nexport const recoverWalletConfig = async (\n  address: string,\n  digest: BytesLike,\n  signature: string | DecodedSignature,\n  chainId: BigNumberish,\n  walletContext?: WalletContext\n): Promise<WalletConfig> => {\n  const subDigest = packMessageData(address, chainId, digest)\n  const config = await recoverConfig(subDigest, signature)\n\n  if (walletContext) {\n    const recoveredWalletAddress = addressOf(config, walletContext)\n    if (config.address && config.address !== recoveredWalletAddress) {\n      throw new Error('recovered address does not match the WalletConfig address, check the WalletContext')\n    } else {\n      config.address = recoveredWalletAddress\n    }\n  }\n\n  return config\n}\n\nexport const isBrowserExtension = (): boolean =>\n  window.location.protocol === 'chrome-extension:' || window.location.protocol === 'moz-extension:'\n\nexport const isUnityPlugin = (): boolean => !!navigator.userAgent.match(/UnitySequence/i)\n\n/**\n * Returns the status of a signer's wallet on given chain by checking wallet deployment and config status\n *\n * @param {Signer} signer\n * @param {number} chainId\n * @return {Promise<boolean>} Promise that returns true if the wallet is up to date, false otherwise\n */\nexport const isWalletUpToDate = async (signer: Signer, chainId: number): Promise<boolean> => {\n  const walletState = await signer.getWalletState()\n  const networks = await signer.getNetworks()\n\n  const walletStateForRequiredChain = walletState.find(state => state.chainId === chainId)\n  if (!walletStateForRequiredChain) {\n    throw new Error(`WalletRequestHandler: could not find wallet state for chainId ${chainId}`)\n  }\n\n  const isDeployed = walletStateForRequiredChain.deployed\n\n  if (!networks) {\n    throw new Error(`isWalletUpToDate util: could not get networks from signer`)\n  }\n  const authChain = networks.find(network => network.isAuthChain)\n  if (!authChain) {\n    throw new Error(`isWalletUpToDate util: could not get auth chain network information`)\n  }\n  const authChainId = authChain.chainId\n  const authChainConfig = walletState.find(state => state.chainId === authChainId)?.config\n  if (!authChainConfig) {\n    throw new Error(`isWalletUpToDate util: could not get auth chain config`)\n  }\n  const requiredChainConfig = walletStateForRequiredChain.config\n  if (!requiredChainConfig) {\n    throw new Error(`isWalletUpToDate util: could not get config for chainId ${chainId}`)\n  }\n\n  const isUpToDate = isConfigEqual(authChainConfig, requiredChainConfig)\n\n  return isDeployed && isUpToDate\n}\n\nexport interface ItemStore {\n  getItem(key: string): Promise<string | null>\n  setItem(key: string, value: string): Promise<void>\n  removeItem(key: string): Promise<void>\n}\n\nexport class LocalStorage {\n  private static _instance: ItemStore\n\n  private constructor() {}\n\n  static getInstance(): ItemStore {\n    if (typeof window === 'object') {\n      if (!LocalStorage._instance) {\n        LocalStorage._instance = {\n          getItem: (key: string) => Promise.resolve(window.localStorage.getItem(key)),\n          setItem: (key: string, value: string) => Promise.resolve(window.localStorage.setItem(key, value)),\n          removeItem: (key: string) => Promise.resolve(window.localStorage.removeItem(key))\n        }\n      }\n    } else {\n      // noop local storage if window is not defined\n      // TODO: perhaps add an in-memory local storage if we need?\n      if (!LocalStorage._instance) {\n        LocalStorage._instance = {\n          getItem: (key: string) => Promise.resolve(null),\n          setItem: (key: string, value: string) => Promise.resolve(),\n          removeItem: (key: string) => Promise.resolve()\n        }\n      }\n    }\n    return this._instance\n  }\n\n  static use(instance: ItemStore) {\n    LocalStorage._instance = instance\n  }\n}\n\n// window.localstorage helper\nexport class LocalStore<T extends Object = string> {\n  readonly key: string\n\n  constructor(key: string, public def?: T) {\n    this.key = key\n  }\n\n  async get(): Promise<T | undefined> {\n    const val = await LocalStorage.getInstance().getItem(this.key)\n\n    if (val === null) {\n      return this.def\n    }\n\n    try {\n      return JSON.parse(val)\n    } catch (err) {\n      console.error(err)\n    }\n\n    return\n  }\n\n  set(val: T | undefined) {\n    val ? LocalStorage.getInstance().setItem(this.key, JSON.stringify(val)) : LocalStorage.getInstance().removeItem(this.key)\n  }\n\n  del() {\n    LocalStorage.getInstance().removeItem(this.key)\n  }\n}\n","import { ethers } from 'ethers'\nimport {\n  WalletTransport,\n  ProviderMessage,\n  ProviderMessageRequest,\n  EventType,\n  ProviderMessageResponse,\n  ProviderMessageTransport,\n  ProviderRpcError,\n  InitState,\n  ConnectDetails,\n  OpenWalletIntent,\n  WalletSession,\n  TransportSession\n} from '../types'\n\nimport { WalletRequestHandler } from './wallet-request-handler'\n\nimport { NetworkConfig, WalletContext, JsonRpcRequest, JsonRpcResponseCallback } from '@0xsequence/network'\nimport { logger, sanitizeAlphanumeric, sanitizeHost, sanitizeNumberString } from '@0xsequence/utils'\nimport { AuthorizationOptions } from '@0xsequence/auth'\n\nimport { PROVIDER_OPEN_TIMEOUT } from './base-provider-transport'\nimport { isBrowserExtension, LocalStorage } from '../utils'\n\nconst TRANSPORT_SESSION_LS_KEY = '@sequence.transportSession'\n\nexport abstract class BaseWalletTransport implements WalletTransport {\n  protected walletRequestHandler: WalletRequestHandler\n  protected _sessionId: string\n  protected _registered: boolean\n\n  protected _init: InitState\n  protected _initNonce: string\n  protected _initCallback?: (error?: string) => void\n\n  // appOrigin identifies the dapp's origin which opened the app. A transport\n  // will auto-detect and set this value if it can. This is determined\n  // as the parent app/window which opened the wallet.\n  protected appOrigin?: string\n\n  constructor(walletRequestHandler: WalletRequestHandler) {\n    this.walletRequestHandler = walletRequestHandler\n    this._init = InitState.NIL\n\n    this.walletRequestHandler.on('connect', (connectDetails: ConnectDetails) => {\n      if (!this.registered) return\n      // means user has logged in and wallet is connected to the app\n      this.notifyConnect(connectDetails)\n    })\n\n    this.walletRequestHandler.on('disconnect', (error?: ProviderRpcError) => {\n      if (!this.registered) return\n      // means user has logged out the app / disconnected wallet from the app\n      this.notifyDisconnect(error)\n    })\n\n    this.walletRequestHandler.on('accountsChanged', (accounts: string[], origin?: string) => {\n      if (!this.registered) return\n      this.notifyAccountsChanged(accounts, origin)\n    })\n\n    this.walletRequestHandler.on('networks', (networks: NetworkConfig[]) => {\n      if (!this.registered) return\n      this.notifyNetworks(networks)\n      if (!networks || networks.length === 0) {\n        this.notifyChainChanged('0x0')\n      } else {\n        this.notifyChainChanged(ethers.utils.hexlify(networks.find(network => network.isDefaultChain)!.chainId))\n      }\n    })\n\n    this.walletRequestHandler.on('walletContext', (walletContext: WalletContext) => {\n      if (!this.registered || !walletContext) return\n      this.notifyWalletContext(walletContext)\n    })\n\n    this.walletRequestHandler.on('close', (error?: ProviderRpcError) => {\n      if (!this.registered) return\n      this.notifyClose(error)\n    })\n  }\n\n  get registered(): boolean {\n    return this._registered\n  }\n\n  register() {\n    throw new Error('abstract method')\n  }\n\n  unregister() {\n    throw new Error('abstract method')\n  }\n\n  sendAsync = async (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n    throw new Error('abstract method')\n  }\n\n  handleMessage = async (message: ProviderMessage<any>) => {\n    const request = message\n\n    // ensure initial handshake is complete before accepting\n    // other kinds of messages.\n    if (this._init !== InitState.OK) {\n      if (request.type === EventType.INIT) {\n        if (this.isValidInitAck(message)) {\n          // successful init\n          if (this._initCallback) this._initCallback()\n        } else {\n          // failed init\n          if (this._initCallback) this._initCallback('invalid init')\n          return\n        }\n      } else {\n        // we expect init message first. do nothing here.\n      }\n      return\n    }\n\n    // ensure signer is ready to handle requests\n    // if (this.walletRequestHandler.getSigner() === undefined) {\n    //   await this.walletRequestHandler.signerReady()\n    // }\n\n    // handle request\n    switch (request.type) {\n      case EventType.OPEN: {\n        if (this._init !== InitState.OK) return\n        const session: TransportSession = {\n          sessionId: request.data.sessionId,\n          intent: request.data.intent,\n          networkId: request.data.networkId\n        }\n        await this.open(session)\n        return\n      }\n\n      case EventType.CLOSE: {\n        if (this._init !== InitState.OK) return\n        // noop. just here to capture the message so event emitters may be notified\n        return\n      }\n\n      case EventType.MESSAGE: {\n        const response = await this.walletRequestHandler.sendMessageRequest(request)\n        this.sendMessage(response)\n\n        if (response.data.error) {\n          // TODO: for certain errors, whenever we want to render something to the UI\n          // we should throw\n        }\n        return\n      }\n\n      default: {\n        logger.error(`unexpected payload type ${request.type}`)\n      }\n    }\n  }\n\n  // sendMessageRequest sends a ProviderMessageRequest to the wallet post-message transport\n  sendMessageRequest = async (message: ProviderMessageRequest): Promise<ProviderMessageResponse> => {\n    return this.walletRequestHandler.sendMessageRequest(message)\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    throw new Error('abstract method')\n  }\n\n  notifyOpen(openInfo: { chainId?: string; sessionId?: string; session?: WalletSession; error?: string }) {\n    const { chainId, sessionId, session, error } = openInfo\n    this.sendMessage({\n      idx: -1,\n      type: EventType.OPEN,\n      data: {\n        chainId,\n        sessionId,\n        session,\n        error\n      }\n    })\n  }\n\n  notifyClose(error?: ProviderRpcError) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CLOSE,\n      data: error ? { error } : null\n    })\n  }\n\n  notifyConnect(connectDetails: ConnectDetails) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CONNECT,\n      data: connectDetails\n    })\n  }\n\n  notifyDisconnect(error?: ProviderRpcError) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.DISCONNECT,\n      data: error ? { error } : null\n    })\n  }\n\n  notifyAccountsChanged(accounts: string[], origin?: string) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.ACCOUNTS_CHANGED,\n      data: accounts,\n      origin: origin\n    })\n  }\n\n  notifyChainChanged(chainIdHex: string) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.CHAIN_CHANGED,\n      data: chainIdHex\n    })\n  }\n\n  notifyNetworks(networks: NetworkConfig[]) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.NETWORKS,\n      data: networks\n    })\n  }\n\n  notifyWalletContext(walletContext: WalletContext) {\n    this.sendMessage({\n      idx: -1,\n      type: EventType.WALLET_CONTEXT,\n      data: walletContext\n    })\n  }\n\n  protected isValidInitAck(message: ProviderMessage<any>): boolean {\n    if (this._init === InitState.OK) {\n      // we're already in init state, we shouldn't handle this message\n      logger.warn(\"isValidInitAck, already in init'd state, so inquiry is invalid.\")\n      return false\n    }\n    if (message.type !== EventType.INIT) {\n      logger.warn('isValidInitAck, invalid message type, expecting init')\n      return false\n    }\n\n    const { sessionId, nonce } = message.data as any as { sessionId: string; nonce: string }\n    if (!sessionId || sessionId.length === 0 || !nonce || nonce.length === 0) {\n      logger.error('invalid init ack')\n      return false\n    }\n    if (sessionId !== this._sessionId || nonce !== this._initNonce) {\n      logger.error('invalid init ack match')\n      return false\n    }\n\n    // all checks pass, its true\n    return true\n  }\n\n  private init(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      // avoid re-init`ing, or if there is a transport which doesn't require\n      // it, then it may set this._init to OK in its constructor.\n      if (this._init === InitState.OK) {\n        resolve()\n        return\n      }\n      if (this._init !== InitState.NIL || this._initCallback) {\n        reject('transport init is in progress')\n        return\n      }\n\n      // start init timeout, if we don't receive confirmation\n      // from provider within this amount of time, then we timeout\n      const initTimeout = setTimeout(() => {\n        logger.warn('transport init timed out')\n        if (this._initCallback) {\n          this._initCallback('transport init timed out')\n        }\n      }, PROVIDER_OPEN_TIMEOUT / 2)\n\n      // setup callback as we receive the init message async in the handleMessage function\n      this._initCallback = (error?: string) => {\n        this._initCallback = undefined // reset\n        clearTimeout(initTimeout)\n        if (error) {\n          reject(error)\n        } else {\n          this._init = InitState.OK\n          resolve()\n        }\n      }\n\n      // send init request with random nonce to the provider, where we expect\n      // for the provider to echo it back to us as complete handshake\n      this._initNonce = `${performance.now()}`\n      this.sendMessage({\n        idx: -1,\n        type: EventType.INIT,\n        data: { nonce: this._initNonce }\n      })\n      this._init = InitState.SENT_NONCE\n\n      // NOTE: the promise will resolve in the _initCallback method\n      // which will be called from either handleMessage or the initTimeout\n    })\n  }\n\n  protected open = async ({ sessionId, intent, networkId }: TransportSession): Promise<boolean> => {\n    if (sessionId) {\n      this._sessionId = sanitizeNumberString(sessionId)\n      // persist transport session in localstorage for restoring after redirect/reload\n      this.saveTransportSession({ sessionId, intent, networkId })\n    }\n\n    this.walletRequestHandler.setOpenIntent(intent)\n\n    // init handshake for certain transports, before we can open the communication.\n    //\n    // for example, with the window-transport, we have to exchange messages to determine the\n    // origin host of the dapp.\n    await this.init()\n\n    // Prepare connect options from intent\n    if (intent && intent.type === 'connect' && intent.options) {\n      const connectOptions = intent.options\n      const authorizeOptions: AuthorizationOptions = connectOptions // overlapping types\n\n      // Sanity/integrity check the intent payload, and set authorization origin\n      // if its been determined as part of the init handshake from earlier.\n      if (this.appOrigin && authorizeOptions?.origin) {\n        if (!isBrowserExtension()) {\n          if (authorizeOptions.origin !== this.appOrigin) {\n            throw new Error('origin is invalid')\n          } else {\n            // request origin and derived origins match, lets carry on\n          }\n        }\n      } else if (!this.appOrigin && authorizeOptions?.origin) {\n        // ie. when we can't determine the origin in our transport, but dapp provides it to us.\n        // we just sanitize the origin host.\n        connectOptions.origin = sanitizeHost(authorizeOptions.origin)\n      } else if (this.appOrigin) {\n        // ie. when we auto-determine the origin such as in window-transport\n        connectOptions.origin = this.appOrigin\n      }\n      if (connectOptions.app) {\n        connectOptions.app = sanitizeAlphanumeric(connectOptions.app)\n      }\n\n      // Set connect options on the walletRequestHandler as our primary\n      // wallet controller, and fall back to networkId if necessary\n      this.walletRequestHandler.setConnectOptions(connectOptions)\n      if (connectOptions.networkId) {\n        networkId = connectOptions.networkId\n      } else if (networkId) {\n        connectOptions.networkId = networkId\n      }\n    } else {\n      this.walletRequestHandler.setConnectOptions(undefined)\n    }\n\n    // ensure signer is ready\n    await this.walletRequestHandler.getSigner()\n\n    // Notify open and proceed to prompt for connection if intended\n    if (!(await this.walletRequestHandler.isSignedIn())) {\n      // open wallet without a specific connected chainId, as the user is not signed in\n      this.notifyOpen({\n        sessionId: this._sessionId\n      })\n      return true\n    } else {\n      // prompt user with a connect request. the options will be used as previously set above.\n      // upon success, the walletRequestHandler will notify the dapp with the ConnectDetails.\n      // upon cancellation by user, the walletRequestHandler will throw an error\n\n      if (intent && intent.type === 'connect') {\n        let chainId: number | undefined = undefined\n        try {\n          if (networkId) {\n            chainId = await this.walletRequestHandler.setDefaultNetwork(networkId, false)\n          } else {\n            chainId = await this.walletRequestHandler.getChainId()\n          }\n        } catch (err) {\n          console.error(err)\n        }\n        // Failed to set default network on open\n        // Fail silently here so we can continue with connect flow and ask\n        // user to connect on a different network if necessary\n        if (!chainId || chainId <= 0) {\n          console.log('Failed to set default network on open')\n        }\n\n        // notify wallet is opened, without session details\n        this.notifyOpen({\n          sessionId: this._sessionId\n        })\n\n        try {\n          const connectDetails = await this.walletRequestHandler.promptConnect(intent.options)\n          if (connectDetails.connected) {\n            this.walletRequestHandler.notifyConnect(connectDetails)\n          }\n        } catch (err) {\n          logger.warn('promptConnect not connected:', err)\n        } finally {\n          // auto-close by default, unless intent is to keep open\n          if (!intent.options || intent.options.keepWalletOpened !== true) {\n            this.notifyClose()\n          }\n        }\n      } else {\n        // Set default network, in case of error chainId will be undefined or 0\n        let chainId: number | undefined = undefined\n        try {\n          if (networkId) {\n            chainId = await this.walletRequestHandler.setDefaultNetwork(networkId, false)\n          } else {\n            chainId = await this.walletRequestHandler.getChainId()\n          }\n        } catch (err) {\n          console.error(err)\n        }\n\n        // Failed to set default network on open -- quit + close\n        if (!chainId || chainId <= 0) {\n          this.notifyOpen({\n            sessionId: this._sessionId,\n            error: `failed to open wallet on network ${networkId}`\n          })\n          return false\n        }\n\n        // user is already connected, notify session details.\n        // TODO: in future, keep list if 'connected' dapps / sessions in the session\n        // controller, and only sync with allowed apps\n        this.notifyOpen({\n          sessionId: this._sessionId,\n          chainId: `${chainId}`,\n          session: await this.walletRequestHandler.walletSession()\n        })\n      }\n    }\n\n    return true\n  }\n\n  private saveTransportSession = (session: TransportSession) => {\n    LocalStorage.getInstance().setItem(TRANSPORT_SESSION_LS_KEY, JSON.stringify(session))\n  }\n\n  protected getCachedTransportSession = async (): Promise<TransportSession | null> => {\n    const session = await LocalStorage.getInstance().getItem(TRANSPORT_SESSION_LS_KEY)\n\n    try {\n      return session ? (JSON.parse(session) as TransportSession) : null\n    } catch (err) {\n      console.error(`unable to parse transport session: ${session}`)\n      return null\n    }\n  }\n}\n","import { EventEmitter2 as EventEmitter } from 'eventemitter2'\nimport { ProviderMessage, ProviderMessageTransport, ProviderEventTypes, TypedEventEmitter } from '../../types'\n\nexport class ProxyMessageChannel {\n  app: ProxyMessageChannelPort\n  wallet: ProxyMessageChannelPort\n\n  constructor() {\n    const port1 = new ProxyMessageChannelPort()\n    const port2 = new ProxyMessageChannelPort()\n\n    port1.conn = port2\n    port2.conn = port1\n\n    this.app = port1\n    this.wallet = port2\n  }\n}\n\nexport class ProxyMessageChannelPort implements ProviderMessageTransport {\n  conn: ProviderMessageTransport\n  events: TypedEventEmitter<ProxyEventTypes> = new EventEmitter() as TypedEventEmitter<ProxyEventTypes>\n\n\n  // handle messages which hit this port\n  handleMessage = (message: ProviderMessage<any>): void => {\n    throw new Error('ProxyMessageChannelPort is not registered')\n  }\n\n  // send messages to the connected port\n  sendMessage = (message: ProviderMessage<any>): void => {\n    this.conn.handleMessage(message)\n\n    // trigger events\n    if (message.type === 'open') {\n      this.events.emit('open', message as any)\n    }\n    if (message.type === 'close') {\n      this.events.emit('close', message as any)\n    }\n    if (message.type === 'connect') {\n      this.events.emit('connect', message as any)\n    }\n    if (message.type === 'disconnect') {\n      this.events.emit('disconnect', message as any)\n    }\n  }\n\n  on<K extends keyof ProxyEventTypes>(event: K, fn: ProxyEventTypes[K]) {\n    this.events.on(event, fn as any)\n  }\n\n  once<K extends keyof ProxyEventTypes>(event: K, fn: ProxyEventTypes[K]) {\n    this.events.once(event, fn as any)\n  }\n}\n\nexport type ProxyEventTypes = Pick<ProviderEventTypes, 'open' | 'close' | 'connect' | 'disconnect'>\n","import { BaseProviderTransport } from '../base-provider-transport'\n\nimport {\n  ProviderMessage, OpenState, OpenWalletIntent, EventType, InitState\n} from '../../types'\n\nimport { ProxyMessageChannelPort, ProxyEventTypes } from './proxy-message-channel'\n\nexport class ProxyMessageProvider extends BaseProviderTransport {\n\n  private port: ProxyMessageChannelPort\n  \n  constructor(port: ProxyMessageChannelPort) {\n    super()\n    this.state = OpenState.CLOSED\n    this.port = port    \n    if (!port) {\n      throw new Error('port argument cannot be empty')\n    }\n\n    // disable init handshake for proxy-transport, we set it to OK, to\n    // consider it in completed state.\n    this._init = InitState.OK\n  }\n\n  register = () => {\n    this.port.handleMessage = (message: ProviderMessage<any>): void => {\n      this.handleMessage(message)\n    }\n\n    this.on('open', (...args: Parameters<ProxyEventTypes['open']>) => {\n      this.port.events.emit('open', ...args)\n    })\n    this.on('close', (...args: Parameters<ProxyEventTypes['close']>) => {\n      this.port.events.emit('close', ...args)\n    })\n    this.on('connect', (...args: Parameters<ProxyEventTypes['connect']>) => {\n      this.port.events.emit('connect', ...args)\n    })\n    this.on('disconnect', (...args: Parameters<ProxyEventTypes['disconnect']>) => {\n      this.port.events.emit('disconnect', ...args)\n    })\n\n    this._registered = true\n  }\n\n  unregister = () => {\n    this._registered = false\n    this.closeWallet()\n    this.events.removeAllListeners()\n    // @ts-ignore\n    this.port.handleMessage = undefined\n  }\n\n  openWallet = (path?: string, intent?: OpenWalletIntent, networkId?: string | number): void => {\n    if (this.state === OpenState.CLOSED) {\n      this.state = OpenState.OPENING\n      const sessionId = `${performance.now()}`\n      this._sessionId = sessionId\n      this.sendMessage({\n        idx: -1, type: EventType.OPEN, data: {\n          path, intent, networkId, sessionId\n        }\n      })\n    }\n  }\n\n  closeWallet() {\n    this.sendMessage({\n      idx: -1, type: EventType.CLOSE, data: null\n    })\n    this.close()\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    if (!message.idx) {\n      throw new Error('message idx is empty')\n    }\n    this.port.sendMessage(message)\n  }\n}\n","import {\n  ProviderMessage, EventType, ProviderTransport,\n  ProviderEventTypes, ProviderMessageRequest, ProviderMessageResponse, WalletSession, OpenWalletIntent, ConnectDetails\n} from '../../types'\n\nimport { JsonRpcRequest, JsonRpcResponseCallback } from '@0xsequence/network'\n\nexport class MuxMessageProvider implements ProviderTransport {\n\n  private messageProviders: ProviderTransport[]\n  private provider: ProviderTransport | undefined\n\n  constructor(...messageProviders: ProviderTransport[]) {\n    this.messageProviders = messageProviders\n    this.provider = undefined\n  }\n\n  add(...messageProviders: ProviderTransport[]) {\n    this.messageProviders.push(...messageProviders)\n  }\n\n  register = () => {\n    if (this.messageProviders.length === 1) {\n      this.provider = this.messageProviders[0]\n      this.provider.register()\n      return\n    }\n\n    // REVIEW/NOTE: ........ this method does not work for the chrome-extension. The issue becomes\n    // when the browser quits or restarts, the \"open\" event is never triggered. Perhaps the code here is fine,\n    // or maybe its not. What should happen is when a dapp makes a request, it will call openWallet\n    // below, in which case one of the events will register. So perhaps this is fine.\n    this.messageProviders.forEach(m => {\n      m.register()\n\n      m.once('open', () => {\n        // the first one to open is the winner, and others will be unregistered\n        if (!this.provider) {\n          this.provider = m\n\n          // unregister other providers\n          this.messageProviders.forEach(m => {\n            if (this.provider !== m) {\n              m.unregister()\n            }\n          })\n        }\n      })\n    })\n  }\n\n  unregister = () => {\n    this.messageProviders.forEach(m => m.unregister())\n    this.provider = undefined\n  }\n\n  openWallet = (path?: string, intent?: OpenWalletIntent, networkId?: string | number): void => {\n    if (this.provider) {\n      this.provider.openWallet(path, intent, networkId)\n      return\n    }\n    this.messageProviders.forEach(m => m.openWallet(path, intent, networkId))\n  }\n\n  closeWallet() {\n    if (this.provider) {\n      this.provider.closeWallet()\n    }\n  }\n\n  isOpened(): boolean {\n    if (this.provider) {\n      return this.provider.isOpened()\n    }\n    return false\n  }\n\n  isConnected(): boolean {\n    if (this.provider) {\n      return this.provider.isConnected()\n    }\n    return false\n  }\n\n  on<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    if (this.provider) {\n      this.provider.on(event, fn)\n      return\n    }\n    this.messageProviders.forEach(m => {\n      m.on(event, fn)\n    })\n  }\n\n  once<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    if (this.provider) {\n      this.provider.once(event, fn)\n      return\n    }\n    this.messageProviders.forEach(m => {\n      m.once(event, fn)\n    })\n  }\n\n  emit<K extends keyof ProviderEventTypes>(event: K, ...args: Parameters<ProviderEventTypes[K]>): boolean {\n    if (this.provider) {\n      return this.provider.emit(event, ...args)\n    }\n    for (let i=0; i < this.messageProviders.length; i++) {\n      this.messageProviders[i].emit(event, ...args)\n    }\n    return true\n  }\n\n  sendAsync = async (request: JsonRpcRequest, callback: JsonRpcResponseCallback, chainId?: number) => {\n    if (this.provider) {\n      this.provider.sendAsync(request, callback, chainId)\n      return\n    }\n    throw new Error('impossible state, wallet must be opened first')\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    if (!message.idx || message.idx <= 0) {\n      throw new Error('message idx is empty')\n    }\n\n    if (this.provider) {\n      this.provider.sendMessage(message)\n    } else {\n      throw new Error('impossible state, wallet must be opened first')\n    }\n  }\n\n  sendMessageRequest = async (message: ProviderMessageRequest): Promise<ProviderMessageResponse> => {\n    if (this.provider) {\n      return this.provider.sendMessageRequest(message)\n    }\n    throw new Error('impossible state, wallet must be opened first')\n  }\n\n  handleMessage(message: ProviderMessage<any>): void {\n    if (this.provider) {\n      this.provider.handleMessage(message)\n      return\n    }\n    throw new Error('impossible state, wallet must be opened first')\n  }\n\n  waitUntilOpened = async (): Promise<WalletSession | undefined> => {\n    if (this.provider) {\n      return this.provider.waitUntilOpened()\n    }\n    return Promise.race(this.messageProviders.map(p => p.waitUntilOpened()))\n  }\n\n  waitUntilConnected = async (): Promise<ConnectDetails> => {\n    if (this.provider) {\n      return this.provider.waitUntilConnected()\n    }\n    throw new Error('impossible state, wallet must be opened first')\n  }\n\n}\n","import { OpenWalletIntent, ProviderMessage, InitState, EventType, WindowSessionParams } from '../../types'\nimport { BaseProviderTransport } from '../base-provider-transport'\nimport { logger, base64EncodeObject } from '@0xsequence/utils'\nimport { isBrowserExtension, isUnityPlugin } from '../../utils'\n\n// ..\nlet registeredWindowMessageProvider: WindowMessageProvider | undefined\n\nexport class WindowMessageProvider extends BaseProviderTransport {\n  private walletURL: URL\n  private walletWindow: Window | null\n\n  constructor(walletAppURL: string) {\n    super()\n    this.walletURL = new URL(walletAppURL)\n  }\n\n  register = () => {\n    if (registeredWindowMessageProvider) {\n      // overriding the registered message provider\n      registeredWindowMessageProvider.unregister()\n      registeredWindowMessageProvider = this\n    }\n\n    // listen for incoming messages from wallet\n    window.addEventListener('message', this.onWindowEvent)\n    registeredWindowMessageProvider = this\n\n    // open heartbeat\n    this.on('open', () => {\n      // Heartbeat to track if window closed\n      const popup = this.walletWindow\n      const interval = setInterval(() => {\n        if (popup && popup.closed) {\n          clearInterval(interval)\n          this.close()\n        }\n      }, 500)\n    })\n\n    // close clean up\n    this.on('close', () => {\n      if (this.walletWindow) {\n        this.walletWindow.close()\n        this.walletWindow = null\n      }\n    })\n\n    this._registered = true\n  }\n\n  unregister = () => {\n    this._registered = false\n    this.closeWallet()\n\n    // disable message listener\n    if (registeredWindowMessageProvider === this) {\n      registeredWindowMessageProvider = undefined\n    }\n    window.removeEventListener('message', this.onWindowEvent)\n\n    // clear event listeners\n    this.events.removeAllListeners()\n  }\n\n  openWallet = (path?: string, intent?: OpenWalletIntent, networkId?: string | number): void => {\n    if (this.walletWindow && this.isOpened()) {\n      // TODO: update the location of window to path\n      this.walletWindow.focus()\n      return\n    }\n\n    // Instantiate new walletURL for this call\n    const walletURL = new URL(this.walletURL.href)\n    const windowSessionParams = new WindowSessionParams()\n\n    if (path && path !== '') {\n      walletURL.pathname = path.toLowerCase()\n    }\n\n    // Set session, intent and network id on walletURL\n    this._init = InitState.NIL\n    this._sessionId = `${performance.now()}`\n    windowSessionParams.set('sid', this._sessionId)\n\n    if (intent) {\n      // for the window-transport, we eagerly/optimistically set the origin host\n      // when connecting to the wallet, however, this will be verified and enforced\n      // on the wallet-side, so if a dapp provides the wrong origin, it will be dropped.\n      if (intent.type === 'connect') {\n        if (!intent.options) intent.options = {}\n\n        // skip setting origin host if we're in an browser extension execution context\n        // allow origin that is passed in\n        if (!isBrowserExtension() && !isUnityPlugin()) {\n          intent.options.origin = window.location.origin\n        }\n      }\n      // encode intent as base64 url-encoded param\n      windowSessionParams.set('intent', base64EncodeObject(intent))\n    }\n    if (networkId) {\n      windowSessionParams.set('net', `${networkId}`)\n    }\n\n    // Open popup window on center of the app window\n    let windowSize: number[]\n    let windowPos: number[]\n\n    if (isBrowserExtension()) {\n      windowSize = [450, 750]\n      windowPos = [Math.abs(window.screen.width / 2 - windowSize[0] / 2), Math.abs(window.screen.height / 2 - windowSize[1] / 2)]\n    } else {\n      windowSize = [450, 750]\n      windowPos = [\n        Math.abs(window.screenX + window.innerWidth / 2 - windowSize[0] / 2),\n        Math.abs(window.screenY + window.innerHeight / 2 - windowSize[1] / 2)\n      ]\n    }\n\n    const windowFeatures =\n      `toolbar=0,location=0,menubar=0,scrollbars=yes,status=yes` +\n      `,width=${windowSize[0]},height=${windowSize[1]}` +\n      `,left=${windowPos[0]},top=${windowPos[1]}`\n\n    // serialize params\n    walletURL.search = windowSessionParams.toString()\n\n    this.walletWindow = window.open(walletURL.href, 'sequence.app', windowFeatures)\n\n    // TODO: move this somewhere else\n    // TODO: perhaps we trigger a .on('openTimeout') event..? maybe.. could help.\n\n    // Popup blocking detection and notice\n    // let warned = false\n    // const warnPopupBlocked = () => {\n    //   if (warned) return\n    //   warned = true\n    //   // alert('popup is blocked! hey yo') // NOTE: for debug purposes only\n    //   throw new Error('popup is blocked')\n    // }\n\n    // const popupCheck = setTimeout(() => {\n    //   if (!popup || popup.closed || typeof popup.closed === 'undefined') {\n    //     // popup is definitely blocked if we reach here.\n    //     warnPopupBlocked()\n    //   }\n    // }, 1000)\n\n    // const popupBlocked = popup === null || popup === undefined\n    // if (popupBlocked) {\n    //   warnPopupBlocked()\n    //   return\n    // }\n  }\n\n  closeWallet() {\n    this.close()\n    this.walletWindow?.close()\n  }\n\n  // onmessage, receives ProviderMessageResponse from the wallet post-message transport\n  private onWindowEvent = (event: MessageEvent) => {\n    // Security check, ensure message is coming from wallet origin url\n    if (event.origin !== this.walletURL.origin) {\n      // Safetly can skip events not from the wallet\n      return\n    }\n\n    let message: ProviderMessage<any>\n    try {\n      message = JSON.parse(event.data)\n    } catch (err) {\n      // event is not a ProviderMessage JSON object, skip\n      return\n    }\n\n    if (!message) {\n      throw new Error('ProviderMessage object is empty')\n    }\n\n    // handle message with base message provider\n    this.handleMessage(message)\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    if (!this.walletWindow) {\n      logger.warn('WindowMessageProvider: sendMessage failed as walletWindow is unavailable')\n      return\n    }\n    const postedMessage = typeof message !== 'string' ? JSON.stringify(message) : message\n    this.walletWindow.postMessage(postedMessage, this.walletURL.origin)\n  }\n}\n","import { WalletRequestHandler } from '../wallet-request-handler'\nimport { BaseWalletTransport } from '../base-wallet-transport'\nimport { InitState, ProviderMessage } from '../../types'\nimport { Runtime } from 'webextension-polyfill'\nimport { logger } from '@0xsequence/utils'\n\nexport const CHANNEL_ID = 'sequence-extension-message-handler'\n\nexport class ExtensionMessageHandler extends BaseWalletTransport {\n  private port: any\n\n  constructor(walletRequestHandler: WalletRequestHandler, public runtime: Runtime.Static) {\n    super(walletRequestHandler)\n    this._init = InitState.OK\n  }\n\n  register() {\n    this._registered = true\n    this.port = this.runtime.connect({ name: CHANNEL_ID })\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    logger.info('[ExtensionMessageHandler send]', message)\n    this.port.postMessage(message)\n  }\n}\n","import { InitState, OpenWalletIntent, ProviderMessage } from '../../types'\nimport { BaseProviderTransport } from '../base-provider-transport'\nimport { CHANNEL_ID } from './extension-message-handler'\n\nimport { Runtime } from 'webextension-polyfill'\n\nexport class ExtensionMessageProvider extends BaseProviderTransport {\n  constructor(runtime: Runtime.Static) {\n    super()\n\n    runtime.onConnect.addListener(port => {\n      if (port.name === CHANNEL_ID) {\n        this._init = InitState.OK\n\n        port.onMessage.addListener((message: ProviderMessage<any>) => {\n          this.handleMessage(message)\n        })\n      }\n    })\n  }\n\n  register = () => {\n    this._registered = true\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    //noop\n  }\n\n  unregister() {\n    //noop\n  }\n\n  openWallet(path?: string, intent?: OpenWalletIntent, networkId?: string | number) {\n    //noop\n  }\n\n  closeWallet() {\n    //noop\n  }\n}\n","import { JsonRpcRequest, JsonRpcResponse } from '@0xsequence/network'\nimport { logger } from '@0xsequence/utils'\nimport { EventEmitter2 as EventEmitter } from 'eventemitter2'\nimport {\n  ProviderMessageResponseCallback,\n  ProviderMessage,\n  EventType,\n  ProviderMessageRequest,\n  ProviderMessageResponse\n} from '../../types'\n\nexport interface Stream {\n  on(ev: string | symbol, fn: (...args: any[]) => void): void\n  writable: boolean\n  write(chunk: any, cb?: (error: Error | null | undefined) => void): boolean\n}\n\n// to be used on injected window.ethereum EIP1193 proxy\nexport abstract class BaseInjectedTransport extends EventEmitter {\n  protected responseCallbacks = new Map<number, ProviderMessageResponseCallback>()\n\n  private _messageIdx = 0\n  protected nextMessageIdx = () => ++this._messageIdx\n\n  constructor(private stream: Stream) {\n    super()\n\n    this.stream.on('data', this.handleMessage)\n  }\n\n  private handleMessage = (message: ProviderMessage<JsonRpcResponse>) => {\n    if (!message.type || !message.data) {\n      return\n    }\n\n    logger.info('[received message]', message)\n\n    const requestIdx = message.idx\n    const responseCallback = this.responseCallbacks.get(requestIdx)\n    if (requestIdx) {\n      this.responseCallbacks.delete(requestIdx)\n    }\n\n    switch (message.type) {\n      case EventType.MESSAGE:\n        if (responseCallback) {\n          this.emit(EventType.MESSAGE, message)\n          responseCallback(message.data.error, message)\n        } else {\n          // NOTE: this would occur if 'idx' isn't set, which should never happen\n          // or when we register two handler, or duplicate messages with the same idx are sent,\n          // all of which should be prevented prior to getting to this point\n          throw new Error('impossible state')\n        }\n        break\n      case EventType.DISCONNECT:\n      case EventType.ACCOUNTS_CHANGED:\n      case EventType.CHAIN_CHANGED:\n        this.emit(message.type, message.data)\n        break\n      default:\n        console.error('unknown message type', message)\n        break\n    }\n  }\n\n  protected sendMessageRequest = async (message: ProviderMessageRequest): Promise<ProviderMessageResponse> => {\n    return new Promise((resolve, reject) => {\n      if (!message.idx || message.idx <= 0) {\n        reject(new Error('message idx not set'))\n      }\n\n      const responseCallback: ProviderMessageResponseCallback = (error: any, response?: ProviderMessageResponse) => {\n        if (error) {\n          reject(error)\n        } else if (response) {\n          resolve(response)\n        } else {\n          throw new Error('no valid response to return')\n        }\n      }\n\n      const { idx } = message\n      if (!this.responseCallbacks.get(idx)) {\n        this.responseCallbacks.set(idx, responseCallback)\n      } else {\n        reject(new Error('duplicate message idx, should never happen'))\n      }\n\n      this.sendMessage(message)\n    })\n  }\n\n  private sendMessage(message: ProviderMessage<JsonRpcRequest>) {\n    if (!this.stream.writable) {\n      console.error('window post message stream is not writable')\n    }\n\n    this.stream.write(message)\n  }\n}\n","interface UnrealInjectedWindow {\n  ue?: {\n    sequencewallettransport?: {\n      logfromjs: (message: string) => void\n      warnfromjs: (message: string) => void\n      errorfromjs: (message: string) => void\n    }\n  }\n  logsOverriddenForUnreal?: boolean\n}\ndeclare const window: Window & typeof globalThis & UnrealInjectedWindow\n\n/**\n * This will redirect console logs from Sequence.js & the wallet to the Unreal console, for debugging purposes.\n */\nexport function overrideLogs(side: 'dapp' | 'wallet') {\n  if (window.ue?.sequencewallettransport && !window.logsOverriddenForUnreal) {\n    const t = window.ue?.sequencewallettransport\n    console.log = (...args: unknown[]) => {\n      t.logfromjs(`${side}: ${stringify(args)}`)\n    }\n    console.warn = (...args: unknown[]) => {\n      t.warnfromjs(`${side}: ${stringify(args)}`)\n    }\n    console.error = (...args: unknown[]) => {\n      t.errorfromjs(`${side}: ${stringify(args)}`)\n    }\n    window.logsOverriddenForUnreal = true\n  }\n}\n\nfunction stringify(things: unknown[]): string {\n  return things\n    .map(a => (typeof a === 'object' ? (a instanceof Error ? a.message : JSON.stringify(a)) : String(a)))\n    .join(' ')\n}\n","import { OpenWalletIntent, ProviderMessage, InitState, WindowSessionParams } from '../../types'\nimport { BaseProviderTransport } from '../base-provider-transport'\nimport { base64EncodeObject } from '@0xsequence/utils'\nimport { overrideLogs } from './overridelogs'\n\nlet registeredUnrealMessageProvider: UnrealMessageProvider | undefined\n\n// all lowercase is an annoying limitation of Unreal CEF BindUObject\ninterface UnrealInjectedSequenceJSWindow {\n  ue?: {\n    sequencewallettransport?: {\n      onmessagefromwallet?: (message: ProviderMessage<any>) => void\n      sendmessagetowallet: (message: string) => void\n    }\n  }\n}\n\ndeclare const window: Window & typeof globalThis & UnrealInjectedSequenceJSWindow\n\n/**\n * Initialized on dApp side\n */\nexport class UnrealMessageProvider extends BaseProviderTransport {\n  private walletURL: URL\n\n  constructor(walletAppURL: string) {\n    super()\n    this.walletURL = new URL(walletAppURL)\n  }\n\n  register = () => {\n    overrideLogs('dapp')\n    if (registeredUnrealMessageProvider) {\n      // overriding the registered message provider\n      registeredUnrealMessageProvider.unregister()\n      registeredUnrealMessageProvider = this\n    }\n\n    // listen for incoming messages from wallet\n    if (window.ue?.sequencewallettransport) {\n      window.ue.sequencewallettransport.onmessagefromwallet = this.onUnrealCallback\n    }\n    registeredUnrealMessageProvider = this\n\n    this._registered = true\n    console.log('registering transport!')\n  }\n\n  unregister = () => {\n    this._registered = false\n    this.closeWallet()\n\n    // disable message listener\n    if (registeredUnrealMessageProvider === this) {\n      registeredUnrealMessageProvider = undefined\n    }\n    if (window.ue?.sequencewallettransport?.onmessagefromwallet === this.onUnrealCallback) {\n      delete window.ue.sequencewallettransport.onmessagefromwallet\n    }\n\n    // clear event listeners\n    this.events.removeAllListeners()\n  }\n\n  openWallet = (path?: string, intent?: OpenWalletIntent, networkId?: string | number): void => {\n    if (this.isOpened()) {\n      // TODO focus wallet\n      console.log('wallet already open!')\n      return\n    }\n\n    console.log('opening wallet!')\n    // Instantiate new walletURL for this call\n    const walletURL = new URL(this.walletURL.href)\n    const windowSessionParams = new WindowSessionParams()\n\n    if (path) {\n      walletURL.pathname = path.toLowerCase()\n    }\n\n    // Set session, intent and network id on walletURL\n    this._init = InitState.NIL\n    this._sessionId = `${performance.now()}`\n    windowSessionParams.set('sid', this._sessionId)\n\n    if (intent) {\n      // encode intent as base64 url-encoded param\n      windowSessionParams.set('intent', base64EncodeObject(intent))\n    }\n    if (networkId) {\n      windowSessionParams.set('net', `${networkId}`)\n    }\n    // serialize params\n    walletURL.search = windowSessionParams.toString()\n\n    console.log('opening wallet to', walletURL.href)\n\n    window.open(walletURL.href)\n  }\n\n  closeWallet() {\n    this.close()\n  }\n\n  // onmessage, receives ProviderMessageResponse from the wallet unreal transport\n  private onUnrealCallback = (message: ProviderMessage<any>) => {\n    if (!message) {\n      throw new Error('ProviderMessage object is empty')\n    }\n\n    // handle message with base message provider\n    this.handleMessage(message)\n  }\n\n  // all lowercase is an annoying limitation of Unreal CEF BindUObject\n  sendMessage(message: ProviderMessage<unknown>) {\n    const postedMessage = typeof message !== 'string' ? JSON.stringify(message) : message\n    console.log('Sending message to wallet:', postedMessage)\n    window.ue?.sequencewallettransport?.sendmessagetowallet(postedMessage)\n  }\n}\n","import { BigNumberish, BytesLike, TypedDataDomain, TypedDataField } from 'ethers'\nimport { WalletContext, ChainIdLike } from '@0xsequence/network'\nimport { encodeMessageDigest, TypedData, encodeTypedDataDigest } from '@0xsequence/utils'\nimport { DecodedSignature, WalletConfig } from '@0xsequence/config'\nimport { Wallet } from '../wallet'\nimport { isValidSignature, prefixEIP191Message, recoverWalletConfig } from '../utils'\nimport { isValidEIP712Signature, isValidEthSignSignature } from '@0xsequence/wallet'\n\nexport class WalletUtils {\n  private wallet: Wallet\n\n  constructor(walletProvider: Wallet) {\n    this.wallet = walletProvider\n  }\n\n  // Sign message on a specified chain, or DefaultChain by default\n  signMessage(message: BytesLike, chainId?: ChainIdLike, allSigners?: boolean): Promise<string> {\n    const signer = this.wallet.getSigner()\n    if (!signer) throw new Error('unable to get signer')\n    return signer.signMessage(message, chainId, allSigners)\n  }\n\n  // Sign message on the AuthChain\n  async signAuthMessage(message: BytesLike, allSigners?: boolean): Promise<string> {\n    const signer = await this.wallet.getAuthSigner()\n    if (!signer) throw new Error('unable to get AuthChain signer')\n    return signer.signMessage(message, await signer.getChainId(), allSigners)\n  }\n\n  // Sign EIP-712 TypedData on a specified chain, or DefaultChain by default\n  signTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    message: Record<string, any>,\n    chainId?: ChainIdLike,\n    allSigners?: boolean\n  ): Promise<string> {\n    const signer = this.wallet.getSigner()\n    if (!signer) throw new Error('unable to get signer')\n    return signer.signTypedData(domain, types, message, chainId, allSigners)\n  }\n\n  // Sign EIP-712 TypedData on the AuthChain\n  async signAuthTypedData(\n    domain: TypedDataDomain,\n    types: Record<string, Array<TypedDataField>>,\n    message: Record<string, any>,\n    allSigners?: boolean\n  ): Promise<string> {\n    const signer = await this.wallet.getAuthSigner()\n    if (!signer) throw new Error('unable to get AuthChain signer')\n    return signer.signTypedData(domain, types, message, await signer.getChainId(), allSigners)\n  }\n\n  // Verify signature of a digest, one of a message, typedData or other\n  async isValidSignature(\n    address: string,\n    digest: Uint8Array,\n    signature: string,\n    chainId: number,\n    walletContext?: WalletContext\n  ): Promise<boolean> {\n    const provider = this.wallet.getProvider(chainId)\n    if (!provider) throw new Error(`unable to get provider for chainId ${chainId}`)\n    return isValidSignature(address, digest, signature, provider, chainId, walletContext)\n  }\n\n  // Verify message signature\n  async isValidMessageSignature(\n    address: string,\n    message: string | Uint8Array,\n    signature: string,\n    chainId: number,\n    walletContext?: WalletContext\n  ): Promise<boolean> {\n    const provider = this.wallet.getProvider(chainId)\n    if (!provider) throw new Error(`unable to get provider for chainId ${chainId}`)\n    const prefixed = prefixEIP191Message(message)\n    const digest = encodeMessageDigest(prefixed)\n    return isValidSignature(address, digest, signature, provider, chainId, walletContext)\n  }\n\n  // Verify typedData signature\n  isValidTypedDataSignature(\n    address: string,\n    typedData: TypedData,\n    signature: string,\n    chainId: number,\n    walletContext?: WalletContext\n  ): Promise<boolean> {\n    return this.isValidSignature(address, encodeTypedDataDigest(typedData), signature, chainId, walletContext)\n  }\n\n  // Recover the WalletConfig from a signature + digest combo\n  recoverWalletConfig = async (\n    address: string,\n    digest: BytesLike,\n    signature: string | DecodedSignature,\n    chainId: BigNumberish,\n    walletContext?: WalletContext\n  ): Promise<WalletConfig> => {\n    walletContext = walletContext || (await this.wallet.getWalletContext())\n    return recoverWalletConfig(address, digest, signature, chainId, walletContext)\n  }\n\n  // Recover the WalletConfig from a signature of a message\n  recoverWalletConfigFromMessage = async (\n    address: string,\n    message: string | Uint8Array,\n    signature: string | DecodedSignature,\n    chainId: BigNumberish,\n    walletContext?: WalletContext\n  ): Promise<WalletConfig> => {\n    walletContext = walletContext || (await this.wallet.getWalletContext())\n    return recoverWalletConfig(address, encodeMessageDigest(prefixEIP191Message(message)), signature, chainId, walletContext)\n  }\n\n  // Recover the WalletConfig from a signature of a typedData object\n  recoverWalletConfigFromTypedData = async (\n    address: string,\n    typedData: TypedData,\n    signature: string | DecodedSignature,\n    chainId: BigNumberish,\n    walletContext?: WalletContext\n  ): Promise<WalletConfig> => {\n    walletContext = walletContext || (await this.wallet.getWalletContext())\n    return recoverWalletConfig(address, encodeTypedDataDigest(typedData), signature, chainId, walletContext)\n  }\n\n  // sendTransaction()\n  // sendTransactions()\n\n  // sendETH()\n  // sendToken()\n  // sendCoin() -- sugar for sendToken()\n  // sendCollectible() -- sugar for sendToken()\n  // callContract()\n\n  // transactionHistory()\n  // getReceipt()\n  // getLogs()\n  // // ..\n\n  // isWalletDeployed()\n  // deployWallet()\n\n  // validateSignature()\n  // recoverWalletConfig()\n  // recoverAddress()\n}\n","import {\n  NetworkConfig,\n  WalletContext,\n  ChainIdLike,\n  JsonRpcSender,\n  JsonRpcRouter,\n  JsonRpcMiddleware,\n  allowProviderMiddleware,\n  CachedProvider,\n  loggingProviderMiddleware,\n  SigningProvider,\n  EagerProvider,\n  exceptionProviderMiddleware,\n  networkProviderMiddleware,\n  JsonRpcRequest,\n  findNetworkConfig,\n  updateNetworkConfig,\n  ensureValidNetworks,\n  sortNetworks\n} from '@0xsequence/network'\nimport { WalletConfig, WalletState } from '@0xsequence/config'\nimport { logger } from '@0xsequence/utils'\nimport { Web3Provider, Web3Signer } from './provider'\nimport {\n  MuxMessageProvider,\n  WindowMessageProvider,\n  ProxyMessageProvider,\n  ProxyMessageChannelPort,\n  UnrealMessageProvider\n} from './transports'\nimport { WalletSession, ProviderEventTypes, ConnectOptions, OpenWalletIntent, ConnectDetails } from './types'\nimport { ethers, providers } from 'ethers'\nimport { ExtensionMessageProvider } from './transports/extension-transport/extension-message-provider'\nimport { LocalStore, ItemStore, LocalStorage } from './utils'\nimport { WalletUtils } from './utils/index'\n\nimport { Runtime } from 'webextension-polyfill'\n\nexport interface WalletProvider {\n  connect(options?: ConnectOptions): Promise<ConnectDetails>\n  disconnect(): void\n\n  isConnected(): boolean\n  getSession(): WalletSession | undefined\n\n  getAddress(): Promise<string>\n  getNetworks(chainId?: ChainIdLike): Promise<NetworkConfig[]>\n  getChainId(): Promise<number>\n  getAuthChainId(): Promise<number>\n\n  isOpened(): boolean\n  openWallet(path?: string, intent?: OpenWalletIntent, networkId?: string | number): Promise<boolean>\n  closeWallet(): void\n\n  getProvider(chainId?: ChainIdLike): Web3Provider | undefined\n  getSigner(chainId?: ChainIdLike): Web3Signer\n\n  getWalletContext(): Promise<WalletContext>\n  getWalletConfig(chainId?: ChainIdLike): Promise<WalletConfig[]>\n  getWalletState(chainId?: ChainIdLike): Promise<WalletState[]>\n  isDeployed(chainId?: ChainIdLike): Promise<boolean>\n\n  getProviderConfig(): ProviderConfig\n\n  on<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]): void\n  once<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]): void\n\n  utils: WalletUtils\n}\n\nexport class Wallet implements WalletProvider {\n  public utils: WalletUtils\n\n  private config: ProviderConfig\n  private session?: WalletSession\n\n  private connectedSites: LocalStore<string[]>\n\n  private transport: {\n    // top-level provider which connects all transport layers\n    provider?: Web3Provider\n\n    // middleware stack for provider\n    router?: JsonRpcRouter\n    networkProvider?: JsonRpcMiddleware\n    allowProvider?: JsonRpcMiddleware\n    cachedProvider?: CachedProvider\n\n    // message communication\n    messageProvider?: MuxMessageProvider\n    windowMessageProvider?: WindowMessageProvider\n    proxyMessageProvider?: ProxyMessageProvider\n    extensionMessageProvider?: ExtensionMessageProvider\n    unrealMessageProvider?: UnrealMessageProvider\n  }\n\n  private networks: NetworkConfig[]\n  private providers: { [chainId: number]: Web3Provider }\n\n  constructor(network?: string | number, config?: Partial<ProviderConfig>) {\n    // config is a Partial, so that we may intersect it with the DefaultProviderConfig,\n    // which allows easy overriding and control of the config.\n    this.config = { ...DefaultProviderConfig }\n    if (config) {\n      this.config = { ...this.config, ...config }\n    }\n    if (network) {\n      this.config.defaultNetworkId = network\n    } else if (!this.config.defaultNetworkId) {\n      this.config.defaultNetworkId = 'mainnet'\n    }\n\n    if (config?.localStorage) {\n      LocalStorage.use(config.localStorage)\n    }\n\n    this.transport = {}\n    this.networks = []\n    this.providers = {}\n    this.connectedSites = new LocalStore('@sequence.connectedSites', [])\n    this.utils = new WalletUtils(this)\n    this.init()\n  }\n\n  private init = () => {\n    if (this.transport.provider) {\n      // init must have already been called\n      return\n    }\n\n    // Setup provider\n\n    this.transport.messageProvider = new MuxMessageProvider()\n\n    // multiple message provider setup, first one to connect will be the main transport\n    if (this.config.transports?.windowTransport?.enabled && typeof window === 'object') {\n      this.transport.windowMessageProvider = new WindowMessageProvider(this.config.walletAppURL)\n      this.transport.messageProvider.add(this.transport.windowMessageProvider)\n    }\n    if (this.config.transports?.proxyTransport?.enabled) {\n      this.transport.proxyMessageProvider = new ProxyMessageProvider(this.config.transports.proxyTransport.appPort!)\n      this.transport.messageProvider.add(this.transport.proxyMessageProvider)\n    }\n    if (this.config.transports?.extensionTransport?.enabled) {\n      this.transport.extensionMessageProvider = new ExtensionMessageProvider(this.config.transports.extensionTransport.runtime)\n      // this.transport.extensionMessageProvider.register()\n      this.transport.messageProvider.add(this.transport.extensionMessageProvider)\n\n      // NOTE/REVIEW: see note in mux-message-provider\n      //\n      // We don't add the extensionMessageProvider here because we don't send requests to it anyways, we seem to\n      // send all requests to the WindowMessageProvider anyways. By allowing it, if browser restarts, it will break\n      // the entire extension because messageProvider.provider will be undefined. So this is a hack to fix it.\n      //\n      // this.transport.messageProvider.add(this.transport.extensionMessageProvider)\n    }\n    if (this.config.transports?.unrealTransport?.enabled) {\n      this.transport.unrealMessageProvider = new UnrealMessageProvider(this.config.walletAppURL)\n      this.transport.messageProvider.add(this.transport.unrealMessageProvider)\n    }\n    this.transport.messageProvider.register()\n\n    // .....\n    this.transport.allowProvider = allowProviderMiddleware((request: JsonRpcRequest): boolean => {\n      if (request.method === 'sequence_setDefaultNetwork') return true\n\n      const isConnected = this.isConnected()\n      if (!isConnected) {\n        throw new Error('Sequence: wallet not connected')\n      }\n      return isConnected\n    })\n\n    // ...\n    this.transport.networkProvider = networkProviderMiddleware((request: JsonRpcRequest): number => {\n      // return stub chainId of 0 when not connected to any\n      if (!this.networks || this.networks.length === 0) return 0\n\n      // return the default chainId as we're connected\n      return this.networks.find(network => network.isDefaultChain)!.chainId\n    })\n\n    // Provider proxy to support middleware stack of logging, caching and read-only rpc calls\n    this.transport.cachedProvider = new CachedProvider()\n    this.transport.cachedProvider.onUpdate(() => {\n      if (!this.session) this.session = { providerCache: {} }\n      this.session.providerCache = this.transport.cachedProvider!.getCache()\n      this.saveSession(this.session)\n    })\n\n    // ..\n    this.transport.router = new JsonRpcRouter(\n      [\n        loggingProviderMiddleware,\n        this.transport.networkProvider,\n        this.transport.allowProvider,\n        exceptionProviderMiddleware,\n        this.transport.cachedProvider\n      ],\n      this.transport.messageProvider\n    )\n\n    this.transport.provider = new Web3Provider(this.transport.router)\n\n    // NOTE: we don't listen on 'connect' even here as we handle it within connect() method\n    // in more synchronous flow.\n\n    // below will update the wallet session object and persist it. In case the session\n    // is undefined, we consider the session to have been removed by the user, so we clear it.\n    this.transport.messageProvider.on('open', (openInfo: { session?: WalletSession }) => {\n      const { session } = openInfo\n      if (!session) {\n        if (this.session && this.session.accountAddress) {\n          // emit disconnect even if previously we had a session, and now we don't.\n          this.transport.messageProvider!.emit('disconnect')\n        }\n        this.clearSession()\n      } else {\n        this.useSession(session, true)\n      }\n    })\n\n    // below will update the account upon wallet connect/disconnect - aka, login/logout.\n    // if an origin is provided, this operation should be performed only on that origin\n    // and shouldn't affect the session of the wallet.\n    this.transport.messageProvider.on('accountsChanged', (accounts: string[], origin?: string) => {\n      if (origin) {\n        if (accounts.length > 0) {\n          this.useSession({ accountAddress: accounts[0] }, true)\n        }\n        return\n      }\n\n      if (!accounts || accounts.length === 0 || accounts[0] === '') {\n        this.clearSession()\n      } else {\n        this.useSession({ accountAddress: accounts[0] }, true)\n      }\n    })\n\n    // below will update the networks automatically when the wallet networks change\n    this.transport.messageProvider.on('networks', (networks: NetworkConfig[]) => {\n      this.useSession({ networks: networks }, true)\n    })\n\n    // below will update the wallet context automatically\n    this.transport.messageProvider.on('walletContext', (walletContext: WalletContext) => {\n      this.useSession({ walletContext: walletContext }, true)\n    })\n  }\n\n  loadSession = async (preferredNetwork?: string | number): Promise<WalletSession | undefined> => {\n    const data = await LocalStorage.getInstance().getItem('@sequence.session')\n    if (!data || data === '') {\n      return undefined\n    }\n\n    try {\n      const session = JSON.parse(data) as WalletSession\n      if (session) {\n        // Setting preferredNetwork as default network if it's in session.networks\n        if (preferredNetwork !== undefined) {\n          const preferredNetworkIdNum = typeof preferredNetwork === 'string' ? parseInt(preferredNetwork) : preferredNetwork\n          const isPreferredNetwork = (n: NetworkConfig) => n.name === preferredNetwork || n.chainId === preferredNetworkIdNum\n          const preferredNetworkInConfig = session.networks?.find(isPreferredNetwork)\n          const isAlreadyDefaultChain = preferredNetworkInConfig?.isDefaultChain\n\n          if (session.networks && preferredNetworkInConfig && !isAlreadyDefaultChain) {\n            const updatedNetworks = session.networks.map(n => ({ ...n, isDefaultChain: isPreferredNetwork(n) }))\n            session.networks = sortNetworks(updatedNetworks)\n            session.providerCache = undefined\n          }\n        }\n\n        this.useSession(session, true)\n      }\n      return session\n    } catch (err) {\n      logger.warn('loadSession failed, unable to parse session payload from storage.')\n      return undefined\n    }\n  }\n\n  connect = async (options?: ConnectOptions): Promise<ConnectDetails> => {\n    if (options?.refresh === true) {\n      this.disconnect()\n    }\n\n    if (\n      this.isConnected() &&\n      (await this.isSiteConnected(options?.origin)) &&\n      !!this.session &&\n      !options?.authorize &&\n      !options?.askForEmail\n    ) {\n      return {\n        connected: true,\n        session: this.session,\n        chainId: ethers.utils.hexlify(await this.getChainId())\n      }\n    }\n\n    if (options) {\n      if (options.authorize && (!options.app || options.app === '')) {\n        throw new Error(`connecting with 'authorize' option also requires 'app' to be set`)\n      }\n    }\n\n    await this.openWallet(undefined, { type: 'connect', options })\n\n    const connectDetails = await this.transport.messageProvider!.waitUntilConnected().catch((error): ConnectDetails => {\n      if (error instanceof Error) {\n        return { connected: false, error: error.message }\n      } else {\n        return { connected: false, error: JSON.stringify(error) }\n      }\n    })\n\n    if (connectDetails.connected) {\n      if (!!connectDetails.session) {\n        this.useSession(connectDetails.session, true)\n\n        this.addConnectedSite(options?.origin)\n      } else {\n        throw new Error('impossible state, connect response is missing session')\n      }\n    }\n\n    return connectDetails\n  }\n\n  async addConnectedSite(origin: string | undefined) {\n    origin = origin || window.location.origin\n\n    const connectedSites = await this.connectedSites.get()\n\n    if (connectedSites) {\n      if (connectedSites.includes(origin)) {\n        return\n      }\n      this.connectedSites.set([...connectedSites, origin])\n    } else {\n      this.connectedSites.set([origin])\n    }\n  }\n\n  async removeConnectedSite(origin: string) {\n    const authorized = await this.connectedSites.get()\n\n    if (authorized) {\n      this.connectedSites.set(authorized.filter(domain => domain !== origin))\n    }\n  }\n\n  getConnectedSites() {\n    return this.connectedSites.get()\n  }\n\n  async isSiteConnected(origin: string | undefined): Promise<boolean> {\n    const authorized = await this.connectedSites.get()\n\n    return !!authorized && authorized.includes(origin || window.location.origin)\n  }\n\n  authorize = async (options?: ConnectOptions): Promise<ConnectDetails> => {\n    return this.connect({ ...options, authorize: true })\n  }\n\n  disconnect(): void {\n    if (this.isOpened()) {\n      this.closeWallet()\n    }\n    this.clearSession()\n  }\n\n  // TODO: add switchNetwork(network: string | number) which will call wallet_switchEthereumChain\n  // and on successful response, will update the provider info here, etc.\n\n  getProviderConfig(): ProviderConfig {\n    return this.config\n  }\n\n  isOpened(): boolean {\n    return this.transport.messageProvider!.isOpened()\n  }\n\n  isConnected(): boolean {\n    return (\n      this.session !== undefined &&\n      this.session.networks !== undefined &&\n      this.session.networks.length > 0 &&\n      this.networks !== undefined &&\n      this.networks.length > 0 &&\n      !!this.session.accountAddress &&\n      this.session.accountAddress.startsWith('0x')\n    )\n  }\n\n  getSession = (): WalletSession | undefined => {\n    if (!this.isConnected()) {\n      return undefined\n    }\n    return this.session\n  }\n\n  getAddress = async (): Promise<string> => {\n    if (!this.isConnected()) {\n      throw new Error('connect first')\n    }\n    const session = this.getSession()\n    return session!.accountAddress!\n  }\n\n  getNetworks = async (chainId?: ChainIdLike): Promise<NetworkConfig[]> => {\n    if (!this.isConnected() || !this.networks) {\n      throw new Error('connect first')\n    }\n    if (chainId) {\n      // filter list to just the specific chain requested\n      const network = findNetworkConfig(this.networks, chainId)\n      return network ? [network] : []\n    }\n    return this.networks\n  }\n\n  // getChainId returns the default chain id\n  getChainId = async (): Promise<number> => {\n    if (!this.networks || this.networks.length < 1) {\n      throw new Error('networks have not been set by session. connect first.')\n    }\n\n    const network = this.networks.find(network => network.isDefaultChain)\n\n    if (!network) {\n      throw new Error('networks must have a default chain specified')\n    }\n\n    return network.chainId\n  }\n\n  getAuthChainId = async (): Promise<number> => {\n    if (!this.networks || this.networks.length < 1) {\n      throw new Error('networks have not been set by session. connect first.')\n    }\n\n    const network = this.networks.find(network => network.isAuthChain)\n\n    if (!network) {\n      throw new Error('networks must have an auth chain specified')\n    }\n\n    return network.chainId\n  }\n\n  openWallet = async (path?: string, intent?: OpenWalletIntent, networkId?: string | number): Promise<boolean> => {\n    if (intent?.type !== 'connect' && !this.isConnected()) {\n      throw new Error('connect first')\n    }\n\n    let currentNetworkId\n\n    if (!this.networks || this.networks.length < 1) {\n      currentNetworkId = this.config.defaultNetworkId\n    } else {\n      currentNetworkId = await this.getChainId()\n    }\n\n    this.transport.messageProvider!.openWallet(path, intent, networkId || currentNetworkId)\n    await this.transport.messageProvider!.waitUntilOpened()\n\n    return true\n  }\n\n  closeWallet = (): void => {\n    this.transport.messageProvider!.closeWallet()\n  }\n\n  getProvider(chainId?: ChainIdLike): Web3Provider | undefined {\n    // return the top-level provider message transport when chainId is unspecified\n    // and user has not logged in\n    if (!this.isConnected()) {\n      if (chainId) {\n        throw new Error(`session is empty. connect and try again.`)\n      } else {\n        return this.transport.provider\n      }\n    }\n\n    let network: NetworkConfig | undefined = this.networks.find(network => network.isDefaultChain)!\n    if (chainId) {\n      network = findNetworkConfig(this.networks, chainId)\n      if (!network) {\n        throw new Error(`network ${chainId} is not in the network list`)\n      }\n    }\n\n    // return memoized network provider\n    if (this.providers[network.chainId]) {\n      return this.providers[network.chainId]\n    }\n\n    // builder web3 provider stack\n    let provider: Web3Provider\n\n    // network.provider may be set by the ProviderConfig override\n    const rpcProvider = network.provider ? network.provider : new providers.JsonRpcProvider(network.rpcUrl, network.chainId)\n\n    if (network.isDefaultChain) {\n      // communicating with defaultChain will prioritize the wallet message transport\n      const router = new JsonRpcRouter(\n        [\n          loggingProviderMiddleware,\n          exceptionProviderMiddleware,\n          new EagerProvider({ accountAddress: this.session!.accountAddress, walletContext: this.session!.walletContext }),\n          new SigningProvider(this.transport!.provider!),\n          this.transport.cachedProvider!\n        ],\n        new JsonRpcSender(rpcProvider)\n      )\n\n      provider = new Web3Provider(router, network.chainId)\n    } else {\n      // communicating with another chain will bind to that network, but will forward\n      // any signing-related requests to the wallet message transport\n      const router = new JsonRpcRouter(\n        [\n          loggingProviderMiddleware,\n          exceptionProviderMiddleware,\n          new EagerProvider({\n            accountAddress: this.session!.accountAddress,\n            walletContext: this.session!.walletContext,\n            chainId: network.chainId\n          }),\n          new SigningProvider(this.transport.provider!),\n          new CachedProvider({ defaultChainId: network.chainId })\n        ],\n        new JsonRpcSender(rpcProvider)\n      )\n\n      provider = new Web3Provider(router, network.chainId)\n    }\n\n    this.providers[network.chainId] = provider\n    return provider\n  }\n\n  async getAuthProvider(): Promise<Web3Provider> {\n    return this.getProvider((await this.getAuthNetwork()).chainId)!\n  }\n\n  async getAuthNetwork(): Promise<NetworkConfig> {\n    return (await this.getNetworks()).find(n => n.isAuthChain)!\n  }\n\n  getAllProviders(): { [chainId: number]: Web3Provider } {\n    return this.providers\n  }\n\n  getSigner(chainId?: ChainIdLike): Web3Signer {\n    return this.getProvider(chainId)!.getSigner()\n  }\n\n  async getAuthSigner(): Promise<Web3Signer> {\n    return (await this.getAuthProvider()).getSigner()\n  }\n\n  getWalletConfig(chainId?: ChainIdLike): Promise<WalletConfig[]> {\n    return this.getSigner().getWalletConfig(chainId)\n  }\n\n  getWalletState(chainId?: ChainIdLike): Promise<WalletState[]> {\n    return this.getSigner().getWalletState(chainId)\n  }\n\n  getWalletContext(): Promise<WalletContext> {\n    return this.getSigner().getWalletContext()\n  }\n\n  isDeployed(chainId?: ChainIdLike): Promise<boolean> {\n    return this.getSigner(chainId).isDeployed()\n  }\n\n  on<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    this.transport.messageProvider!.on(event, fn)\n  }\n\n  once<K extends keyof ProviderEventTypes>(event: K, fn: ProviderEventTypes[K]) {\n    this.transport.messageProvider!.once(event, fn)\n  }\n\n  unregister = () => {\n    this.disconnect()\n    this.transport.messageProvider?.unregister()\n  }\n\n  private saveSession = async (session: WalletSession) => {\n    logger.debug('wallet provider: saving session')\n    const data = JSON.stringify(session)\n    await LocalStorage.getInstance().setItem('@sequence.session', data)\n  }\n\n  private useSession = async (session: WalletSession, autoSave: boolean = true) => {\n    if (!this.session) this.session = {}\n\n    // setup wallet context\n    if (this.config.walletContext) {\n      this.session.walletContext = this.config.walletContext\n    } else if (session.walletContext) {\n      this.session.walletContext = session.walletContext\n    }\n\n    // setup account\n    if (session.accountAddress) {\n      this.useAccountAddress(session.accountAddress)\n    }\n\n    // setup networks\n    if (session.networks) {\n      this.useNetworks(session.networks)\n    }\n\n    // setup provider cache\n    if (session.providerCache) {\n      this.transport.cachedProvider!.setCache(session.providerCache)\n    } else {\n      this.transport.cachedProvider!.clearCache()\n    }\n\n    // persist\n    if (autoSave) {\n      this.saveSession(this.session)\n    }\n  }\n\n  private useAccountAddress(accountAddress: string) {\n    if (!this.session) this.session = {}\n    this.session.accountAddress = ethers.utils.getAddress(accountAddress)\n  }\n\n  private useNetworks(networks: NetworkConfig[]) {\n    // set networks in the session\n    if (!this.session) this.session = {}\n\n    // set networks on session object\n    this.session.networks = networks\n\n    // short-circuit if setting empty network list (aka logged out state)\n    if (!this.session.networks || this.session.networks.length === 0) {\n      return\n    }\n\n    // check if any custom network settings, otherwise return early\n    if (!this.config.networks && !this.config.networkRpcUrl) {\n      this.networks = networks\n      return\n    }\n\n    // init networks\n    this.networks = networks\n\n    // combine custom network config with networks in the session\n    if (this.config.networks) {\n      this.networks = networks.map(n => ({ ...n })) // copy\n      this.config.networks.forEach(n => {\n        const network = findNetworkConfig(this.networks, n.chainId || n.name!)\n        if (!network) return\n        updateNetworkConfig(n, network)\n      })\n      ensureValidNetworks(this.networks, true)\n    }\n\n    // an extra override for convenience\n    if (this.config.networkRpcUrl) {\n      const network = this.networks.find(network => network.isDefaultChain)\n      if (network) {\n        network.rpcUrl = this.config.networkRpcUrl\n      }\n    }\n  }\n\n  private clearSession(): void {\n    logger.debug('wallet provider: clearing session')\n    LocalStorage.getInstance().removeItem('@sequence.session')\n    this.session = undefined\n    this.networks = []\n    this.providers = {}\n    this.transport.cachedProvider?.clearCache()\n  }\n}\n\nexport interface ProviderConfig {\n  // The local storage dependency for the wallet provider, defaults to window.localStorage.\n  // For example, this option should be used when using React Native since window.localStorage is not available.\n  localStorage?: ItemStore\n\n  // Sequence Wallet App URL, default: https://sequence.app\n  walletAppURL: string\n\n  // Sequence Wallet Session URL, default: https://session.sequence.app\n  // walletSessionURL: string\n\n  // networks is a configuration list of networks used by the wallet. This list\n  // is combined with the network list supplied from the wallet upon login,\n  // and settings here take precedence such as overriding a relayer setting, or rpcUrl.\n  networks?: Partial<NetworkConfig>[]\n\n  // networkRpcUrl will set the provider rpcUrl of the default network\n  networkRpcUrl?: string\n\n  // defaultNetworkId is the primary network of a dapp and the default network a\n  // provider will communicate. Note: this setting is also configurable from the\n  // Wallet constructor's first argument.\n  defaultNetworkId?: string | number\n\n  // transports for dapp to wallet jron-rpc communication\n  transports?: {\n    // WindowMessage transport (optional)\n    windowTransport?: {\n      enabled: boolean\n    }\n\n    // ProxyMessage transport (optional)\n    proxyTransport?: {\n      enabled: boolean\n      appPort?: ProxyMessageChannelPort\n    }\n\n    // Extension transport (optional)\n    extensionTransport?: {\n      enabled: boolean\n      runtime: Runtime.Static\n    }\n\n    // Unreal Engine transport (optional)\n    unrealTransport?: {\n      enabled: boolean\n    }\n  }\n\n  // Sequence Wallet Modules Context override. By default (and recommended), the\n  // WalletContext used the one returned by the wallet app upon login.\n  //\n  // NOTE: do not use this option unless you know what you're doing\n  walletContext?: WalletContext\n}\n\nexport const DefaultProviderConfig: ProviderConfig = {\n  walletAppURL: 'https://sequence.app',\n\n  // walletSessionURL: 'https://session.sequence.app',\n\n  transports: {\n    windowTransport: { enabled: true },\n    proxyTransport: { enabled: false }\n  }\n}\n\nlet walletInstance: Wallet | undefined\n\nexport const initWallet = async (network?: string | number, config?: Partial<ProviderConfig>) => {\n  if (walletInstance) {\n    return walletInstance\n  }\n  walletInstance = new Wallet(network, config)\n  await walletInstance.loadSession(network)\n  return walletInstance\n}\n\nexport const unregisterWallet = () => {\n  if (!walletInstance) return\n  walletInstance.closeWallet()\n  walletInstance.unregister()\n}\n\nexport const getWallet = () => {\n  if (!walletInstance) {\n    throw new Error('Wallet has not been initialized, call sequence.initWallet(network, config) first.')\n  }\n  return walletInstance\n}\n","import { BaseWalletTransport } from '../base-wallet-transport'\nimport { WalletRequestHandler } from '../wallet-request-handler'\nimport { InitState, ProviderMessage } from '../../types'\nimport { ProxyMessageChannelPort } from './proxy-message-channel'\n\nexport class ProxyMessageHandler extends BaseWalletTransport {\n  private port: ProxyMessageChannelPort\n\n  constructor(walletRequestHandler: WalletRequestHandler, port: ProxyMessageChannelPort) {\n    super(walletRequestHandler)\n    this.port = port\n    this._init = InitState.OK\n  }\n\n  register() {\n    this.port.handleMessage = (message: ProviderMessage<any>): void => {\n      this.handleMessage(message)\n    }\n    this._registered = true\n  }\n\n  // note: we can't decide whether to restore the session within register(), because session info is\n  // received asyncronously via EventType.OPEN after register() is executed.\n  // And in the case of a redirect/reload, EventType.OPEN is not sent at all,\n  // because the wallet is already open.\n  //\n  // call this method from wallet redirect hander when a session restore is needed\n  async restoreSession() {\n    const cachedSession = await this.getCachedTransportSession()\n    if (cachedSession) {\n      this.open(cachedSession)\n    }\n  }\n\n  unregister() {\n    // @ts-ignore\n    this.port.handleMessage = undefined\n    this._registered = false\n  }\n\n  sendMessage(message: ProviderMessage<any>) {\n    this.port.sendMessage(message)\n  }\n}\n","import {\n  ProviderMessageRequest,\n  ProviderMessage,\n  EventType,\n  InitState,\n  WindowSessionParams,\n  OpenWalletIntent,\n  ProviderRpcError,\n  TransportSession\n} from '../../types'\nimport { WalletRequestHandler } from '../wallet-request-handler'\nimport { BaseWalletTransport } from '../base-wallet-transport'\nimport { logger, sanitizeNumberString, base64DecodeObject } from '@0xsequence/utils'\n\nexport class WindowMessageHandler extends BaseWalletTransport {\n  protected parentWindow: Window\n\n  private _isPopup: boolean = false\n\n  constructor(walletRequestHandler: WalletRequestHandler) {\n    super(walletRequestHandler)\n    this._init = InitState.NIL\n  }\n\n  async register(windowHref?: any) {\n    const isPopup = parent.window.opener !== null\n    this._isPopup = isPopup\n    if (isPopup !== true) {\n      return\n    }\n\n    // record open details (sessionId + default network) from the window url\n    const { pathname, search: rawParams } = new URL(windowHref || window.location.href)\n\n    let session: TransportSession | null = this.getWindowTransportSession(rawParams)\n\n    // provider should always include sid when opening a new window\n    const isNewWindowSession = !!session.sessionId\n\n    // attempt to restore previous session in the case of a redirect or window reload\n    if (!isNewWindowSession) {\n      session = await this.getCachedTransportSession()\n    }\n\n    if (!session) {\n      logger.error('window session is undefined')\n      return\n    }\n\n    // record parent window instance for communication\n    this.parentWindow = parent.window.opener\n\n    // listen for window-transport requests\n    window.addEventListener('message', this.onWindowEvent, false)\n    this._registered = true\n\n    // send open event to the app which opened us\n    this.open(session)\n      .then(opened => {\n        if (!opened) {\n          const err = `failed to open to network ${session?.networkId}`\n          logger.error(err)\n          this.notifyClose({ message: err } as ProviderRpcError)\n          window.close()\n        }\n      })\n      .catch(e => {\n        const err = `failed to open to network ${session?.networkId}, due to: ${e}`\n        logger.error(err)\n        this.notifyClose({ message: err } as ProviderRpcError)\n        window.close()\n      })\n  }\n\n  unregister() {\n    window.removeEventListener('message', this.onWindowEvent)\n    this._registered = false\n  }\n\n  // onmessage is called when (the wallet) receives request messages from the dapp\n  // over the window post-messaging transport\n  private onWindowEvent = async (event: MessageEvent) => {\n    if (!event.origin || event.origin === '') {\n      // skip same-origin or when event.origin is empty/undefined\n      return\n    }\n    if (this.appOrigin && event.origin !== this.appOrigin) {\n      // skip message as not from expected app origin\n      return\n    }\n\n    // Wallet always expects json-rpc request messages from a dapp\n    let request: ProviderMessageRequest\n    try {\n      request = JSON.parse(event.data)\n    } catch (err) {\n      // event is not a ProviderMessage JSON object, skip\n      return\n    }\n\n    logger.debug('RECEIVED MESSAGE', request)\n\n    // Record event origin for valid init ack\n    if (this._init !== InitState.OK && this.isValidInitAck(request)) {\n      this.appOrigin = event.origin\n    }\n    if (this._init === InitState.OK && (!this.appOrigin || this.appOrigin.length < 8)) {\n      // impossible state\n      logger.error('impossible state, init.OK and appOrigin required')\n      return\n    }\n\n    // Handle message via the base transport\n    this.handleMessage(request)\n  }\n\n  // postMessage sends message to the dapp window\n  sendMessage(message: ProviderMessage<any>) {\n    // prepare payload\n    const payload = JSON.stringify(message)\n\n    // post-message to app.\n    // only for init requests, we send to '*' origin\n    if (message.type === EventType.INIT) {\n      this.postMessage(payload, true)\n    } else {\n      this.postMessage(payload)\n    }\n  }\n\n  get isPopup(): boolean {\n    return this._isPopup\n  }\n\n  private postMessage(message: any, init = false) {\n    if (init !== true && this._init !== InitState.OK) {\n      logger.error('impossible state, should not be calling postMessage until inited')\n      return\n    }\n\n    if (init) {\n      // init message transmission to global target -- for 'init' payloads only\n      this.parentWindow.postMessage(message, '*')\n    } else {\n      // open message transmission\n      if (this.appOrigin && this.appOrigin.length > 4) {\n        // just above '.com'\n        this.parentWindow.postMessage(message, this.appOrigin)\n      } else {\n        logger.error('unable to postMessage as parentOrigin is invalid')\n      }\n    }\n  }\n\n  private getWindowTransportSession = (windowParams: string | undefined): TransportSession => {\n    const params = new WindowSessionParams(windowParams)\n    return {\n      sessionId: params.get('sid'),\n      networkId: params.get('net'),\n      intent: base64DecodeObject<OpenWalletIntent>(params.get('intent'))\n    }\n  }\n}\n","import {\n  ProviderMessageRequest,\n  ProviderMessage,\n  EventType,\n  InitState,\n  WindowSessionParams,\n  OpenWalletIntent,\n  ProviderRpcError,\n  TransportSession\n} from '../../types'\nimport { WalletRequestHandler } from '../wallet-request-handler'\nimport { BaseWalletTransport } from '../base-wallet-transport'\nimport { logger, base64DecodeObject } from '@0xsequence/utils'\nimport { overrideLogs } from './overridelogs'\n\n// all lowercase is an annoying limitation of Unreal CEF BindUObject\ninterface UnrealInjectedWalletWindow {\n  ue?: {\n    sequencewallettransport?: {\n      onmessagefromsequencejs?: (message: ProviderMessageRequest) => void\n      sendmessagetosequencejs: (message: string) => void\n    }\n  }\n}\ndeclare const window: Window & typeof globalThis & UnrealInjectedWalletWindow\n\n/**\n * Initialized on Wallet side\n */\nexport class UnrealMessageHandler extends BaseWalletTransport {\n  constructor(walletRequestHandler: WalletRequestHandler) {\n    super(walletRequestHandler)\n    this._init = InitState.NIL\n  }\n\n  async register(windowHref?: string | URL) {\n    if (window.ue?.sequencewallettransport === undefined) {\n      return\n    }\n    overrideLogs('wallet')\n\n    // record open details (sessionId + default network) from the window url\n    const { search: rawParams } = new URL(windowHref || window.location.href)\n\n    let session: TransportSession | null = this.getUnrealTransportSession(rawParams)\n\n    // provider should always include sid when opening a new window\n    const isNewWindowSession = !!session.sessionId\n\n    // attempt to restore previous session in the case of a redirect or window reload\n    if (!isNewWindowSession) {\n      session = await this.getCachedTransportSession()\n    }\n\n    if (!session) {\n      logger.error('unreal session is undefined')\n      return\n    }\n\n    // listen for window-transport requests\n    window.ue.sequencewallettransport.onmessagefromsequencejs = this.onMessageFromUnreal\n    this._registered = true\n\n    // send open event to the app which opened us\n    this.open(session)\n      .then(opened => {\n        if (!opened) {\n          const err = `failed to open to network ${session?.networkId}`\n          logger.error(err)\n          this.notifyClose({ message: err } as ProviderRpcError)\n          window.close()\n        }\n      })\n      .catch(e => {\n        const err = `failed to open to network ${session?.networkId}, due to: ${e}`\n        logger.error(err)\n        this.notifyClose({ message: err } as ProviderRpcError)\n        window.close()\n      })\n  }\n\n  unregister() {\n    if (window.ue?.sequencewallettransport?.onmessagefromsequencejs === this.onMessageFromUnreal) {\n      delete window.ue.sequencewallettransport.onmessagefromsequencejs\n    }\n    this._registered = false\n  }\n\n  // onmessage is called when (the wallet) receives request messages from the dapp\n  // over the unreal json-messaging transport\n  private onMessageFromUnreal = (request: ProviderMessageRequest) => {\n    // Wallet always expects json-rpc request messages from a dapp\n\n    logger.debug('RECEIVED MESSAGE', request)\n\n    // Handle message via the base transport\n    this.handleMessage(request)\n  }\n\n  // sendMessage sends message to the dapp window\n  sendMessage(message: ProviderMessage<any>) {\n    if (message.type !== EventType.INIT && this._init !== InitState.OK) {\n      logger.error('impossible state, should not be calling postMessage until inited')\n      return\n    }\n    // prepare payload\n    const payload = JSON.stringify(message)\n\n    // post-message to app.\n    window.ue?.sequencewallettransport?.sendmessagetosequencejs(payload)\n  }\n\n  private getUnrealTransportSession = (windowParams: string | undefined): TransportSession => {\n    const params = new WindowSessionParams(windowParams)\n    return {\n      sessionId: params.get('sid'),\n      networkId: params.get('net'),\n      intent: base64DecodeObject<OpenWalletIntent>(params.get('intent'))\n    }\n  }\n}\n","import { Signer as AbstractSigner, ethers, providers } from 'ethers'\nimport { walletContracts } from '@0xsequence/abi'\nimport { SignedTransactions, Transaction, sequenceTxAbiEncode, TransactionResponse } from '@0xsequence/transactions'\nimport { WalletContext } from '@0xsequence/network'\nimport { WalletConfig } from '@0xsequence/config'\nimport { logger } from '@0xsequence/utils'\nimport { FeeOption, FeeQuote, Relayer } from '.'\nimport { ProviderRelayer, ProviderRelayerOptions } from './provider-relayer'\n\nexport type LocalRelayerOptions = Omit<ProviderRelayerOptions, \"provider\"> & {\n  signer: AbstractSigner\n}\n\nexport function isLocalRelayerOptions(obj: any): obj is LocalRelayerOptions {\n  return obj.signer !== undefined && AbstractSigner.isSigner(obj.signer)\n}\n\nexport class LocalRelayer extends ProviderRelayer implements Relayer {\n  private signer: AbstractSigner\n  private txnOptions: providers.TransactionRequest\n\n  constructor(options: LocalRelayerOptions | AbstractSigner) {\n    super(AbstractSigner.isSigner(options) ? { provider: options.provider! } : { ...options, provider: options.signer.provider! })\n    this.signer = AbstractSigner.isSigner(options) ? options : options.signer\n    if (!this.signer.provider) throw new Error(\"Signer must have a provider\")\n  }\n\n  async deployWallet(config: WalletConfig, context: WalletContext): Promise<TransactionResponse> {\n    // NOTE: on hardhat some tests fail on HookCallerMock when not passing gasLimit directly as below,\n    // and using eth_gasEstimate. Perhaps review HookCallerMock.sol and fix it to avoid what looks\n    // like an infinite loop?\n    const walletDeployTxn = this.prepareWalletDeploy(config, context)\n\n    // NOTE: for hardhat to pass, we have to set the gasLimit directly, as its unable to estimate\n    return this.signer.sendTransaction({ ...walletDeployTxn, gasLimit: ethers.constants.Two.pow(17) } )\n  }\n\n  async getFeeOptions(\n    _config: WalletConfig,\n    _context: WalletContext,\n    ..._transactions: Transaction[]\n  ): Promise<{ options: FeeOption[] }> {\n    return { options: [] }\n  }\n\n  async gasRefundOptions(\n    config: WalletConfig,\n    context: WalletContext,\n    ...transactions: Transaction[]\n  ): Promise<FeeOption[]> {\n    const { options } = await this.getFeeOptions(config, context, ...transactions)\n    return options\n  }\n\n  setTransactionOptions(transactionRequest: providers.TransactionRequest) {\n    this.txnOptions = transactionRequest\n  }\n\n  async relay(signedTxs: SignedTransactions, quote?: FeeQuote, waitForReceipt: boolean = true): Promise<TransactionResponse<providers.TransactionReceipt>> {\n    if (quote !== undefined) {\n      logger.warn(`LocalRelayer doesn't accept fee quotes`)\n    }\n\n    if (!signedTxs.context.guestModule || signedTxs.context.guestModule.length !== 42) {\n      throw new Error('LocalRelayer requires the context.guestModule address')\n    }\n\n    const { to, execute } = await this.prependWalletDeploy(signedTxs)\n\n    const walletInterface = new ethers.utils.Interface(walletContracts.mainModule.abi)\n    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [\n      sequenceTxAbiEncode(execute.transactions),\n      execute.nonce,\n      execute.signature\n    ])\n\n    // TODO: think about computing gas limit individually, summing together and passing across\n    // NOTE: we expect that all txns have set their gasLimit ahead of time through proper estimation\n    // const gasLimit = signedTxs.transactions.reduce((sum, tx) => sum.add(tx.gasLimit), ethers.BigNumber.from(0))\n    // txRequest.gasLimit = gasLimit\n\n    const responsePromise = this.signer.sendTransaction({ to, data, ...this.txnOptions })\n\n    if (waitForReceipt) {\n      const response: TransactionResponse = await responsePromise\n      response.receipt = await response.wait()\n      return response\n    } else {\n      return responsePromise\n    }\n  }\n}\n","export function queryStringFromObject(name: string, obj: any) {\n  const k = encodeURIComponent(name)\n  const v = encodeURIComponent(JSON.stringify(obj))\n  return `${k}=${v}`\n}\n\nexport function queryStringToObject(qs: string): {[key:string]: any} {\n  const p = qs.split('&')\n  const o: {[key:string]: any} = {}\n  for (const v of p) {\n    const z = v.split('=')\n    o[decodeURIComponent(z[0])] = JSON.parse(decodeURIComponent(z[1]))\n  }\n  return o\n}\n","export const sleep = (t: number) => {\n  return new Promise<void>(resolve => {\n    const timeout = setTimeout(() => {\n      clearTimeout(timeout)\n      resolve()\n    }, t)\n  })\n}\n","// urlClean removes double slashes from url path\nexport const urlClean = (url: string) => url.replace(/([^:]\\/)\\/+/g, '$1')\n"],"names":["walletContracts","erc1271","type","name","constant","inputs","outputs","payable","stateMutability","isValidSignatureBytes32","factory","mainModule","components","mainModuleUpgradable","sequenceUtils","internalType","anonymous","indexed","requireFreshSigner","SmartRampOrderStatus","SmartRampTxnStatus","SortOrder","API","constructor","hostname","fetch","this","path","ping","headers","url","createHTTPRequest","then","res","buildResponse","_data","status","version","runtimeStatus","getSequenceContext","data","getAuthToken","args","jwtToken","address","user","sendPasswordlessLink","friendList","page","friends","getFriendByAddress","friend","searchFriends","addFriend","updateFriendNickname","removeFriend","contractCall","returns","decodeContractCall","call","lookupContractCallSelectors","signatures","userStorageFetch","object","userStorageSave","ok","userStorageDelete","userStorageFetchAll","objects","getMoonpayLink","signedUrl","getSardineClientToken","token","isUsingGoogleMail","yes","resolveENSAddress","isValidSignature","isValid","isValidMessageSignature","isValidTypedDataSignature","isValidETHAuthProof","getCoinPrices","tokenPrices","getCollectiblePrices","getExchangeRate","exchangeRate","memoryStore","memoryLoad","value","listPayCardsOnFile","payCards","savePayCard","payCard","updatePayCardCVC","deletePayCard","smartRampQuote","quoteDetails","smartRampPurchase","processing","receipt","smartRampWaitOrderConfirmation","done","smartRampGetOrder","order","smartRampCheckCardAuthorization","cardAuth","smartRampOrdersList","orders","smartRampGetOrderTxnHash","txnHash","txnSuccessful","smartRampSubmitCardAuthorization","adminSmartRampGetOrder","adminSmartRampListCompletedOrders","adminSmartRampListPendingOrders","pendingOrders","getInviteInfo","inviteInfo","isValidAccessCode","internalClaimAccessCode","walletRecover","encryptedWallet","blockNumberAtTime","blocks","paperSessionSecret","secret","paperSessionSecret2","input","init","body","method","JSON","stringify","text","parse","err","code","msg","global","window","SequenceAPIClient","ApiRpc","jwtAuth","super","endsWith","slice","_fetch","length","_hasatob","atob","_hasbtoa","btoa","_hasBuffer","Buffer","_TD","TextDecoder","undefined","_TE","TextEncoder","b64chs","Array","prototype","b64tab","a","tab","forEach","c","i","b64re","_fromCC","String","fromCharCode","bind","_U8Afrom","Uint8Array","from","it","fn","x","map","_mkUriSafe","src","replace","m0","_tidyB64","s","btoaPolyfill","bin","u32","c0","c1","c2","asc","pad","charCodeAt","TypeError","substring","_btoa","toString","_fromUint8Array","u8a","strs","l","push","apply","subarray","join","cb_utob","cc","re_utob","utob","u","_encode","encode","urlsafe","re_btou","cb_btou","cccc","offset","btou","b","atobPolyfill","test","u24","r1","r2","charAt","_atob","_toUint8Array","_decode","decode","_unURI","gBase64","__assign","Object","assign","t","n","arguments","p","hasOwnProperty","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","result","__generator","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","pop","Proof","prefix","ETHAuthPrefix","toLowerCase","claims","app","iat","exp","ETHAuthVersion","signature","extra","setIssuedAtNow","Math","round","Date","getTime","setExpiryIn","seconds","validateClaims","messageDigest","typedData","ethers","utils","arrayify","messageTypedData","_TypedDataEncoder","hash","domain","types","message","ETHAuthEIP712Domain","Claims","typ","ogn","Error","now","max","ValidateEOAProof","provider","chainId","proof","_a","verifyMessage","ValidateContractAccountProof","walletCode","abi","getCode","Contract","IsValidSignatureBytes32MagicValue","ETHAuth","validators","_i","_this","configJsonRpcProvider","ethereumJsonRpcURL","netVersion","providers","JsonRpcProvider","send","parseInt","NaN","configValidators","encodeProof","skipSignatureValidation","claimsJSON","proofString","validateProof","Base64","decodeProof","parts","messageBase64","split","isValidClaims","validateProofClaims","concat","validateProofSignature","retIsValid","validator","WalletContractBytecode","listKey","configKey","imageHash","storage","localStorage","_unused","Map","getItem","key","_map$get","get","setItem","set","removeItem","delete","getCachedConfig","_storage$getItem","config","pushImageHash","_storage$getItem2","imageHashes","filter","shift","isUsableConfig","signers","reduce","BigNumber","weight","add","constants","Zero","gte","threshold","addressOf","salt","context","ignoreAddress","codeHash","keccak256","solidityPack","hexZeroPad","getAddress","hexDataSlice","sortConfig","signer","defaultAbiCoder","cacheConfig","sort","compareAddr","indexOf","isConfigEqual","bigA","bigB","lt","eq","editConfig","normSigner","toNumber","normSrcSigners","normSetSigners","normDelAddress","del","normSetAddress","newSigners","genConfig","base64EncodeObject","obj","base64DecodeObject","encodedObject","encodeMessageDigest","toUtf8Bytes","packMessageData","walletAddress","digest","subDigestOf","isNode","jwtDecodeClaims","jwt","logLevel","Logger","configure","_extends","DEBUG","INFO","WARN","ERROR","DISABLED","silence","debug","optionalParams","console","log","info","warn","onwarn","error","onerror","logger","promisify","thisContext","async","getRandomInt","min","Number","MAX_SAFE_INTEGER","ceil","floor","random","sanitizeNumberString","numString","match","trim","sanitizeAlphanumeric","alphanum","sanitizeHost","host","encodeTypedDataHash","encodeTypedDataDigest","defineReadOnly","getStatic","resolveProperties","checkProperties","shallowCopy","deepCopy","isBigNumberish","isBigNumber","isHexString","isBytes","SequenceUtilsFinder","authProvider","findCurrentConfig","ignoreIndex","requireIndex","skipCache","chainIdPromise","getNetwork","knownConfigs","findCurrentImageHash","found","findConfigForImageHash","findLastWalletOfInitialSigner","authContract","logBlockHeight","lastSignerUpdate","wallet","filters","RequiredSigner","lastLog","findLatestLog","fromBlock","toBlock","interface","decodeEventLog","topics","_wallet","image","find","kc","cached","imageHashHeight","lastImageHashUpdate","RequiredConfig","event","_signers","_threshold","walletContract","currentImageHash","functions","catch","normalizedAddress","knownImageHash","knownImageHashes","HashZero","findFirstLog","gotImageHash","getBlockNumber","logs","getLogs","pivot","nhalf","JsonRpcMethod","partition","array","callback","element","getChainId","maybeChainId","getAuthNetwork","networks","network","isAuthChain","isValidNetworkConfig","networkConfig","raise","skipRelayerCheck","configs","isArray","chainIds","dupes","names","nameDupes","defaultChain","authChain","rpcUrl","relayer","isDefaultChain","ensureValidNetworks","updateNetworkConfig","dest","validateAndSortNetworks","sortNetworks","findNetworkConfig","startsWith","id","defaultConfigIdx","findIndex","splice","authConfigIdx","stringTemplate","sTemplate","mData","fullMath","grp","val","valueOf","ChainId","indexerURL","relayerURL","nodesURL","MAINNET","title","blockExplorer","rootUrl","ensAddress","ROPSTEN","testnet","RINKEBY","disabled","GOERLI","KOVAN","POLYGON","POLYGON_MUMBAI","POLYGON_ZKEVM","BSC","BSC_TESTNET","OPTIMISM","OPTIMISM_TESTNET","ARBITRUM","ARBITRUM_GOERLI","ARBITRUM_NOVA","AVALANCHE","AVALANCHE_TESTNET","FANTOM","FANTOM_TESTNET","GNOSIS","AURORA","AURORA_TESTNET","BASE_GOERLI","mainnetNetworks","indexerUrl","testnetNetworks","sequenceContext","guestModule","libs","JsonRpcVersion","JsonRpcRouter","middlewares","sender","handler","setMiddleware","createJsonRpcMiddlewareStack","sendAsync","request","toMiddleware","sendAsyncMiddleware","chain","isJsonRpcProvider","cand","defaultUrl","detectNetwork","getSigner","perform","isJsonRpcHandler","_nextId","JsonRpcSender","defaultChainId","params","r","jsonrpc","response","allowProviderMiddleware","isAllowed","CachedProvider","options","cachableJsonRpcMethods","cachableJsonRpcMethodsByBlock","cache","cacheByBlock","cacheByBlockResetLock","onUpdateCallback","includes","cacheKey","getCacheValue","shouldCacheResponse","setCacheValue","setCacheByBlockValue","getCache","setCache","setTimeout","clearCache","blockCache","onUpdate","EagerProvider","hexlify","accountAddress","walletContext","exceptionProviderMiddleware","loggingProviderMiddleware","chainIdLabel","networkProviderMiddleware","networkChainId","SignerJsonRpcMethods","SigningProvider","SingleflightMiddleware","singleflightJsonRpcMethods","inflight","requestKey","sub","_chainId","_sender","fetchJson","connection","getResult","router","chainIdHex","payload","DefaultMulticallOptions","batchSize","timeWindow","contract","verbose","Multicall","batchableJsonRpcMethods","ethCall","ethGetCode","ethGetBalance","multicallInterface","Interface","timeout","queue","scheduleExecution","clearTimeout","run","handle","m","limit","forward","items","blockTag","discartItems","item","gasPrice","itemBlockTag","parseBlockTag","callParams","delegateCall","revertOnError","target","to","gasLimit","gas","encodeFunctionData","getFunction","_unused2","encodedCall","_unused3","reqId","promise","def","Function","safeSolve","decoded","decodeFunctionResult","_unused4","index","DefaultOptions","entries","static","conf","isMulticallOptions","ProxyMethods","MulticallProvider","BaseProvider","multicall","listenerCount","getResolver","ogResolver","Resolver","req","getBalance","isMulticall","resp","transaction","rpcCall","addressOrName","isMetaMask","isStatus","lib","isDecodedAddress","isDecodedSigner","isDecodedEOASigner","isDecodedEOASplitSigner","isDecodedFullSigner","SignatureType","decodeSignature","auxsig","rindex","signatureType","Address","addr","EOA","sig","splitSignature","Full","size","mul","splitDecodedEOASigner","recoverEOASigner","recoverAddress","subDigest","joinSignatures","joinTwoSignatures","encodeSignature","accountBytes","signatureSize","fill","signerOf","part","buildStubSignature","multicallProvider","sortedSigners","all","isEOA","totalWeight","willSign","stubSig","finalSigners","Wallet","createRandom","ContractType","EventLogType","EventLogDataType","TxnTransferType","TransactionStatus","TransactionType","Indexer","getChainID","chainID","getEtherBalance","balance","getTokenBalances","balances","getTokenSupplies","contractType","tokenIDs","getTokenSuppliesMap","supplies","getBalanceUpdates","getTransactionHistory","transactions","syncBalance","fetchTransactionReceipt","fetchTransactionReceiptWithFilter","SequenceIndexerServices","SequenceIndexerClient","IndexerRpc","PropertyType","SwapType","Metadata","getTokenMetadata","tokenMetadata","refreshTokenMetadata","getTokenMetadataBatch","contractTokenMetadata","searchTokenMetadata","searchTokenIDs","tokenIds","tokenCollectionFilters","getContractInfo","contractInfo","getContractInfoBatch","contractInfoMap","searchContractInfo","contractInfoList","searchContractInfoBatch","contractInfoByChain","searchMetadata","getNiftyswapTokenQuantity","quantity","getNiftyswapUnitPrices","prices","getNiftyswapUnitPricesWithQuantities","SequenceMetadataClient","MetadataRpc","Signer","AbstractSigner","isSequenceSigner","updateConfig","publishConfig","getWalletContext","getWalletConfig","NotEnoughSigners","MetaTransactionsType","packMetaTransactionsNonceData","nonce","txs","sequenceTxAbiEncode","digestOfTransactions","readSequenceNonce","digestOfTransactionsNonce","computeMetaTxnHash","toSequenceTransactions","allTxs","flattenAuxTransactions","nonces","tx","toSequenceTransaction","aux","auxiliary","flatMap","isSequenceTransaction","txGas","walletInterface","hasSequenceTransactions","sample","sampleNonce","_t$to","AddressZero","appendNonce","makeExpirable","expiration","makeAfterNonce","dep","space","encodeNonce","bspace","bnonce","shl","Two","pow","div","decodeNonce","shr","mod","isSignedTransactions","fromTransactionish","stx","afterNonce","after","RemoteSigner","signMessage","signMessageWithData","sendTransaction","signTransaction","connect","isRemoteSigner","resolveArrayProperties","o","strict","nonStrict","isSigner","useConfig","setProvider","setRelayer","useSigners","Provider","isProvider","jsonProvider","getChainIdNumber","isDeployed","deployed","lastImageHash","fetchImageHash","connected","getNonce","encodedNonce","decodedNonce","allSigners","quote","waitForReceipt","signedTxs","signTransactions","relay","signChainId","some","results","simulate","providedNonce","sign","isDigest","domainChainId","signTypedData","solvedChainId","signWith","auxData","signersAddr","localSigners","localSignature","packMsgAndSig","remoteSigners","remoteSignature","getSigners","sconfig","publish","buildUpdateConfigTransaction","requireFreshSigners","buildPublishConfigTransaction","buildPublishSignersTransaction","_this2","isUpgradable","implementation","getStorageAt","preTransaction","mainModuleInterface","sequenceUtilsInterface","_this$context$libs","requireFreshSignersInterface","randomBytes","decodedSignature","filteredSignature","contextRequireFreshSigner","connectedChainId","owner","signWeight","BaseRelayerDefaults","bundleCreation","creationGasLimit","BaseRelayer","opts","prepareWalletDeploy","factoryInterface","signedTransactions","encodedSignature","isWalletDeployed","execute","prependWalletDeploy","DEFAULT_GAS_LIMIT","ProviderRelayerDefaults","waitPollRate","deltaBlocksLog","fromBlockLog","ProviderRelayer","estimateGas","executed","succeeded","gasUsed","module","readNonce","metaTxnId","delay","maxFails","timedOut","retry","errorMessage","fails","waitReceipt","lastBlock","block","normalMetaTxnId","getTransactionReceipt","transactionHash","getTransaction","race","ETHTxnStatus","TransferType","FeeTokenType","Relayer","sendMetaTxn","getMetaTxnNonce","getMetaTxnReceipt","updateMetaTxnGasLimits","feeTokens","isFeeRequired","tokens","feeOptions","getMetaTxnNetworkFeeOptions","sentTransactions","pendingTransactions","listGasSponsors","gasSponsors","addGasSponsor","gasSponsor","updateGasSponsor","reportGasSponsorUsage","gasSponsorUsage","FINAL_STATUSES","proto","DROPPED","SUCCEEDED","PARTIALLY_FAILED","FAILED","FAILED_STATUSES","isRpcRelayerOptions","RpcRelayer","service","isCancelled","metaTxID","txnReceipt","encoded","symbols","symbol","_tag","_quote","getFeeOptions","toHexString","walletContractAddress","decodedSpace","typecheckedQuote","metaTxn","wait","confirmations","_confirmations","_waitResponse$receipt","waitResponse","waitForTransaction","MetaTransactionResponseException","txReceipt","blockHash","blockNumber","raw","isRelayer","gasRefundOptions","Account","_wallets","setNetworks","w","getConfigFinder","configFinder","authWallet","wallets","getWalletByNetwork","flat","configsPromise","states","getWalletState","idx","getAuthChainId","currentConfig","_configs$i","_this$mainWallet","_this$_wallets$find","getProvider","mainWallet","_this$mainWallet2","_this$_wallets$find2","getRelayer","thisConfig","_this$authWallet","hasEnoughSigners","updatedTransaction","prependConfigUpdate","finalTransactions","dtransactionish","sendSignedTransactions","skipThresholdCheck","lastConfig","transactionParts","newConfig","getWallets","networkId","defaultChainIdNum","foundMainnetNetwork","foundTestnetNetwork","initialConfig","isValidEIP712Signature","isValidEthSignSignature","erc1271Check","isValidContractWalletSignature","isValidSequenceUndeployedWalletSignature","cid","recoverConfigFromDigest","walletSignersValidation","DEFAULT_SESSION_EXPIRATION","Session","sequenceApiUrl","sequenceMetadataUrl","account","metadata","_jwt$expiration","_initialAuthRequest","_jwt","proofStrings","onAuthCallbacks","apiClient","metadataClient","indexerClients","getJWTExpiration","onAuth","cb","setAccount","setConfig","maxTries","getJWT","isTestnetMode","tryAuth","getMetadataClient","has","indexer","proofStringKey","getProofStringKey","getProofString","api","authResp","ewtString","testnetMode","isProofStringValid","reason","location","origin","ethAuth","referenceSigner","deepSearch","noIndex","getAuthProvider","solvedSigners","fullSigners","existingWallet","session","auth","dump","_authChain$provider","signAuthorization","ErrAccountIsRequired","AuthError","expiry","valid","getSignerConfig","signerConfig","isAllowedFunc","setIsAllowedFunc","privateJsonRpcMethods","setRpcUrl","getRpcUrl","nextTickSupported","process","nextTick","symbolsSupported","reflectSupported","Reflect","_setImmediate","setImmediate","ownKeys","arr","getOwnPropertyNames","getOwnPropertySymbols","keys","_events","_conf","delimiter","maxListeners","_maxListeners","wildcard","newListener","_newListener","removeListener","_removeListener","verboseMemoryLeak","ignoreErrors","listenerTree","logPossibleMemoryLeak","count","eventName","errorMsg","emitWarning","emitter","trace","toArray","toObject","values","len","valuesCount","TargetObserver","on","off","_emitter","_target","_listeners","_listenersCount","addEventListener","removeEventListener","addListener","_on","_off","_observers","resolveOptions","schema","reducers","allowUnknown","computedOptions","option","reducer","constructorReducer","makeTypeReducer","firstType","secondType","kind","subscribe","localEvent","observer","listeners","eventObj","original","emit","_onNewListener","_event","_onRemoveListener","hasListeners","unsubscribe","events","clearRefs","findTargetIndex","functionReducer","objectFunctionReducer","makeCancelablePromise","executor","isCancelable","callbacks","subscriptionClosed","timer","onCancel","cleanup","overload","isFinite","cancel","_resolve","_reject","observers","searchListenerTree","handlers","tree","typeLength","ns","j","dl","branch","xTree","xxTree","isolatedBranch","endReached","branches","currentType","nextType","growListenerTree","listener","prepend","unshift","warned","collectTreeEvents","root","asArray","branchName","isArrayPath","recursivelyGarbageCollect","flag","Listener","setupListener","objectify","_listener","_origin","_async","EventEmitter","EventEmitter2","listenTo","listen","isSingleReducer","stopListeningTo","matched","setMaxListeners","getMaxListeners","once","_once","prependOnceListener","_many","many","ttl","prependMany","self","_all","containsSymbol","al","emitAsync","promises","prependListener","onAny","_onAny","prependAny","temp","returnValue","leafs","iLeaf","leaf","position","offAny","fns","removeAllListeners","allListeners","eventNames","nsAsArray","listenersAny","waitFor","handleError","defineProperties","defaultMaxListeners","isNaN","enumerable","errorListener","eventListener","writable","configurable","exports","WindowSessionParams","URLSearchParams","EventType","OpenState","InitState","ProviderError","ErrSignedInRequired","PROVIDER_OPEN_TIMEOUT","_messageIdx","nextMessageIdx","BaseProviderTransport","pendingMessageRequests","responseCallbacks","state","confirmationOnly","openPayload","connectPayload","accountsChangedPayload","networksPayload","walletContextPayload","_sessionId","_init","_registered","CLOSED","openWallet","isOpened","waitUntilOpened","sendMessageRequest","MESSAGE","responseCallback","sendMessage","openTimeout","opened","_this$openPayload","openInfo","waitUntilConnected","connectDetails","closeWallet","NIL","registered","register","unregister","intent","OPENED","isConnected","_this$openPayload2","handleMessage","INIT","OK","sessionId","requestIdx","OPEN","ACCOUNTS_CHANGED","accounts","CHAIN_CHANGED","NETWORKS","WALLET_CONTEXT","CLOSE","close","CONNECT","DISCONNECT","_message$data","_message$data2","_message$data3","pendingMessageRequest","clear","WalletRequestHandler","prompter","signerReadyCallbacks","_openIntent","_connectOptions","_defaultNetworkId","onConnectOptionsChange","promptConnect","promptConnectDetails","walletSession","permittedJsonRpcMethods","walletBalance","prefixedMessage","prefixEIP191Message","handleConfirmWalletDeployPrompt","promptSignMessage","connectOptions","signingAddress","typedDataObject","transactionParams","promptSendTransaction","promptSignTransaction","txChainId","tag","getTransactionCount","getBlock","transactionObject","contractAddress","getGasPrice","switchParams","setDefaultNetwork","getNetworks","defaultNetworkId","providerResponse","isSignedIn","signerReady","setSigner","_this$prompter","promptSignInConnect","notifyConnect","keepWalletOpened","notifyClose","signOut","signerReset","authorize","authOptions","responseMessage","openIntent","setOpenIntent","setConnectOptions","_this$onConnectOption","notifyNetworks","jsonRpcResponse","_connectDetails$sessi","_connectDetails$sessi2","notifyDisconnect","defaultNetwork","isWalletUpToDate","promptConfirmWalletDeploy","Web3Provider","isSequenceProvider","_isSequenceProvider","_defaultChainId","Web3Signer","_address","_index","_context","_networks","_providers","currentChainId","authChainId","walletConfig","getSender","getPayload","sendUncheckedTransaction","poll","_wrapTransaction","onceBlock","batch","fromAddress","hexTx","hexlifyTransaction","connectUnchecked","UncheckedJsonRpcSigner","password","allowedTransactionKeys","allowExtra","allowed","hexValue","EIP_191_PREFIX_EXCEPTIONS","predicate","bytes","stringified","toUtf8String","DCL_REGEX","ZeroXV3EIP1271OrderWithHashAbi","decodeFunctionData","eip191prefix","messageToBytes","messageBytes","messageIsExemptFromEIP191Prefix","_await$provider$getNe","_isValidSignature","prefixed","recoverWalletConfig","recoverConfig","recoveredWalletAddress","isBrowserExtension","protocol","isUnityPlugin","navigator","userAgent","_walletState$find","walletState","walletStateForRequiredChain","authChainConfig","requiredChainConfig","isUpToDate","LocalStorage","_instance","instance","LocalStore","getInstance","TRANSPORT_SESSION_LS_KEY","BaseWalletTransport","walletRequestHandler","_initNonce","_initCallback","appOrigin","open","isValidInitAck","saveTransportSession","authorizeOptions","notifyOpen","getCachedTransportSession","notifyAccountsChanged","notifyChainChanged","notifyWalletContext","initTimeout","performance","SENT_NONCE","ProxyMessageChannelPort","conn","ProxyMessageProvider","port","OPENING","MuxMessageProvider","messageProviders","registeredWindowMessageProvider","WindowMessageProvider","walletAppURL","walletURL","walletWindow","onWindowEvent","popup","interval","setInterval","closed","clearInterval","focus","URL","href","windowSessionParams","windowSize","windowPos","pathname","abs","screen","width","height","screenX","innerWidth","screenY","innerHeight","windowFeatures","search","_this$walletWindow","postedMessage","postMessage","CHANNEL_ID","ExtensionMessageProvider","runtime","onConnect","onMessage","BaseInjectedTransport","stream","write","overrideLogs","side","_window$ue","ue","sequencewallettransport","logsOverriddenForUnreal","_window$ue2","logfromjs","warnfromjs","errorfromjs","things","registeredUnrealMessageProvider","UnrealMessageProvider","onmessagefromwallet","onUnrealCallback","_window$ue2$sequencew","_window$ue3","_window$ue3$sequencew","sendmessagetowallet","WalletUtils","walletProvider","recoverWalletConfigFromMessage","recoverWalletConfigFromTypedData","getAuthSigner","connectedSites","transport","_this$config$transpor","_this$config$transpor2","_this$config$transpor3","_this$config$transpor4","_this$config$transpor5","_this$config$transpor6","_this$config$transpor7","_this$config$transpor8","messageProvider","transports","windowTransport","enabled","windowMessageProvider","proxyTransport","proxyMessageProvider","appPort","extensionTransport","extensionMessageProvider","unrealTransport","unrealMessageProvider","allowProvider","networkProvider","cachedProvider","providerCache","saveSession","useSession","clearSession","loadSession","preferredNetwork","_session$networks","preferredNetworkIdNum","isPreferredNetwork","preferredNetworkInConfig","isAlreadyDefaultChain","updatedNetworks","refresh","disconnect","isSiteConnected","askForEmail","addConnectedSite","getSession","currentNetworkId","_this$transport$messa","autoSave","useAccountAddress","useNetworks","DefaultProviderConfig","use","authorized","getConnectedSites","getProviderConfig","rpcProvider","getAllProviders","networkRpcUrl","_this$transport$cache","walletInstance","initWallet","getWallet","port1","port2","cachedSession","parentWindow","_isPopup","getWindowTransportSession","windowParams","windowHref","isPopup","parent","opener","rawParams","_session","_session2","onMessageFromUnreal","getUnrealTransportSession","onmessagefromsequencejs","sendmessagetosequencejs","txnOptions","walletDeployTxn","_config","_transactions","setTransactionOptions","transactionRequest","responsePromise","encodedString","encodeURIComponent","qs","z","decodeURIComponent"],"mappings":"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,QAAS,CACP,CACES,aAAc,UACdZ,KAAM,GACND,KAAM,YAGVM,gBAAiB,OACjBN,KAAM,YAER,CACEG,OAAQ,CACN,CACEU,aAAc,UACdZ,KAAM,GACND,KAAM,YAGVC,KAAM,mBACNG,QAAS,CACP,CACES,aAAc,UACdZ,KAAM,GACND,KAAM,YAGVM,gBAAiB,OACjBN,KAAM,YAER,CACEG,OAAQ,CACN,CACEU,aAAc,UACdZ,KAAM,GACND,KAAM,YAGVC,KAAM,sBACNG,QAAS,CACP,CACES,aAAc,UACdZ,KAAM,GACND,KAAM,YAGVM,gBAAiB,OACjBN,KAAM,YAER,CACEG,OAAQ,CACN,CACEU,aAAc,UACdZ,KAAM,GACND,KAAM,YAGVC,KAAM,mBACNG,QAAS,CACP,CACES,aAAc,UACdZ,KAAM,GACND,KAAM,YAGVM,gBAAiB,OACjBN,KAAM,YAER,CACEG,OAAQ,CACN,CACEU,aAAc,UACdZ,KAAM,GACND,KAAM,YAGVC,KAAM,mBACNG,QAAS,CACP,CACES,aAAc,UACdZ,KAAM,GACND,KAAM,YAGVM,gBAAiB,OACjBN,KAAM,YAER,CACEG,OAAQ,CACN,CACEO,WAAY,CACV,CACEG,aAAc,OACdZ,KAAM,eACND,KAAM,QAER,CACEa,aAAc,OACdZ,KAAM,gBACND,KAAM,QAER,CACEa,aAAc,UACdZ,KAAM,WACND,KAAM,WAER,CACEa,aAAc,UACdZ,KAAM,SACND,KAAM,WAER,CACEa,aAAc,UACdZ,KAAM,QACND,KAAM,WAER,CACEa,aAAc,QACdZ,KAAM,OACND,KAAM,UAGVa,aAAc,oCACdZ,KAAM,OACND,KAAM,YAGVC,KAAM,YACNG,QAAS,CACP,CACES,aAAc,SACdZ,KAAM,aACND,KAAM,UAER,CACEa,aAAc,UACdZ,KAAM,WACND,KAAM,YAGVM,gBAAiB,UACjBN,KAAM,YAER,CACEG,OAAQ,CACN,CACEU,aAAc,UACdZ,KAAM,UACND,KAAM,WAER,CACEa,aAAc,UACdZ,KAAM,aACND,KAAM,WAER,CACEU,WAAY,CACV,CACEG,aAAc,UACdZ,KAAM,SACND,KAAM,WAER,CA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"}
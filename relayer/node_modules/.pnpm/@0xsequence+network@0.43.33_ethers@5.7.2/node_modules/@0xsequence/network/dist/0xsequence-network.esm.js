import { ethers, providers } from 'ethers';
import { logger } from '@0xsequence/utils';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function isNetworkConfig(cand) {
  return cand && cand.chainId !== undefined && cand.name !== undefined && cand.rpcUrl !== undefined && cand.relayer !== undefined;
}
const getChainId = chainId => {
  if (typeof chainId === 'number') {
    return chainId;
  }
  if (chainId.chainId) {
    return chainId.chainId;
  }
  return ethers.BigNumber.from(chainId).toNumber();
};
const maybeChainId = chainId => {
  if (!chainId) return undefined;
  return getChainId(chainId);
};
const getAuthNetwork = networks => {
  return networks.find(network => network.isAuthChain);
};
const isValidNetworkConfig = (networkConfig, raise = false, skipRelayerCheck = false) => {
  if (!networkConfig) throw new Error(`invalid network config: empty config`);
  const configs = [];
  if (Array.isArray(networkConfig)) {
    configs.push(...networkConfig);
  } else {
    configs.push(networkConfig);
  }
  if (configs.length === 0) {
    if (raise) throw new Error(`invalid network config: empty config`);
    return false;
  }

  // Ensure distinct chainId configs
  const chainIds = configs.map(c => c.chainId).sort();
  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i);
  if (dupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  }

  // Downcase all network names
  configs.forEach(c => c.name = c.name.toLowerCase());

  // Ensure distinct network names
  const names = configs.map(c => c.name).sort();
  const nameDupes = names.filter((c, i) => names.indexOf(c) !== i);
  if (nameDupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate network names ${nameDupes}`);
    return false;
  }

  // Ensure rpcUrl or provider is specified
  // Ensure relayerUrl or relayer is specified
  // Ensure one default chain
  // Ensure one auth chain
  let defaultChain = false;
  let authChain = false;
  for (let i = 0; i < configs.length; i++) {
    const c = configs[i];
    if ((!c.rpcUrl || c.rpcUrl === '') && !c.provider) {
      if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: rpcUrl or provider must be provided`);
      return false;
    }
    if (!skipRelayerCheck) {
      if (!c.relayer) {
        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: relayer must be provided`);
        return false;
      }
    }
    if (c.isDefaultChain) {
      if (defaultChain) {
        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: DefaultChain is already set by another config`);
        return false;
      }
      defaultChain = true;
    }
    if (c.isAuthChain) {
      if (authChain) {
        if (raise) throw new Error(`invalid network config for chainId ${c.chainId}: AuthChain is already set by another config`);
      }
      authChain = true;
    }
  }
  if (!defaultChain) {
    if (raise) throw new Error(`invalid network config: DefaultChain must be set`);
    return false;
  }
  if (!authChain) {
    if (raise) throw new Error(`invalid network config: AuthChain must be set`);
    return false;
  }
  return true;
};
const ensureValidNetworks = (networks, skipRelayerCheck = false) => {
  isValidNetworkConfig(networks, true, skipRelayerCheck);
  return networks;
};
const ensureUniqueNetworks = (networks, raise = true) => {
  const chainIds = networks.map(c => c.chainId).sort();
  const dupes = chainIds.filter((c, i) => chainIds.indexOf(c) !== i);
  if (dupes.length > 0) {
    if (raise) throw new Error(`invalid network config: duplicate chainIds ${dupes}`);
    return false;
  }
  return true;
};
const updateNetworkConfig = (src, dest) => {
  if (!src || !dest) return;
  if (!src.chainId && !src.name) {
    throw new Error('failed to update network config: source config is missing chainId or name');
  }
  if (src.chainId !== dest.chainId && src.name !== dest.name) {
    throw new Error('failed to update network config: one of chainId or name must match');
  }
  if (src.rpcUrl) {
    dest.rpcUrl = src.rpcUrl;
    dest.provider = undefined;
  }
  if (src.provider) {
    dest.provider = src.provider;
  }
  if (src.relayer) {
    dest.relayer = src.relayer;
  }
  // NOTE: we do not set default or auth chain from here
  // if (src.isDefaultChain) {
  //   dest.isDefaultChain = src.isDefaultChain
  // }
  // if (src.isAuthChain) {
  //   dest.isAuthChain = src.isAuthChain
  // }
};

const validateAndSortNetworks = networks => {
  return ensureValidNetworks(sortNetworks(networks));
};
const findNetworkConfig = (networks, chainId) => {
  if (typeof chainId === 'string') {
    if (chainId.startsWith('0x')) {
      const id = ethers.BigNumber.from(chainId).toNumber();
      return networks.find(n => n.chainId === id);
    } else {
      return networks.find(n => n.name === chainId);
    }
  } else if (typeof chainId === 'number') {
    return networks.find(n => n.chainId === chainId);
  } else if (chainId.chainId) {
    return networks.find(n => n.chainId === chainId.chainId);
  } else {
    return undefined;
  }
};
const checkNetworkConfig = (network, chainId) => {
  if (!network) return false;
  if (network.name === chainId) return true;
  if (network.chainId === chainId) return true;
  return false;
};
const networksIndex = networks => {
  const index = {};
  for (let i = 0; i < networks.length; i++) {
    index[networks[i].name] = networks[i];
  }
  return index;
};

// TODO: we should remove sortNetworks in the future but this is a breaking change for dapp integrations on older versions <-> wallet
// sortNetworks orders the network config list by: defaultChain, authChain, ..rest by chainId ascending numbers
const sortNetworks = networks => {
  if (!networks) {
    return [];
  }
  const config = networks.sort((a, b) => {
    if (a.chainId === b.chainId) return 0;
    return a.chainId < b.chainId ? -1 : 1;
  });

  // DefaultChain goes first
  const defaultConfigIdx = config.findIndex(c => c.isDefaultChain);
  if (defaultConfigIdx > 0) config.splice(0, 0, config.splice(defaultConfigIdx, 1)[0]);

  // AuthChain goes second
  const authConfigIdx = config.findIndex(c => c.isAuthChain && c.isDefaultChain !== true);
  if (authConfigIdx > 0) config.splice(1, 0, config.splice(authConfigIdx, 1)[0]);
  return config;
};
const stringTemplate = (sTemplate, mData) => {
  if (typeof sTemplate === 'string') {
    mData = mData ? mData : {};
    return sTemplate.replace(/\$\{\s*([$#@\-\d\w]+)\s*\}/gim, function (fullMath, grp) {
      let val = mData[grp];
      if (typeof val === 'function') {
        val = val();
      } else if (val === null || val === undefined) {
        val = '';
      } else if (typeof val === 'object' || typeof val === 'symbol') {
        val = val.toString();
      } else {
        val = val.valueOf();
      }
      return val;
    });
  }
  return '';
};

let ChainId;
(function (ChainId) {
  ChainId[ChainId["MAINNET"] = 1] = "MAINNET";
  ChainId[ChainId["ROPSTEN"] = 3] = "ROPSTEN";
  ChainId[ChainId["RINKEBY"] = 4] = "RINKEBY";
  ChainId[ChainId["GOERLI"] = 5] = "GOERLI";
  ChainId[ChainId["KOVAN"] = 42] = "KOVAN";
  ChainId[ChainId["POLYGON"] = 137] = "POLYGON";
  ChainId[ChainId["POLYGON_MUMBAI"] = 80001] = "POLYGON_MUMBAI";
  ChainId[ChainId["POLYGON_ZKEVM"] = 1101] = "POLYGON_ZKEVM";
  ChainId[ChainId["BSC"] = 56] = "BSC";
  ChainId[ChainId["BSC_TESTNET"] = 97] = "BSC_TESTNET";
  ChainId[ChainId["OPTIMISM"] = 10] = "OPTIMISM";
  ChainId[ChainId["OPTIMISM_TESTNET"] = 69] = "OPTIMISM_TESTNET";
  ChainId[ChainId["ARBITRUM"] = 42161] = "ARBITRUM";
  ChainId[ChainId["ARBITRUM_GOERLI"] = 421613] = "ARBITRUM_GOERLI";
  ChainId[ChainId["ARBITRUM_NOVA"] = 42170] = "ARBITRUM_NOVA";
  ChainId[ChainId["AVALANCHE"] = 43114] = "AVALANCHE";
  ChainId[ChainId["AVALANCHE_TESTNET"] = 43113] = "AVALANCHE_TESTNET";
  ChainId[ChainId["FANTOM"] = 250] = "FANTOM";
  ChainId[ChainId["FANTOM_TESTNET"] = 4002] = "FANTOM_TESTNET";
  ChainId[ChainId["GNOSIS"] = 100] = "GNOSIS";
  ChainId[ChainId["AURORA"] = 1313161554] = "AURORA";
  ChainId[ChainId["AURORA_TESTNET"] = 1313161556] = "AURORA_TESTNET";
  ChainId[ChainId["BASE_GOERLI"] = 84531] = "BASE_GOERLI";
})(ChainId || (ChainId = {}));
const indexerURL = network => stringTemplate('https://${network}-indexer.sequence.app', {
  network: network
});
const relayerURL = network => stringTemplate('https://${network}-relayer.sequence.app', {
  network: network
});
const nodesURL = network => stringTemplate('https://nodes.sequence.app/${network}', {
  network: network
});
const networks = {
  [ChainId.MAINNET]: {
    chainId: ChainId.MAINNET,
    name: 'mainnet',
    title: 'Ethereum',
    blockExplorer: {
      name: 'Etherscan',
      rootUrl: 'https://etherscan.io/'
    },
    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'
  },
  [ChainId.ROPSTEN]: {
    chainId: ChainId.ROPSTEN,
    name: 'ropsten',
    title: 'Ropsten',
    testnet: true,
    blockExplorer: {
      name: 'Etherscan (Ropsten)',
      rootUrl: 'https://ropsten.etherscan.io/'
    },
    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'
  },
  [ChainId.RINKEBY]: {
    chainId: ChainId.RINKEBY,
    name: 'rinkeby',
    title: 'Rinkeby',
    testnet: true,
    blockExplorer: {
      name: 'Etherscan (Rinkeby)',
      rootUrl: 'https://rinkeby.etherscan.io/'
    },
    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
    disabled: true
  },
  [ChainId.GOERLI]: {
    chainId: ChainId.GOERLI,
    name: 'goerli',
    title: 'Goerli',
    testnet: true,
    blockExplorer: {
      name: 'Etherscan (Goerli)',
      rootUrl: 'https://goerli.etherscan.io/'
    },
    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e'
  },
  [ChainId.KOVAN]: {
    chainId: ChainId.KOVAN,
    name: 'kovan',
    title: 'Kovan',
    testnet: true,
    blockExplorer: {
      name: 'Etherscan (Kovan)',
      rootUrl: 'https://kovan.etherscan.io/'
    }
  },
  [ChainId.POLYGON]: {
    chainId: ChainId.POLYGON,
    name: 'polygon',
    title: 'Polygon',
    blockExplorer: {
      name: 'Polygonscan',
      rootUrl: 'https://polygonscan.com/'
    }
  },
  [ChainId.POLYGON_MUMBAI]: {
    chainId: ChainId.POLYGON_MUMBAI,
    name: 'mumbai',
    title: 'Polygon Mumbai',
    testnet: true,
    blockExplorer: {
      name: 'Polygonscan (Mumbai)',
      rootUrl: 'https://mumbai.polygonscan.com/'
    }
  },
  [ChainId.POLYGON_ZKEVM]: {
    chainId: ChainId.POLYGON_ZKEVM,
    name: 'polygon-zkevm',
    title: 'Polygon zkEVM',
    blockExplorer: {
      name: 'Polygonscan (zkEVM)',
      rootUrl: 'https://zkevm.polygonscan.com/'
    }
  },
  [ChainId.BSC]: {
    chainId: ChainId.BSC,
    name: 'bsc',
    title: 'BNB Smart Chain',
    blockExplorer: {
      name: 'BSCScan',
      rootUrl: 'https://bscscan.com/'
    }
  },
  [ChainId.BSC_TESTNET]: {
    chainId: ChainId.BSC_TESTNET,
    name: 'bsc-testnet',
    title: 'BNB Smart Chain Testnet',
    testnet: true,
    blockExplorer: {
      name: 'BSCScan (Testnet)',
      rootUrl: 'https://testnet.bscscan.com/'
    }
  },
  [ChainId.OPTIMISM]: {
    chainId: ChainId.OPTIMISM,
    name: 'optimism',
    title: 'Optimism',
    blockExplorer: {
      name: 'Etherscan (Optimism)',
      rootUrl: 'https://optimistic.etherscan.io/'
    }
  },
  [ChainId.OPTIMISM_TESTNET]: {
    chainId: ChainId.OPTIMISM_TESTNET,
    name: 'optimism-testnet',
    title: 'Optimistic Kovan',
    testnet: true,
    blockExplorer: {
      name: 'Etherscan (Optimism Testnet)',
      rootUrl: 'https://kovan-optimistic.etherscan.io/'
    }
  },
  [ChainId.ARBITRUM]: {
    chainId: ChainId.ARBITRUM,
    name: 'arbitrum',
    title: 'Arbitrum One',
    blockExplorer: {
      name: 'Arbiscan',
      rootUrl: 'https://arbiscan.io/'
    }
  },
  [ChainId.ARBITRUM_GOERLI]: {
    chainId: ChainId.ARBITRUM_GOERLI,
    name: 'arbitrum-goerli',
    title: 'Arbitrum Goerli',
    testnet: true,
    blockExplorer: {
      name: 'Arbiscan (Testnet)',
      rootUrl: 'https://testnet.arbiscan.io/'
    }
  },
  [ChainId.ARBITRUM_NOVA]: {
    chainId: ChainId.ARBITRUM_NOVA,
    name: 'arbitrum-nova',
    title: 'Arbitrum Nova',
    blockExplorer: {
      name: 'Nova Explorer',
      rootUrl: 'https://nova-explorer.arbitrum.io/'
    }
  },
  [ChainId.AVALANCHE]: {
    chainId: ChainId.AVALANCHE,
    name: 'avalanche',
    title: 'Avalanche',
    blockExplorer: {
      name: 'Snowtrace',
      rootUrl: 'https://snowtrace.io/'
    }
  },
  [ChainId.AVALANCHE_TESTNET]: {
    chainId: ChainId.AVALANCHE_TESTNET,
    name: 'avalanche-testnet',
    title: 'Avalanche Testnet',
    testnet: true,
    blockExplorer: {
      name: 'Snowtrace (Testnet)',
      rootUrl: 'https://testnet.snowtrace.io/'
    }
  },
  [ChainId.FANTOM]: {
    chainId: ChainId.FANTOM,
    name: 'fantom',
    title: 'Fantom',
    blockExplorer: {
      name: 'FTMScan',
      rootUrl: 'https://ftmscan.com/'
    }
  },
  [ChainId.FANTOM_TESTNET]: {
    chainId: ChainId.FANTOM_TESTNET,
    name: 'fantom-testnet',
    title: 'Fantom Testnet',
    testnet: true,
    blockExplorer: {
      name: 'FTMScan (Testnet)',
      rootUrl: 'https://testnet.ftmscan.com/'
    }
  },
  [ChainId.GNOSIS]: {
    chainId: ChainId.GNOSIS,
    name: 'gnosis',
    title: 'Gnosis Chain',
    blockExplorer: {
      name: 'Gnosis Chain Explorer',
      rootUrl: 'https://blockscout.com/xdai/mainnet/'
    }
  },
  [ChainId.AURORA]: {
    chainId: ChainId.AURORA,
    name: 'aurora',
    title: 'Aurora',
    blockExplorer: {
      name: 'Aurora Explorer',
      rootUrl: 'https://aurorascan.dev/'
    }
  },
  [ChainId.AURORA_TESTNET]: {
    chainId: ChainId.AURORA_TESTNET,
    name: 'aurora-testnet',
    title: 'Aurora Testnet',
    blockExplorer: {
      name: 'Aurora Explorer (Testnet)',
      rootUrl: 'https://testnet.aurorascan.dev/'
    }
  },
  [ChainId.BASE_GOERLI]: {
    chainId: ChainId.BASE_GOERLI,
    name: 'base-goerli',
    title: 'Base Goerli',
    blockExplorer: {
      name: 'Base Goerli Explorer',
      rootUrl: 'https://goerli.basescan.org/'
    }
  }
};
const mainnetNetworks = validateAndSortNetworks([_extends({}, networks[ChainId.MAINNET], {
  rpcUrl: nodesURL('mainnet'),
  relayer: {
    url: relayerURL('mainnet')
  },
  indexerUrl: indexerURL('mainnet')
}), _extends({}, networks[ChainId.POLYGON], {
  rpcUrl: nodesURL('polygon'),
  relayer: {
    url: relayerURL('polygon')
  },
  indexerUrl: indexerURL('polygon'),
  isDefaultChain: true,
  isAuthChain: true
}), _extends({}, networks[ChainId.BSC], {
  rpcUrl: nodesURL('bsc'),
  indexerUrl: indexerURL('bsc'),
  relayer: {
    url: relayerURL('bsc')
  }
}), _extends({}, networks[ChainId.AVALANCHE], {
  rpcUrl: nodesURL('avalanche'),
  indexerUrl: indexerURL('avalanche'),
  relayer: {
    url: relayerURL('avalanche')
  }
}), _extends({}, networks[ChainId.ARBITRUM], {
  rpcUrl: nodesURL('arbitrum'),
  indexerUrl: indexerURL('arbitrum'),
  relayer: {
    url: relayerURL('arbitrum')
  }
}), _extends({}, networks[ChainId.ARBITRUM_NOVA], {
  rpcUrl: nodesURL('arbitrum-nova'),
  indexerUrl: indexerURL('arbitrum-nova'),
  relayer: {
    url: relayerURL('arbitrum-nova')
  }
}), _extends({}, networks[ChainId.OPTIMISM], {
  rpcUrl: nodesURL('optimism'),
  indexerUrl: indexerURL('optimism'),
  relayer: {
    url: relayerURL('optimism')
  }
}), _extends({}, networks[ChainId.POLYGON_ZKEVM], {
  rpcUrl: nodesURL('polygon-zkevm'),
  indexerUrl: indexerURL('polygon-zkevm'),
  relayer: {
    url: relayerURL('polygon-zkevm')
  }
}), _extends({}, networks[ChainId.GNOSIS], {
  rpcUrl: nodesURL('gnosis'),
  indexerUrl: indexerURL('gnosis'),
  relayer: {
    url: relayerURL('gnosis')
  }
})]);
const testnetNetworks = validateAndSortNetworks([_extends({}, networks[ChainId.RINKEBY], {
  rpcUrl: nodesURL('rinkeby'),
  relayer: {
    url: relayerURL('rinkeby')
  },
  indexerUrl: indexerURL('rinkeby')
}), _extends({}, networks[ChainId.GOERLI], {
  rpcUrl: nodesURL('goerli'),
  relayer: {
    url: relayerURL('goerli')
  },
  indexerUrl: indexerURL('goerli')
}), _extends({}, networks[ChainId.POLYGON_MUMBAI], {
  rpcUrl: nodesURL('mumbai'),
  relayer: {
    url: relayerURL('mumbai')
  },
  indexerUrl: indexerURL('mumbai'),
  isDefaultChain: true,
  isAuthChain: true
}), _extends({}, networks[ChainId.BSC_TESTNET], {
  rpcUrl: nodesURL('bsc-testnet'),
  relayer: {
    url: relayerURL('bsc-testnet')
  },
  indexerUrl: indexerURL('bsc-testnet')
}), _extends({}, networks[ChainId.ARBITRUM_GOERLI], {
  rpcUrl: nodesURL('arbitrum-goerli'),
  relayer: {
    url: relayerURL('arbitrum-goerli')
  },
  indexerUrl: indexerURL('arbitrum-goerli')
}), _extends({}, networks[ChainId.BASE_GOERLI], {
  rpcUrl: nodesURL('base-goerli'),
  relayer: {
    url: relayerURL('base-goerli')
  },
  indexerUrl: indexerURL('base-goerli')
})]);

// WalletContext is the module addresses deployed on a network, aka the context / environment
// of the Sequence Smart Wallet system on Ethereum.

// sequenceContext are the deployed addresses of modules available on public networks.
const sequenceContext = {
  factory: '0xf9D09D634Fb818b05149329C1dcCFAeA53639d96',
  mainModule: '0xd01F11855bCcb95f88D7A48492F66410d4637313',
  mainModuleUpgradable: '0x7EFE6cE415956c5f80C6530cC6cc81b4808F6118',
  guestModule: '0x02390F3E6E5FD1C6786CB78FD3027C117a9955A7',
  sequenceUtils: '0xd130B43062D875a4B7aF3f8fc036Bc6e9D3E1B3E',
  libs: {
    requireFreshSigner: '0xE6B9B21C077F382333220a072e4c44280b873907'
  }
};

const JsonRpcVersion = '2.0';

class JsonRpcRouter {
  constructor(middlewares, sender) {
    this.sender = void 0;
    this.handler = void 0;
    this.sender = sender;
    if (middlewares) {
      this.setMiddleware(middlewares);
    }
  }
  setMiddleware(middlewares) {
    this.handler = createJsonRpcMiddlewareStack(middlewares, this.sender.sendAsync);
  }
  sendAsync(request, callback, chainId) {
    try {
      this.handler(request, callback, chainId);
    } catch (err) {
      callback(err, undefined);
    }
  }

  // createWeb3Provider(network?: Networkish): EthersWeb3Provider {
  //   return new EthersWeb3Provider(this.sender, network)
  // }
}

const createJsonRpcMiddlewareStack = (middlewares, handler) => {
  if (middlewares.length === 0) return handler;
  const toMiddleware = v => {
    if (v.sendAsyncMiddleware) {
      return v.sendAsyncMiddleware;
    } else {
      return v;
    }
  };
  let chain;
  chain = toMiddleware(middlewares[middlewares.length - 1])(handler);
  for (let i = middlewares.length - 2; i >= 0; i--) {
    chain = toMiddleware(middlewares[i])(chain);
  }
  return chain;
};

function isJsonRpcProvider(cand) {
  return cand !== undefined && cand.send !== undefined && cand.constructor.defaultUrl !== undefined && cand.detectNetwork !== undefined && cand.getSigner !== undefined && cand.perform !== undefined;
}
function isJsonRpcHandler(cand) {
  return cand !== undefined && cand.sendAsync !== undefined;
}

let _nextId = 0;
class JsonRpcSender {
  constructor(provider, defaultChainId) {
    this.send = void 0;
    this.request = void 0;
    this.defaultChainId = void 0;
    this.sendAsync = (request, callback, chainId) => {
      this.send(request.method, request.params, chainId || this.defaultChainId).then(r => {
        callback(undefined, {
          jsonrpc: '2.0',
          id: request.id,
          result: r
        });
      }).catch(e => {
        callback(e, undefined);
      });
    };
    this.defaultChainId = defaultChainId;
    if (isJsonRpcProvider(provider)) {
      // we can ignore defaultChainId for JsonRpcProviders as they are already chain-bound
      this.send = provider.send.bind(provider);
    } else if (isJsonRpcHandler(provider)) {
      this.send = (method, params, chainId) => {
        return new Promise((resolve, reject) => {
          provider.sendAsync({
            // TODO: really shouldn't have to set these here?
            jsonrpc: JsonRpcVersion,
            id: ++_nextId,
            method,
            params
          }, (error, response) => {
            if (error) {
              reject(error);
            } else if (response) {
              resolve(response.result);
            } else {
              resolve(undefined);
            }
          }, chainId || this.defaultChainId);
        });
      };
    } else {
      this.send = provider;
    }
    this.request = (request, chainId) => {
      return this.send(request.method, request.params, chainId);
    };
  }
}
class JsonRpcExternalProvider {
  constructor(provider) {
    this.provider = provider;
    this.sendAsync = (request, callback) => {
      this.provider.send(request.method, request.params).then(r => {
        callback(undefined, {
          jsonrpc: '2.0',
          id: request.id,
          result: r
        });
      }).catch(e => {
        callback(e, undefined);
      });
    };
    this.send = this.sendAsync;
  }
}

class AllowProvider {
  constructor(isAllowedFunc) {
    this.sendAsyncMiddleware = void 0;
    this.isAllowedFunc = void 0;
    if (isAllowedFunc) {
      this.isAllowedFunc = isAllowedFunc;
    } else {
      this.isAllowedFunc = request => true;
    }
    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);
  }
  setIsAllowedFunc(fn) {
    this.isAllowedFunc = fn;
    this.sendAsyncMiddleware = allowProviderMiddleware(this.isAllowedFunc);
  }
}
const allowProviderMiddleware = isAllowed => next => {
  return (request, callback, chainId) => {
    // ensure precondition is met or do not allow the request to continue
    if (!isAllowed(request)) {
      throw new Error('allowProvider middleware precondition is unmet.');
    }

    // request is allowed. keep going..
    next(request, callback, chainId);
  };
};

class CachedProvider {
  // cachableJsonRpcMethods which can be permanently cached for lifetime
  // of the provider.

  // cachableJsonRpcMethodsByBlock which can be temporarily cached for a short
  // period of time, essentially by block time. As we support chains fast blocks,
  // we keep the values here cachable only for 1.5 seconds. This is still useful to
  // memoize the calls within app-code that calls out to fetch these values within
  // a short period of time.

  // cache for life-time of provider (unless explicitly cleared)

  // cache by block, simulated by using a 1 second life-time

  // onUpdateCallback callback to be notified when cache values are set.

  // defaultChainId is used for default chain select with used with multi-chain provider

  constructor(options) {
    this.cachableJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts', 'sequence_getWalletContext', 'sequence_getNetworks'];
    this.cachableJsonRpcMethodsByBlock = ['eth_call', 'eth_getCode'];
    this.cache = void 0;
    this.cacheByBlock = void 0;
    this.cacheByBlockResetLock = false;
    this.onUpdateCallback = void 0;
    this.defaultChainId = void 0;
    this.sendAsyncMiddleware = next => {
      return (request, callback, chainId) => {
        // Respond early with cached result
        if (this.cachableJsonRpcMethods.includes(request.method) || this.cachableJsonRpcMethodsByBlock.includes(request.method)) {
          const key = this.cacheKey(request.method, request.params, chainId || this.defaultChainId);
          const result = this.getCacheValue(key);
          if (result && result !== '') {
            callback(undefined, {
              jsonrpc: '2.0',
              id: request.id,
              result: result
            });
            return;
          }
        }

        // Continue down the handler chain
        next(request, (error, response, chainId) => {
          // Store result in cache and continue
          if (this.cachableJsonRpcMethods.includes(request.method) || this.cachableJsonRpcMethodsByBlock.includes(request.method)) {
            if (response && response.result && this.shouldCacheResponse(request, response)) {
              // cache the value
              const key = this.cacheKey(request.method, request.params, chainId || this.defaultChainId);
              if (this.cachableJsonRpcMethods.includes(request.method)) {
                this.setCacheValue(key, response.result);
              } else {
                this.setCacheByBlockValue(key, response.result);
              }
            }
          }

          // Exec next handler
          callback(error, response);
        }, chainId || this.defaultChainId);
      };
    };
    this.cacheKey = (method, params, chainId) => {
      let key = '';
      if (chainId) {
        key = `${chainId}:${method}:`;
      } else {
        key = `:${method}:`;
      }
      if (!params || params.length === 0) {
        return key + '[]';
      }
      return key + JSON.stringify(params);
    };
    this.getCache = () => this.cache;
    this.setCache = cache => {
      this.cache = cache;
      if (this.onUpdateCallback) {
        this.onUpdateCallback();
      }
    };
    this.getCacheValue = key => {
      if (this.cache[key]) {
        return this.cache[key];
      }
      if (this.cacheByBlock[key]) {
        return this.cacheByBlock[key];
      }
      return undefined;
    };
    this.setCacheValue = (key, value) => {
      this.cache[key] = value;
      if (this.onUpdateCallback) {
        this.onUpdateCallback(key, value);
      }
    };
    this.setCacheByBlockValue = (key, value) => {
      this.cacheByBlock[key] = value;

      // clear the cacheByBlock once every X period of time
      if (!this.cacheByBlockResetLock) {
        this.cacheByBlockResetLock = true;
        setTimeout(() => {
          this.cacheByBlockResetLock = false;
          this.cacheByBlock = {};
        }, 1500); // 1.5 second cache lifetime
      }
    };
    this.shouldCacheResponse = (request, response) => {
      // skip if we do not have response result
      if (!response || !response.result) {
        return false;
      }

      // skip caching eth_getCode where resposne value is '0x' or empty
      if (request.method === 'eth_getCode' && response.result.length <= 2) {
        return false;
      }

      // all good -- signal to cache the result
      return true;
    };
    this.clearCache = () => {
      this.cache = {};
      this.cacheByBlock = {};
    };
    this.cache = {};
    this.cacheByBlock = {};
    this.defaultChainId = options == null ? void 0 : options.defaultChainId;
    if (!(options != null && options.blockCache)) {
      this.cachableJsonRpcMethodsByBlock = [];
    } else if ((options == null ? void 0 : options.blockCache) !== true) {
      this.cachableJsonRpcMethodsByBlock = options == null ? void 0 : options.blockCache;
    }
  }
  onUpdate(callback) {
    this.onUpdateCallback = callback;
  }
}

class EagerProvider {
  constructor(options) {
    this.options = void 0;
    this.sendAsyncMiddleware = next => {
      return (request, callback, chainId) => {
        const {
          id,
          method
        } = request;
        switch (method) {
          case 'net_version':
            if (this.options.chainId) {
              callback(undefined, {
                jsonrpc: '2.0',
                id: id,
                result: `${this.options.chainId}`
              });
              return;
            }
            break;
          case 'eth_chainId':
            if (this.options.chainId) {
              callback(undefined, {
                jsonrpc: '2.0',
                id: id,
                result: ethers.utils.hexlify(this.options.chainId)
              });
              return;
            }
            break;
          case 'eth_accounts':
            if (this.options.accountAddress) {
              callback(undefined, {
                jsonrpc: '2.0',
                id: id,
                result: [ethers.utils.getAddress(this.options.accountAddress)]
              });
              return;
            }
            break;
          case 'sequence_getWalletContext':
            if (this.options.walletContext) {
              callback(undefined, {
                jsonrpc: '2.0',
                id: id,
                result: this.options.walletContext
              });
              return;
            }
            break;
        }
        next(request, callback, chainId);
      };
    };
    this.options = options;
  }
}

const exceptionProviderMiddleware = next => {
  return (request, callback, chainId) => {
    next(request, (error, response) => {
      if (!error && response && response.error) {
        if (typeof response.error === 'string') {
          throw new Error(response.error);
        } else {
          throw new Error(response.error.message);
        }
      }
      callback(error, response);
    }, chainId);
  };
};

// TODO: rename to loggerMiddleware
const loggingProviderMiddleware = next => {
  return (request, callback, chainId) => {
    const chainIdLabel = chainId ? ` chainId:${chainId}` : '';
    logger.info(`[provider request]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params);
    next(request, (error, response) => {
      if (error) {
        logger.warn(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `error:`, error);
      } else {
        logger.info(`[provider response]${chainIdLabel} id:${request.id} method:${request.method} params:`, request.params, `response:`, response);
      }
      callback(error, response);
    }, chainId);
  };
};

const networkProviderMiddleware = getChainId => next => {
  return (request, callback, chainId) => {
    const networkChainId = getChainId(request);
    const {
      id,
      method
    } = request;
    switch (method) {
      case 'net_version':
        callback(undefined, {
          jsonrpc: '2.0',
          id: id,
          result: `${networkChainId}`
        });
        return;
      case 'eth_chainId':
        callback(undefined, {
          jsonrpc: '2.0',
          id: id,
          result: ethers.utils.hexlify(networkChainId)
        });
        return;
    }

    // request is allowed. keep going..
    next(request, callback, chainId);
  };
};

const SignerJsonRpcMethods = ['personal_sign', 'eth_sign', 'eth_signTypedData', 'eth_signTypedData_v4', 'eth_sendTransaction', 'eth_sendRawTransaction', 'sequence_getWalletContext', 'sequence_getWalletConfig', 'sequence_getWalletState', 'sequence_getNetworks', 'sequence_updateConfig', 'sequence_publishConfig', 'sequence_gasRefundOptions', 'sequence_getNonce', 'sequence_relay', 'eth_decrypt', 'eth_getEncryptionPublicKey', 'wallet_addEthereumChain', 'wallet_switchEthereumChain', 'wallet_registerOnboarding', 'wallet_watchAsset', 'wallet_scanQRCode'];
class SigningProvider {
  constructor(provider) {
    this.provider = void 0;
    this.sendAsyncMiddleware = next => {
      return (request, callback, chainId) => {
        // Forward signing requests to the signing provider
        if (SignerJsonRpcMethods.includes(request.method)) {
          this.provider.sendAsync(request, callback, chainId);
          return;
        }

        // Continue to next handler
        next(request, callback, chainId);
      };
    };
    this.provider = provider;
  }
}

class PublicProvider {
  constructor(rpcUrl) {
    this.privateJsonRpcMethods = ['net_version', 'eth_chainId', 'eth_accounts', ...SignerJsonRpcMethods];
    this.provider = void 0;
    this.rpcUrl = void 0;
    this.sendAsyncMiddleware = next => {
      return (request, callback) => {
        // When provider is configured, send non-private methods to our local public provider
        if (this.provider && !this.privateJsonRpcMethods.includes(request.method)) {
          this.provider.send(request.method, request.params).then(r => {
            callback(undefined, {
              jsonrpc: '2.0',
              id: request.id,
              result: r
            });
          }).catch(e => callback(e));
          return;
        }

        // Continue to next handler
        logger.debug('[public-provider] sending request to signer window', request.method);
        next(request, callback);
      };
    };
    if (rpcUrl) {
      this.setRpcUrl(rpcUrl);
    }
  }
  getRpcUrl() {
    return this.rpcUrl;
  }
  setRpcUrl(rpcUrl) {
    if (!rpcUrl || rpcUrl === '') {
      this.rpcUrl = undefined;
      this.provider = undefined;
    } else {
      this.rpcUrl = rpcUrl;
      // TODO: maybe use @0xsequence/network JsonRpcProvider here instead,
      // which supports better caching.
      this.provider = new providers.JsonRpcProvider(rpcUrl);
    }
  }
}

class SingleflightMiddleware {
  constructor() {
    this.singleflightJsonRpcMethods = ['eth_chainId', 'net_version', 'eth_call', 'eth_getCode', 'eth_blockNumber', 'eth_getBalance', 'eth_getStorageAt', 'eth_getTransactionCount', 'eth_getBlockTransactionCountByHash', 'eth_getBlockTransactionCountByNumber', 'eth_getUncleCountByBlockHash', 'eth_getUncleCountByBlockNumber', 'eth_getBlockByHash', 'eth_getBlockByNumber', 'eth_getTransactionByHash', 'eth_getTransactionByBlockHashAndIndex', 'eth_getTransactionByBlockNumberAndIndex', 'eth_getTransactionReceipt', 'eth_getUncleByBlockHashAndIndex', 'eth_getUncleByBlockNumberAndIndex', 'eth_getLogs'];
    this.inflight = void 0;
    this.sendAsyncMiddleware = next => {
      return (request, callback, chainId) => {
        // continue to next handler if method isn't part of methods list
        if (!this.singleflightJsonRpcMethods.includes(request.method)) {
          next(request, callback, chainId);
          return;
        }
        const key = this.requestKey(request.method, request.params || [], chainId);
        if (!this.inflight[key]) {
          // first request -- init the empty list
          this.inflight[key] = [];
        } else {
          // already in-flight, add the callback to the list and return
          this.inflight[key].push({
            id: request.id,
            callback
          });
          return;
        }

        // Continue down the handler chain
        next(request, (error, response, chainId) => {
          // callback the original request
          callback(error, response);

          // callback all other requests of the same kind in queue, with the
          // same response result as from the first response.
          for (let i = 0; i < this.inflight[key].length; i++) {
            const sub = this.inflight[key][i];
            if (error) {
              sub.callback(error, response);
            } else if (response) {
              sub.callback(undefined, {
                jsonrpc: '2.0',
                id: sub.id,
                result: response.result
              });
            }
          }

          // clear request key
          delete this.inflight[key];
        }, chainId);
      };
    };
    this.requestKey = (method, params, chainId) => {
      let key = '';
      if (chainId) {
        key = `${chainId}:${method}:`;
      } else {
        key = `:${method}:`;
      }
      if (!params || params.length === 0) {
        return key + '[]';
      }
      return key + JSON.stringify(params);
    };
    this.inflight = {};
  }
}

// JsonRpcProvider with a middleware stack. By default it will use a simple caching middleware.
class JsonRpcProvider extends ethers.providers.JsonRpcProvider {
  constructor(url, options) {
    super(url, options == null ? void 0 : options.chainId);
    this._chainId = void 0;
    this._sender = void 0;
    this.send = (method, params) => {
      return this._sender.send(method, params);
    };
    this.fetch = (method, params) => {
      const request = {
        method: method,
        params: params,
        id: this._nextId++,
        jsonrpc: '2.0'
      };
      const result = ethers.utils.fetchJson(this.connection, JSON.stringify(request), getResult).then(result => {
        return result;
      }, error => {
        throw error;
      });
      return result;
    };
    const chainId = options == null ? void 0 : options.chainId;
    const middlewares = options == null ? void 0 : options.middlewares;
    const blockCache = options == null ? void 0 : options.blockCache;
    this._chainId = chainId;

    // NOTE: it will either use the middleware stack passed to the constructor
    // or it will use the default caching middleware provider. It does not concat them,
    // so if you set middlewares, make sure you set the caching middleware yourself if you'd
    // like to keep using it.
    const router = new JsonRpcRouter(middlewares != null ? middlewares : [
    // loggingProviderMiddleware,
    new EagerProvider({
      chainId
    }), new SingleflightMiddleware(), new CachedProvider({
      defaultChainId: chainId,
      blockCache: blockCache
    })], new JsonRpcSender(this.fetch, chainId));
    this._sender = new JsonRpcSender(router, chainId);
  }
  async getNetwork() {
    const chainId = this._chainId;
    if (chainId) {
      const network = networks[chainId];
      const name = (network == null ? void 0 : network.name) || '';
      const ensAddress = network == null ? void 0 : network.ensAddress;
      return {
        name: name,
        chainId: chainId,
        ensAddress: ensAddress
      };
    } else {
      const chainIdHex = await this.send('eth_chainId', []);
      this._chainId = ethers.BigNumber.from(chainIdHex).toNumber();
      return this.getNetwork();
    }
  }
}
function getResult(payload) {
  if (payload.error) {
    // @TODO: not any
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}

export { AllowProvider, CachedProvider, ChainId, EagerProvider, JsonRpcExternalProvider, JsonRpcProvider, JsonRpcRouter, JsonRpcSender, JsonRpcVersion, PublicProvider, SigningProvider, SingleflightMiddleware, allowProviderMiddleware, checkNetworkConfig, createJsonRpcMiddlewareStack, ensureUniqueNetworks, ensureValidNetworks, exceptionProviderMiddleware, findNetworkConfig, getAuthNetwork, getChainId, indexerURL, isJsonRpcHandler, isJsonRpcProvider, isNetworkConfig, isValidNetworkConfig, loggingProviderMiddleware, mainnetNetworks, maybeChainId, networkProviderMiddleware, networks, networksIndex, nodesURL, relayerURL, sequenceContext, sortNetworks, stringTemplate, testnetNetworks, updateNetworkConfig, validateAndSortNetworks };

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

/* eslint-disable */
// sequence-indexer v0.4.0 3254a537c563d6b612b7ab5365c305664abb5951
// --
// Code generated by webrpc-gen@v0.10.x-dev with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=indexer.ridl -target=typescript -client -out=./clients/indexer.gen.ts

// WebRPC description and code-gen version
const WebRPCVersion = "v1";

// Schema version of your RIDL schema
const WebRPCSchemaVersion = "v0.4.0";

// Schema hash generated from your RIDL schema
const WebRPCSchemaHash = "3254a537c563d6b612b7ab5365c305664abb5951";

//
// Types
//

exports.ContractType = void 0;
(function (ContractType) {
  ContractType["UNKNOWN"] = "UNKNOWN";
  ContractType["ERC20"] = "ERC20";
  ContractType["ERC721"] = "ERC721";
  ContractType["ERC1155"] = "ERC1155";
  ContractType["SEQUENCE_WALLET"] = "SEQUENCE_WALLET";
  ContractType["ERC20_BRIDGE"] = "ERC20_BRIDGE";
  ContractType["ERC721_BRIDGE"] = "ERC721_BRIDGE";
  ContractType["ERC1155_BRIDGE"] = "ERC1155_BRIDGE";
})(exports.ContractType || (exports.ContractType = {}));
exports.EventLogType = void 0;
(function (EventLogType) {
  EventLogType["UNKNOWN"] = "UNKNOWN";
  EventLogType["BLOCK_ADDED"] = "BLOCK_ADDED";
  EventLogType["BLOCK_REMOVED"] = "BLOCK_REMOVED";
})(exports.EventLogType || (exports.EventLogType = {}));
exports.EventLogDataType = void 0;
(function (EventLogDataType) {
  EventLogDataType["UNKNOWN"] = "UNKNOWN";
  EventLogDataType["TOKEN_TRANSFER"] = "TOKEN_TRANSFER";
  EventLogDataType["NATIVE_TOKEN_TRANSFER"] = "NATIVE_TOKEN_TRANSFER";
  EventLogDataType["SEQUENCE_TXN"] = "SEQUENCE_TXN";
})(exports.EventLogDataType || (exports.EventLogDataType = {}));
exports.TxnTransferType = void 0;
(function (TxnTransferType) {
  TxnTransferType["UNKNOWN"] = "UNKNOWN";
  TxnTransferType["SEND"] = "SEND";
  TxnTransferType["RECEIVE"] = "RECEIVE";
})(exports.TxnTransferType || (exports.TxnTransferType = {}));
exports.TransactionStatus = void 0;
(function (TransactionStatus) {
  TransactionStatus["FAILED"] = "FAILED";
  TransactionStatus["SUCCESSFUL"] = "SUCCESSFUL";
})(exports.TransactionStatus || (exports.TransactionStatus = {}));
exports.TransactionType = void 0;
(function (TransactionType) {
  TransactionType["LegacyTxnType"] = "LegacyTxnType";
  TransactionType["AccessListTxnType"] = "AccessListTxnType";
  TransactionType["DynamicFeeTxnType"] = "DynamicFeeTxnType";
})(exports.TransactionType || (exports.TransactionType = {}));
exports.SortOrder = void 0;
(function (SortOrder) {
  SortOrder["DESC"] = "DESC";
  SortOrder["ASC"] = "ASC";
})(exports.SortOrder || (exports.SortOrder = {}));
//
// Client
//
class Indexer {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/Indexer/';
    this.ping = headers => {
      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };
    this.version = headers => {
      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            version: _data.version
          };
        });
      });
    };
    this.runtimeStatus = headers => {
      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };
    this.getChainID = headers => {
      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            chainID: _data.chainID
          };
        });
      });
    };
    this.getEtherBalance = (args, headers) => {
      return this.fetch(this.url('GetEtherBalance'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            balance: _data.balance
          };
        });
      });
    };
    this.getTokenBalances = (args, headers) => {
      return this.fetch(this.url('GetTokenBalances'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            balances: _data.balances
          };
        });
      });
    };
    this.getTokenSupplies = (args, headers) => {
      return this.fetch(this.url('GetTokenSupplies'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            contractType: _data.contractType,
            tokenIDs: _data.tokenIDs
          };
        });
      });
    };
    this.getTokenSuppliesMap = (args, headers) => {
      return this.fetch(this.url('GetTokenSuppliesMap'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            supplies: _data.supplies
          };
        });
      });
    };
    this.getBalanceUpdates = (args, headers) => {
      return this.fetch(this.url('GetBalanceUpdates'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            balances: _data.balances
          };
        });
      });
    };
    this.getTransactionHistory = (args, headers) => {
      return this.fetch(this.url('GetTransactionHistory'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            transactions: _data.transactions
          };
        });
      });
    };
    this.syncBalance = (args, headers) => {
      return this.fetch(this.url('SyncBalance'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {};
        });
      });
    };
    this.fetchTransactionReceipt = (args, headers) => {
      return this.fetch(this.url('FetchTransactionReceipt'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            receipt: _data.receipt
          };
        });
      });
    };
    this.fetchTransactionReceiptWithFilter = (args, headers) => {
      return this.fetch(this.url('FetchTransactionReceiptWithFilter'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            receipt: _data.receipt
          };
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input, init) => fetch(input, init);
  }
  url(name) {
    return this.hostname + this.path + name;
  }
}
const createHTTPRequest = (body = {}, headers = {}) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {})
  };
};
const buildResponse = res => {
  return res.text().then(text => {
    let data;
    try {
      data = JSON.parse(text);
    } catch (err) {
      throw {
        code: 'unknown',
        msg: `expecting JSON, got: ${text}`,
        status: res.status
      };
    }
    if (!res.ok) {
      throw data; // webrpc error response
    }

    return data;
  });
};

// TODO: rename to SequenceIndexerNetworks
exports.SequenceIndexerServices = void 0;
(function (SequenceIndexerServices) {
  SequenceIndexerServices["MAINNET"] = "https://mainnet-indexer.sequence.app";
  SequenceIndexerServices["POLYGON"] = "https://polygon-indexer.sequence.app";
  SequenceIndexerServices["POLYGON_MUMBAI"] = "https://mumbai-indexer.sequence.app";
  SequenceIndexerServices["POLYGON_ZKEVM"] = "https://polygon-zkevm-indexer.sequence.app";
  SequenceIndexerServices["ARBITRUM"] = "https://arbitrum-indexer.sequence.app";
  SequenceIndexerServices["ARBITRUM_NOVA"] = "https://arbitrum-nova-indexer.sequence.app";
  SequenceIndexerServices["OPTIMISM"] = "https://optimism-indexer.sequence.app";
  SequenceIndexerServices["AVALANCHE"] = "https://avalanche-indexer.sequence.app";
  SequenceIndexerServices["GNOSIS"] = "https://gnosis-indexer.sequence.app";
  SequenceIndexerServices["BSC"] = "https://bsc-indexer.sequence.app";
  SequenceIndexerServices["BSC_TESTNET"] = "https://bsc-testnet-indexer.sequence.app";
  SequenceIndexerServices["GOERLI"] = "https://goerli-indexer.sequence.app";
})(exports.SequenceIndexerServices || (exports.SequenceIndexerServices = {}));
const fetch = typeof global === 'object' ? global.fetch : window.fetch;
class SequenceIndexerClient extends Indexer {
  constructor(hostname, jwtAuth) {
    super(hostname.endsWith('/') ? hostname.slice(0, -1) : hostname, fetch);
    this.jwtAuth = jwtAuth;
    this._fetch = (input, init) => {
      // automatically include jwt auth header to requests
      // if its been set on the api client
      const headers = {};
      if (this.jwtAuth && this.jwtAuth.length > 0) {
        headers['Authorization'] = `BEARER ${this.jwtAuth}`;
      }

      // before the request is made
      init.headers = _extends({}, init.headers, headers);
      return fetch(input, init);
    };
    this.fetch = this._fetch;
  }
}

// const SequenceIndexerServices: { [key: string]: string } = {}

// {
//   [ ...mainnetNetworks, ...testnetNetworks ].forEach(n => {
//     if (n.indexerUrl) {
//       SequenceIndexerServices[n.name.toUpperCase()] = n.indexerUrl
//     }
//   })
// }

// export { SequenceIndexerServices }

exports.Indexer = Indexer;
exports.SequenceIndexerClient = SequenceIndexerClient;
exports.WebRPCSchemaHash = WebRPCSchemaHash;
exports.WebRPCSchemaVersion = WebRPCSchemaVersion;
exports.WebRPCVersion = WebRPCVersion;

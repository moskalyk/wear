import { ethers } from 'ethers';
import { Transaction, SignedTransactions, TransactionResponse } from '@0xsequence/transactions';
import { BaseRelayer, BaseRelayerOptions } from '../base-relayer';
import { FeeOption, FeeQuote, Relayer, SimulateResult } from '..';
import { WalletContext } from '@0xsequence/network';
import { WalletConfig } from '@0xsequence/config';
import * as proto from './relayer.gen';
export { proto };
export interface RpcRelayerOptions extends BaseRelayerOptions {
    url: string;
}
export declare function isRpcRelayerOptions(obj: any): obj is RpcRelayerOptions;
export declare class RpcRelayer extends BaseRelayer implements Relayer {
    private readonly service;
    constructor(options: RpcRelayerOptions);
    waitReceipt(metaTxnId: string | SignedTransactions, delay?: number, maxFails?: number, isCancelled?: () => boolean): Promise<proto.GetMetaTxnReceiptReturn>;
    simulate(wallet: string, ...transactions: Transaction[]): Promise<SimulateResult[]>;
    getFeeOptions(config: WalletConfig, context: WalletContext, ...transactions: Transaction[]): Promise<{
        options: FeeOption[];
        quote?: FeeQuote;
    }>;
    gasRefundOptions(config: WalletConfig, context: WalletContext, ...transactions: Transaction[]): Promise<FeeOption[]>;
    getNonce(config: WalletConfig, context: WalletContext, space?: ethers.BigNumberish): Promise<ethers.BigNumberish>;
    relay(signedTxs: SignedTransactions, quote?: FeeQuote, waitForReceipt?: boolean): Promise<TransactionResponse<RelayerTxReceipt>>;
    wait(metaTxnId: string | SignedTransactions, timeout?: number, delay?: number, maxFails?: number): Promise<TransactionResponse<RelayerTxReceipt>>;
}
export type RelayerTxReceipt = {
    blockHash: string;
    blockNumber: string;
    contractAddress: string;
    cumulativeGasUsed: string;
    gasUsed: string;
    logs: {
        address: string;
        blockHash: string;
        blockNumber: string;
        data: string;
        logIndex: string;
        removed: boolean;
        topics: string[];
        transactionHash: string;
        transactionIndex: string;
    }[];
    logsBloom: string;
    root: string;
    status: string;
    transactionHash: string;
    transactionIndex: string;
};

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ethers = require('ethers');
var abi = require('@0xsequence/abi');
var transactions = require('@0xsequence/transactions');
var utils = require('@0xsequence/utils');
var config = require('@0xsequence/config');

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function isBaseRelayerOptions(obj) {
  return obj.bundleCreation !== undefined && typeof obj.bundleCreation === 'boolean' || obj.creationGasLimit !== undefined && utils.isBigNumberish(obj.creationGasLimit) || obj.provider !== undefined && (ethers.providers.Provider.isProvider(obj.provider) || typeof obj.provider === 'string');
}
const BaseRelayerDefaults = {
  bundleCreation: true,
  creationGasLimit: ethers.ethers.constants.Two.pow(17)
};
class BaseRelayer {
  constructor(options) {
    this.provider = void 0;
    this.bundleCreation = void 0;
    this.creationGasLimit = void 0;
    const opts = _extends({}, BaseRelayerDefaults, options);
    this.bundleCreation = opts.bundleCreation;
    this.provider = opts.provider;
    this.creationGasLimit = ethers.ethers.BigNumber.from(opts.creationGasLimit);
  }
  async isWalletDeployed(walletAddress) {
    if (!this.provider) throw new Error('Bundled creation provider not found');
    return (await this.provider.getCode(walletAddress)) !== '0x';
  }
  prepareWalletDeploy(config$1, context) {
    const factoryInterface = new ethers.utils.Interface(abi.walletContracts.factory.abi);
    return {
      to: context.factory,
      data: factoryInterface.encodeFunctionData(factoryInterface.getFunction('deploy'), [context.mainModule, config.imageHash(config$1)])
    };
  }
  async prependWalletDeploy(signedTransactions) {
    const {
      config: config$1,
      context,
      transactions: transactions$1,
      nonce,
      signature
    } = signedTransactions;
    const walletAddress = config.addressOf(config$1, context);
    const walletInterface = new ethers.utils.Interface(abi.walletContracts.mainModule.abi);
    const encodedSignature = async function () {
      const sig = await signature;
      if (typeof sig === 'string') return sig;
      return config.encodeSignature(sig);
    }();
    if (this.bundleCreation && !(await this.isWalletDeployed(walletAddress))) {
      return {
        to: context.guestModule,
        execute: {
          transactions: [_extends({}, this.prepareWalletDeploy(config$1, context), {
            delegateCall: false,
            revertOnError: false,
            gasLimit: this.creationGasLimit,
            value: ethers.ethers.constants.Zero
          }), {
            delegateCall: false,
            revertOnError: true,
            gasLimit: ethers.ethers.constants.Zero,
            to: walletAddress,
            value: ethers.ethers.constants.Zero,
            data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [transactions.sequenceTxAbiEncode(transactions$1), nonce, await encodedSignature])
          }],
          nonce: ethers.ethers.constants.Zero,
          signature: '0x'
        }
      };
    } else {
      return {
        to: walletAddress,
        execute: {
          transactions: transactions$1,
          nonce: ethers.ethers.BigNumber.from(nonce),
          signature: await encodedSignature
        }
      };
    }
  }
  async prepareTransactions(config, context, signature, ...transactions$1) {
    //, gasLimit?: ethers.BigNumberish }> {
    const nonce = transactions.readSequenceNonce(...transactions$1);
    if (!nonce) {
      throw new Error('Unable to prepare transactions without a defined nonce');
    }
    const {
      to,
      execute
    } = await this.prependWalletDeploy({
      config,
      context,
      transactions: transactions$1,
      nonce,
      signature
    });
    const walletInterface = new ethers.utils.Interface(abi.walletContracts.mainModule.abi);
    return {
      to,
      data: walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [transactions.sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature])
    };
  }
}

const DEFAULT_GAS_LIMIT = ethers.ethers.BigNumber.from(800000);
const ProviderRelayerDefaults = {
  waitPollRate: 1000,
  deltaBlocksLog: 12,
  fromBlockLog: -1024
};
function isProviderRelayerOptions(obj) {
  return obj.provider !== undefined && ethers.providers.Provider.isProvider(obj.provider);
}
class ProviderRelayer extends BaseRelayer {
  constructor(options) {
    super(options);
    this.provider = void 0;
    this.waitPollRate = void 0;
    this.deltaBlocksLog = void 0;
    this.fromBlockLog = void 0;
    const opts = _extends({}, ProviderRelayerDefaults, options);
    this.provider = opts.provider;
    this.waitPollRate = opts.waitPollRate;
    this.deltaBlocksLog = opts.deltaBlocksLog;
    this.fromBlockLog = opts.fromBlockLog;
  }
  async simulate(wallet, ...transactions) {
    var _this = this;
    return (await Promise.all(transactions.map(async function (tx) {
      // Respect gasLimit request of the transaction (as long as its not 0)
      if (tx.gasLimit && !ethers.ethers.BigNumber.from(tx.gasLimit || 0).eq(ethers.ethers.constants.Zero)) {
        return tx.gasLimit;
      }

      // Fee can't be estimated locally for delegateCalls
      if (tx.delegateCall) {
        return DEFAULT_GAS_LIMIT;
      }

      // Fee can't be estimated for self-called if wallet hasn't been deployed
      if (tx.to === wallet && !(await _this.isWalletDeployed(wallet))) {
        return DEFAULT_GAS_LIMIT;
      }
      if (!_this.provider) {
        throw new Error('signer.provider is not set, but is required');
      }

      // TODO: If the wallet address has been deployed, gas limits can be
      // estimated with more accurately by using self-calls with the batch transactions one by one
      return _this.provider.estimateGas({
        from: wallet,
        to: tx.to,
        data: tx.data,
        value: tx.value
      });
    }))).map(gasLimit => ({
      executed: true,
      succeeded: true,
      gasUsed: ethers.ethers.BigNumber.from(gasLimit).toNumber(),
      gasLimit: ethers.ethers.BigNumber.from(gasLimit).toNumber()
    }));
  }
  async getNonce(config$1, context, space, blockTag) {
    if (!this.provider) {
      throw new Error('provider is not set');
    }
    const addr = config.addressOf(config$1, context);
    if ((await this.provider.getCode(addr)) === '0x') {
      return 0;
    }
    if (space === undefined) {
      space = 0;
    }
    const module = new ethers.ethers.Contract(addr, abi.walletContracts.mainModule.abi, this.provider);
    const nonce = await module.readNonce(space, {
      blockTag: blockTag
    });
    return transactions.encodeNonce(space, nonce);
  }
  async wait(metaTxnId, timeout, delay = this.waitPollRate, maxFails = 5) {
    var _this2 = this;
    if (typeof metaTxnId !== 'string') {
      utils.logger.info('computing id', metaTxnId.config, metaTxnId.context, metaTxnId.chainId, ...metaTxnId.transactions);
      metaTxnId = transactions.computeMetaTxnHash(config.addressOf(metaTxnId.config, metaTxnId.context), metaTxnId.chainId, ...metaTxnId.transactions);
    }
    let timedOut = false;
    const retry = async function retry(f, errorMessage) {
      let fails = 0;
      while (!timedOut) {
        try {
          return await f();
        } catch (error) {
          fails++;
          if (maxFails !== undefined && fails >= maxFails) {
            utils.logger.error(`giving up after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ''}`, error);
            throw error;
          } else {
            utils.logger.warn(`attempt #${fails} failed${errorMessage ? `: ${errorMessage}` : ''}`, error);
          }
        }
        if (delay > 0) {
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
      throw new Error(`timed out after ${fails} failed attempts${errorMessage ? `: ${errorMessage}` : ''}`);
    };
    const waitReceipt = async function waitReceipt() {
      // Transactions can only get executed on nonce change
      // get all nonce changes and look for metaTxnIds in between logs
      let lastBlock = _this2.fromBlockLog;
      if (lastBlock < 0) {
        const block = await retry(() => _this2.provider.getBlockNumber(), 'unable to get latest block number');
        lastBlock = block + lastBlock;
      }
      if (typeof metaTxnId !== 'string') {
        throw new Error('impossible');
      }
      const normalMetaTxnId = metaTxnId.replace('0x', '');
      while (!timedOut) {
        const block = await retry(() => _this2.provider.getBlockNumber(), 'unable to get latest block number');
        const logs = await retry(() => _this2.provider.getLogs({
          fromBlock: Math.max(0, lastBlock - _this2.deltaBlocksLog),
          toBlock: block,
          // Nonce change event topic
          topics: ['0x1f180c27086c7a39ea2a7b25239d1ab92348f07ca7bb59d1438fcf527568f881']
        }), `unable to get NonceChange logs for blocks ${Math.max(0, lastBlock - _this2.deltaBlocksLog)} to ${block}`);
        lastBlock = block;

        // Get receipts of all transactions
        const txs = await Promise.all(logs.map(l => retry(() => _this2.provider.getTransactionReceipt(l.transactionHash), `unable to get receipt for transaction ${l.transactionHash}`)));

        // Find a transaction with a TxExecuted log
        const found = txs.find(tx => tx.logs.find(l => l.topics.length === 0 && l.data.replace('0x', '') === normalMetaTxnId || l.topics.length === 1 &&
        // TxFailed event topic
        l.topics[0] === '0x3dbd1590ea96dd3253a91f24e64e3a502e1225d602a5731357bc12643070ccd7' && l.data.length >= 64 && l.data.replace('0x', '').startsWith(normalMetaTxnId)));

        // If found return that
        if (found) {
          return _extends({
            receipt: found
          }, await retry(() => _this2.provider.getTransaction(found.transactionHash), `unable to get transaction ${found.transactionHash}`));
        }

        // Otherwise wait and try again
        if (!timedOut) {
          await new Promise(r => setTimeout(r, delay));
        }
      }
      throw new Error(`Timeout waiting for transaction receipt ${metaTxnId}`);
    };
    if (timeout !== undefined) {
      return Promise.race([waitReceipt(), new Promise((_, reject) => setTimeout(() => {
        timedOut = true;
        reject(`Timeout waiting for transaction receipt ${metaTxnId}`);
      }, timeout))]);
    } else {
      return waitReceipt();
    }
  }
}

function isLocalRelayerOptions(obj) {
  return obj.signer !== undefined && ethers.Signer.isSigner(obj.signer);
}
class LocalRelayer extends ProviderRelayer {
  constructor(options) {
    super(ethers.Signer.isSigner(options) ? {
      provider: options.provider
    } : _extends({}, options, {
      provider: options.signer.provider
    }));
    this.signer = void 0;
    this.txnOptions = void 0;
    this.signer = ethers.Signer.isSigner(options) ? options : options.signer;
    if (!this.signer.provider) throw new Error("Signer must have a provider");
  }
  async deployWallet(config, context) {
    // NOTE: on hardhat some tests fail on HookCallerMock when not passing gasLimit directly as below,
    // and using eth_gasEstimate. Perhaps review HookCallerMock.sol and fix it to avoid what looks
    // like an infinite loop?
    const walletDeployTxn = this.prepareWalletDeploy(config, context);

    // NOTE: for hardhat to pass, we have to set the gasLimit directly, as its unable to estimate
    return this.signer.sendTransaction(_extends({}, walletDeployTxn, {
      gasLimit: ethers.ethers.constants.Two.pow(17)
    }));
  }
  async getFeeOptions(_config, _context, ..._transactions) {
    return {
      options: []
    };
  }
  async gasRefundOptions(config, context, ...transactions) {
    const {
      options
    } = await this.getFeeOptions(config, context, ...transactions);
    return options;
  }
  setTransactionOptions(transactionRequest) {
    this.txnOptions = transactionRequest;
  }
  async relay(signedTxs, quote, waitForReceipt = true) {
    if (quote !== undefined) {
      utils.logger.warn(`LocalRelayer doesn't accept fee quotes`);
    }
    if (!signedTxs.context.guestModule || signedTxs.context.guestModule.length !== 42) {
      throw new Error('LocalRelayer requires the context.guestModule address');
    }
    const {
      to,
      execute
    } = await this.prependWalletDeploy(signedTxs);
    const walletInterface = new ethers.ethers.utils.Interface(abi.walletContracts.mainModule.abi);
    const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [transactions.sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);

    // TODO: think about computing gas limit individually, summing together and passing across
    // NOTE: we expect that all txns have set their gasLimit ahead of time through proper estimation
    // const gasLimit = signedTxs.transactions.reduce((sum, tx) => sum.add(tx.gasLimit), ethers.BigNumber.from(0))
    // txRequest.gasLimit = gasLimit

    const responsePromise = this.signer.sendTransaction(_extends({
      to,
      data
    }, this.txnOptions));
    if (waitForReceipt) {
      const response = await responsePromise;
      response.receipt = await response.wait();
      return response;
    } else {
      return responsePromise;
    }
  }
}

/* eslint-disable */
// sequence-relayer v0.4.0 752f4f4274ca80d2fd974b5b44ed8245dfe40554
// --
// Code generated by webrpc-gen@v0.10.x-dev with typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=relayer.ridl -target=typescript -client -out=./clients/relayer.gen.ts

// WebRPC description and code-gen version
const WebRPCVersion = "v1";

// Schema version of your RIDL schema
const WebRPCSchemaVersion = "v0.4.0";

// Schema hash generated from your RIDL schema
const WebRPCSchemaHash = "752f4f4274ca80d2fd974b5b44ed8245dfe40554";

//
// Types
//

let ETHTxnStatus;
(function (ETHTxnStatus) {
  ETHTxnStatus["UNKNOWN"] = "UNKNOWN";
  ETHTxnStatus["DROPPED"] = "DROPPED";
  ETHTxnStatus["QUEUED"] = "QUEUED";
  ETHTxnStatus["SENT"] = "SENT";
  ETHTxnStatus["SUCCEEDED"] = "SUCCEEDED";
  ETHTxnStatus["PARTIALLY_FAILED"] = "PARTIALLY_FAILED";
  ETHTxnStatus["FAILED"] = "FAILED";
})(ETHTxnStatus || (ETHTxnStatus = {}));
let TransferType;
(function (TransferType) {
  TransferType["SEND"] = "SEND";
  TransferType["RECEIVE"] = "RECEIVE";
  TransferType["BRIDGE_DEPOSIT"] = "BRIDGE_DEPOSIT";
  TransferType["BRIDGE_WITHDRAW"] = "BRIDGE_WITHDRAW";
  TransferType["BURN"] = "BURN";
  TransferType["UNKNOWN"] = "UNKNOWN";
})(TransferType || (TransferType = {}));
let FeeTokenType;
(function (FeeTokenType) {
  FeeTokenType["UNKNOWN"] = "UNKNOWN";
  FeeTokenType["ERC20_TOKEN"] = "ERC20_TOKEN";
  FeeTokenType["ERC1155_TOKEN"] = "ERC1155_TOKEN";
})(FeeTokenType || (FeeTokenType = {}));
let SortOrder;
(function (SortOrder) {
  SortOrder["DESC"] = "DESC";
  SortOrder["ASC"] = "ASC";
})(SortOrder || (SortOrder = {}));
//
// Client
//
class Relayer {
  constructor(hostname, fetch) {
    this.hostname = void 0;
    this.fetch = void 0;
    this.path = '/rpc/Relayer/';
    this.ping = headers => {
      return this.fetch(this.url('Ping'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };
    this.version = headers => {
      return this.fetch(this.url('Version'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            version: _data.version
          };
        });
      });
    };
    this.runtimeStatus = headers => {
      return this.fetch(this.url('RuntimeStatus'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status
          };
        });
      });
    };
    this.getSequenceContext = headers => {
      return this.fetch(this.url('GetSequenceContext'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            data: _data.data
          };
        });
      });
    };
    this.getChainID = headers => {
      return this.fetch(this.url('GetChainID'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            chainID: _data.chainID
          };
        });
      });
    };
    this.sendMetaTxn = (args, headers) => {
      return this.fetch(this.url('SendMetaTxn'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            txnHash: _data.txnHash
          };
        });
      });
    };
    this.getMetaTxnNonce = (args, headers) => {
      return this.fetch(this.url('GetMetaTxnNonce'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            nonce: _data.nonce
          };
        });
      });
    };
    this.getMetaTxnReceipt = (args, headers) => {
      return this.fetch(this.url('GetMetaTxnReceipt'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            receipt: _data.receipt
          };
        });
      });
    };
    this.simulate = (args, headers) => {
      return this.fetch(this.url('Simulate'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            results: _data.results
          };
        });
      });
    };
    this.updateMetaTxnGasLimits = (args, headers) => {
      return this.fetch(this.url('UpdateMetaTxnGasLimits'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            payload: _data.payload
          };
        });
      });
    };
    this.feeTokens = headers => {
      return this.fetch(this.url('FeeTokens'), createHTTPRequest({}, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            isFeeRequired: _data.isFeeRequired,
            tokens: _data.tokens
          };
        });
      });
    };
    this.feeOptions = (args, headers) => {
      return this.fetch(this.url('FeeOptions'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            options: _data.options,
            quote: _data.quote
          };
        });
      });
    };
    this.getMetaTxnNetworkFeeOptions = (args, headers) => {
      return this.fetch(this.url('GetMetaTxnNetworkFeeOptions'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            options: _data.options
          };
        });
      });
    };
    this.sentTransactions = (args, headers) => {
      return this.fetch(this.url('SentTransactions'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            transactions: _data.transactions
          };
        });
      });
    };
    this.pendingTransactions = (args, headers) => {
      return this.fetch(this.url('PendingTransactions'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            transactions: _data.transactions
          };
        });
      });
    };
    this.listGasSponsors = (args, headers) => {
      return this.fetch(this.url('ListGasSponsors'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            page: _data.page,
            gasSponsors: _data.gasSponsors
          };
        });
      });
    };
    this.addGasSponsor = (args, headers) => {
      return this.fetch(this.url('AddGasSponsor'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            gasSponsor: _data.gasSponsor
          };
        });
      });
    };
    this.updateGasSponsor = (args, headers) => {
      return this.fetch(this.url('UpdateGasSponsor'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            status: _data.status,
            gasSponsor: _data.gasSponsor
          };
        });
      });
    };
    this.reportGasSponsorUsage = (args, headers) => {
      return this.fetch(this.url('ReportGasSponsorUsage'), createHTTPRequest(args, headers)).then(res => {
        return buildResponse(res).then(_data => {
          return {
            gasSponsorUsage: _data.gasSponsorUsage
          };
        });
      });
    };
    this.hostname = hostname;
    this.fetch = (input, init) => fetch(input, init);
  }
  url(name) {
    return this.hostname + this.path + name;
  }
}
const createHTTPRequest = (body = {}, headers = {}) => {
  return {
    method: 'POST',
    headers: _extends({}, headers, {
      'Content-Type': 'application/json'
    }),
    body: JSON.stringify(body || {})
  };
};
const buildResponse = res => {
  return res.text().then(text => {
    let data;
    try {
      data = JSON.parse(text);
    } catch (err) {
      throw {
        code: 'unknown',
        msg: `expecting JSON, got: ${text}`,
        status: res.status
      };
    }
    if (!res.ok) {
      throw data; // webrpc error response
    }

    return data;
  });
};

var relayer_gen = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WebRPCVersion: WebRPCVersion,
  WebRPCSchemaVersion: WebRPCSchemaVersion,
  WebRPCSchemaHash: WebRPCSchemaHash,
  get ETHTxnStatus () { return ETHTxnStatus; },
  get TransferType () { return TransferType; },
  get FeeTokenType () { return FeeTokenType; },
  get SortOrder () { return SortOrder; },
  Relayer: Relayer
});

const FINAL_STATUSES = [ETHTxnStatus.DROPPED, ETHTxnStatus.SUCCEEDED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.FAILED];
const FAILED_STATUSES = [ETHTxnStatus.DROPPED, ETHTxnStatus.PARTIALLY_FAILED, ETHTxnStatus.FAILED];
function isRpcRelayerOptions(obj) {
  return obj.url !== undefined && typeof obj.url === 'string';
}
const fetch = typeof global === 'object' ? global.fetch : window.fetch;
class RpcRelayer extends BaseRelayer {
  constructor(options) {
    super(options);
    this.service = void 0;
    this.service = new Relayer(options.url, fetch);
  }
  async waitReceipt(metaTxnId, delay = 1000, maxFails = 5, isCancelled) {
    if (typeof metaTxnId !== 'string') {
      utils.logger.info('computing id', metaTxnId.config, metaTxnId.context, metaTxnId.chainId, ...metaTxnId.transactions);
      metaTxnId = transactions.computeMetaTxnHash(config.addressOf(metaTxnId.config, metaTxnId.context), metaTxnId.chainId, ...metaTxnId.transactions);
    }
    utils.logger.info(`[rpc-relayer/waitReceipt] waiting for ${metaTxnId}`);
    let fails = 0;
    while (isCancelled === undefined || !isCancelled()) {
      try {
        const {
          receipt
        } = await this.service.getMetaTxnReceipt({
          metaTxID: metaTxnId
        });
        if (receipt && receipt.txnReceipt && receipt.txnReceipt !== 'null' && FINAL_STATUSES.includes(receipt.status)) {
          return {
            receipt
          };
        }
      } catch (e) {
        fails++;
        if (fails === maxFails) {
          throw e;
        }
      }
      if (isCancelled === undefined || !isCancelled()) {
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }
    throw new Error(`Cancelled waiting for transaction receipt ${metaTxnId}`);
  }
  async simulate(wallet, ...transactions$1) {
    const coder = ethers.ethers.utils.defaultAbiCoder;
    const encoded = coder.encode([transactions.MetaTransactionsType], [transactions.sequenceTxAbiEncode(transactions$1)]);
    return (await this.service.simulate({
      wallet,
      transactions: encoded
    })).results;
  }
  async getFeeOptions(config$1, context, ...transactions$1) {
    // NOTE/TODO: for a given `service` the feeTokens will not change between execution, so we should memoize this value
    // for a short-period of time, perhaps for 1 day or in memory. Perhaps one day we can make this happen automatically
    // with http cache response for this endpoint and service-worker.. lots of approaches
    const feeTokens = await this.service.feeTokens();
    if (feeTokens.isFeeRequired) {
      const symbols = feeTokens.tokens.map(token => token.symbol).join(', ');
      utils.logger.info(`[rpc-relayer/getFeeOptions] relayer fees are required, accepted tokens are ${symbols}`);
      const wallet = config.addressOf(config$1, context);
      let nonce = transactions.readSequenceNonce(...transactions$1);
      if (nonce === undefined) {
        nonce = await this.getNonce(config$1, context);
      }
      if (!this.provider) {
        utils.logger.warn(`[rpc-relayer/getFeeOptions] provider not set, needed for stub signature`);
        throw new Error('provider is not set');
      }
      const {
        to,
        execute
      } = await this.prependWalletDeploy({
        config: config$1,
        context,
        transactions: transactions$1,
        nonce,
        signature: config.buildStubSignature(this.provider, config$1)
      });
      const walletInterface = new ethers.ethers.utils.Interface(abi.walletContracts.mainModule.abi);
      const data = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [transactions.sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);
      const {
        options,
        quote
      } = await this.service.feeOptions({
        wallet,
        to,
        data
      });
      utils.logger.info(`[rpc-relayer/getFeeOptions] got refund options ${JSON.stringify(options)}`);
      return {
        options,
        quote: {
          _tag: 'FeeQuote',
          _quote: quote
        }
      };
    } else {
      utils.logger.info(`[rpc-relayer/getFeeOptions] relayer fees are not required`);
      return {
        options: []
      };
    }
  }
  async gasRefundOptions(config, context, ...transactions) {
    const {
      options
    } = await this.getFeeOptions(config, context, ...transactions);
    return options;
  }
  async getNonce(config$1, context, space) {
    const addr = config.addressOf(config$1, context);
    utils.logger.info(`[rpc-relayer/getNonce] get nonce for wallet ${addr} space: ${space}`);
    const encodedNonce = space !== undefined ? ethers.ethers.BigNumber.from(space).toHexString() : undefined;
    const resp = await this.service.getMetaTxnNonce({
      walletContractAddress: addr,
      space: encodedNonce
    });
    const nonce = ethers.ethers.BigNumber.from(resp.nonce);
    const [decodedSpace, decodedNonce] = transactions.decodeNonce(nonce);
    utils.logger.info(`[rpc-relayer/getNonce] got next nonce for wallet ${addr} ${decodedNonce} space: ${decodedSpace}`);
    return nonce;
  }
  async relay(signedTxs, quote, waitForReceipt = true) {
    var _this = this;
    utils.logger.info(`[rpc-relayer/relay] relaying signed meta-transactions ${JSON.stringify(signedTxs)} with quote ${JSON.stringify(quote)}`);
    let typecheckedQuote;
    if (quote !== undefined) {
      if (typeof quote._quote === 'string') {
        typecheckedQuote = quote._quote;
      } else {
        utils.logger.warn('[rpc-relayer/relay] ignoring invalid fee quote');
      }
    }
    if (!this.provider) {
      utils.logger.warn(`[rpc-relayer/relay] provider not set, failed relay`);
      throw new Error('provider is not set');
    }
    const {
      to: contract,
      execute
    } = await this.prependWalletDeploy(signedTxs);
    const walletAddress = config.addressOf(signedTxs.config, signedTxs.context);
    const walletInterface = new ethers.ethers.utils.Interface(abi.walletContracts.mainModule.abi);
    const input = walletInterface.encodeFunctionData(walletInterface.getFunction('execute'), [transactions.sequenceTxAbiEncode(execute.transactions), execute.nonce, execute.signature]);
    const metaTxn = await this.service.sendMetaTxn({
      call: {
        walletAddress,
        contract,
        input
      },
      quote: typecheckedQuote
    });
    utils.logger.info(`[rpc-relayer/relay] got relay result ${JSON.stringify(metaTxn)}`);
    if (waitForReceipt) {
      return this.wait(metaTxn.txnHash);
    } else {
      const response = {
        hash: metaTxn.txnHash,
        confirmations: 0,
        from: walletAddress,
        wait: _confirmations => Promise.reject(new Error('impossible'))
      };
      const wait = async function wait(confirmations) {
        var _waitResponse$receipt;
        if (!_this.provider) {
          throw new Error('cannot wait for receipt, relayer has no provider set');
        }
        const waitResponse = await _this.wait(metaTxn.txnHash);
        const transactionHash = (_waitResponse$receipt = waitResponse.receipt) == null ? void 0 : _waitResponse$receipt.transactionHash;
        if (!transactionHash) {
          throw new Error('cannot wait for receipt, unknown native transaction hash');
        }
        Object.assign(response, waitResponse);
        return _this.provider.waitForTransaction(transactionHash, confirmations);
      };
      response.wait = wait;
      return response;
    }
  }
  async wait(metaTxnId, timeout, delay = 1000, maxFails = 5) {
    var _this2 = this;
    let timedOut = false;
    const {
      receipt
    } = await (timeout !== undefined ? Promise.race([this.waitReceipt(metaTxnId, delay, maxFails, () => timedOut), new Promise((_, reject) => setTimeout(() => {
      timedOut = true;
      reject(`Timeout waiting for transaction receipt ${metaTxnId}`);
    }, timeout))]) : this.waitReceipt(metaTxnId, delay, maxFails));
    if (!receipt.txnReceipt || FAILED_STATUSES.includes(receipt.status)) {
      throw new MetaTransactionResponseException(receipt);
    }
    const txReceipt = JSON.parse(receipt.txnReceipt);
    return {
      blockHash: txReceipt.blockHash,
      blockNumber: ethers.ethers.BigNumber.from(txReceipt.blockNumber).toNumber(),
      confirmations: 1,
      from: typeof metaTxnId === 'string' ? undefined : config.addressOf(metaTxnId.config, metaTxnId.context),
      hash: txReceipt.transactionHash,
      raw: receipt.txnReceipt,
      receipt: txReceipt,
      // extended type which is Sequence-specific. Contains the decoded metaTxReceipt
      wait: async function (confirmations) {
        return _this2.provider.waitForTransaction(txReceipt.transactionHash, confirmations);
      }
    };
  }
}
class MetaTransactionResponseException {
  constructor(receipt) {
    this.receipt = receipt;
  }
}

function isRelayer(cand) {
  return typeof cand === 'object' && typeof cand.simulate === 'function' && typeof cand.getFeeOptions === 'function' && typeof cand.gasRefundOptions === 'function' && typeof cand.getNonce === 'function' && typeof cand.relay === 'function' && typeof cand.wait === 'function';
}

exports.BaseRelayer = BaseRelayer;
exports.BaseRelayerDefaults = BaseRelayerDefaults;
exports.LocalRelayer = LocalRelayer;
exports.ProviderRelayer = ProviderRelayer;
exports.ProviderRelayerDefaults = ProviderRelayerDefaults;
exports.RpcRelayer = RpcRelayer;
exports.RpcRelayerProto = relayer_gen;
exports.isBaseRelayerOptions = isBaseRelayerOptions;
exports.isLocalRelayerOptions = isLocalRelayerOptions;
exports.isProviderRelayerOptions = isProviderRelayerOptions;
exports.isRelayer = isRelayer;
exports.isRpcRelayerOptions = isRpcRelayerOptions;
exports.proto = relayer_gen;

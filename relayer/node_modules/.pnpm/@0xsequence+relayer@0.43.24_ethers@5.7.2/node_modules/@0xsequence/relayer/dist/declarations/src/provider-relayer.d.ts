import { ethers, providers } from 'ethers';
import { SignedTransactions, Transaction, TransactionResponse } from '@0xsequence/transactions';
import { WalletContext } from '@0xsequence/network';
import { WalletConfig } from '@0xsequence/config';
import { BaseRelayer, BaseRelayerOptions } from './base-relayer';
import { FeeOption, FeeQuote, Relayer, SimulateResult } from '.';
import { Optionals, Mask } from '@0xsequence/utils';
export interface ProviderRelayerOptions extends BaseRelayerOptions {
    provider: providers.Provider;
    waitPollRate?: number;
    deltaBlocksLog?: number;
    fromBlockLog?: number;
}
export declare const ProviderRelayerDefaults: Required<Optionals<Mask<ProviderRelayerOptions, BaseRelayerOptions>>>;
export declare function isProviderRelayerOptions(obj: any): obj is ProviderRelayerOptions;
export declare abstract class ProviderRelayer extends BaseRelayer implements Relayer {
    provider: providers.Provider;
    waitPollRate: number;
    deltaBlocksLog: number;
    fromBlockLog: number;
    constructor(options: ProviderRelayerOptions);
    abstract getFeeOptions(config: WalletConfig, context: WalletContext, ...transactions: Transaction[]): Promise<{
        options: FeeOption[];
        quote?: FeeQuote;
    }>;
    abstract gasRefundOptions(config: WalletConfig, context: WalletContext, ...transactions: Transaction[]): Promise<FeeOption[]>;
    abstract relay(signedTxs: SignedTransactions, quote?: FeeQuote, waitForReceipt?: boolean): Promise<TransactionResponse>;
    simulate(wallet: string, ...transactions: Transaction[]): Promise<SimulateResult[]>;
    getNonce(config: WalletConfig, context: WalletContext, space?: ethers.BigNumberish, blockTag?: providers.BlockTag): Promise<ethers.BigNumberish>;
    wait(metaTxnId: string | SignedTransactions, timeout?: number, delay?: number, maxFails?: number): Promise<providers.TransactionResponse & {
        receipt: providers.TransactionReceipt;
    }>;
}

import { BigNumberish, BytesLike, TypedDataDomain, TypedDataField } from 'ethers';
import { WalletContext, ChainIdLike } from '@0xsequence/network';
import { TypedData } from '@0xsequence/utils';
import { DecodedSignature, WalletConfig } from '@0xsequence/config';
import { Wallet } from '../wallet';
export declare class WalletUtils {
    private wallet;
    constructor(walletProvider: Wallet);
    signMessage(message: BytesLike, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    signAuthMessage(message: BytesLike, allSigners?: boolean): Promise<string>;
    signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>, chainId?: ChainIdLike, allSigners?: boolean): Promise<string>;
    signAuthTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, message: Record<string, any>, allSigners?: boolean): Promise<string>;
    isValidSignature(address: string, digest: Uint8Array, signature: string, chainId: number, walletContext?: WalletContext): Promise<boolean>;
    isValidMessageSignature(address: string, message: string | Uint8Array, signature: string, chainId: number, walletContext?: WalletContext): Promise<boolean>;
    isValidTypedDataSignature(address: string, typedData: TypedData, signature: string, chainId: number, walletContext?: WalletContext): Promise<boolean>;
    recoverWalletConfig: (address: string, digest: BytesLike, signature: string | DecodedSignature, chainId: BigNumberish, walletContext?: WalletContext) => Promise<WalletConfig>;
    recoverWalletConfigFromMessage: (address: string, message: string | Uint8Array, signature: string | DecodedSignature, chainId: BigNumberish, walletContext?: WalletContext) => Promise<WalletConfig>;
    recoverWalletConfigFromTypedData: (address: string, typedData: TypedData, signature: string | DecodedSignature, chainId: BigNumberish, walletContext?: WalletContext) => Promise<WalletConfig>;
}
